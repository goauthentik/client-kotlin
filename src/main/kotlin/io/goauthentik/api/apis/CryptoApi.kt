/**
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2023.10.1
 * Contact: hello@goauthentik.io
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.CertificateData
import io.goauthentik.api.models.CertificateGenerationRequest
import io.goauthentik.api.models.CertificateKeyPair
import io.goauthentik.api.models.CertificateKeyPairRequest
import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.PaginatedCertificateKeyPairList
import io.goauthentik.api.models.PatchedCertificateKeyPairRequest
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.ValidationError

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class CryptoApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param certificateKeyPairRequest 
     * @return CertificateKeyPair
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cryptoCertificatekeypairsCreate(certificateKeyPairRequest: CertificateKeyPairRequest) : CertificateKeyPair {
        val localVarResponse = cryptoCertificatekeypairsCreateWithHttpInfo(certificateKeyPairRequest = certificateKeyPairRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CertificateKeyPair
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param certificateKeyPairRequest 
     * @return ApiResponse<CertificateKeyPair?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cryptoCertificatekeypairsCreateWithHttpInfo(certificateKeyPairRequest: CertificateKeyPairRequest) : ApiResponse<CertificateKeyPair?> {
        val localVariableConfig = cryptoCertificatekeypairsCreateRequestConfig(certificateKeyPairRequest = certificateKeyPairRequest)

        return request<CertificateKeyPairRequest, CertificateKeyPair>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cryptoCertificatekeypairsCreate
     *
     * @param certificateKeyPairRequest 
     * @return RequestConfig
     */
    fun cryptoCertificatekeypairsCreateRequestConfig(certificateKeyPairRequest: CertificateKeyPairRequest) : RequestConfig<CertificateKeyPairRequest> {
        val localVariableBody = certificateKeyPairRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crypto/certificatekeypairs/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cryptoCertificatekeypairsDestroy(kpUuid: java.util.UUID) : Unit {
        val localVarResponse = cryptoCertificatekeypairsDestroyWithHttpInfo(kpUuid = kpUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun cryptoCertificatekeypairsDestroyWithHttpInfo(kpUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = cryptoCertificatekeypairsDestroyRequestConfig(kpUuid = kpUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cryptoCertificatekeypairsDestroy
     *
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @return RequestConfig
     */
    fun cryptoCertificatekeypairsDestroyRequestConfig(kpUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/crypto/certificatekeypairs/{kp_uuid}/".replace("{"+"kp_uuid"+"}", encodeURIComponent(kpUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Generate a new, self-signed certificate-key pair
     * @param certificateGenerationRequest 
     * @return CertificateKeyPair
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cryptoCertificatekeypairsGenerateCreate(certificateGenerationRequest: CertificateGenerationRequest) : CertificateKeyPair {
        val localVarResponse = cryptoCertificatekeypairsGenerateCreateWithHttpInfo(certificateGenerationRequest = certificateGenerationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CertificateKeyPair
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Generate a new, self-signed certificate-key pair
     * @param certificateGenerationRequest 
     * @return ApiResponse<CertificateKeyPair?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cryptoCertificatekeypairsGenerateCreateWithHttpInfo(certificateGenerationRequest: CertificateGenerationRequest) : ApiResponse<CertificateKeyPair?> {
        val localVariableConfig = cryptoCertificatekeypairsGenerateCreateRequestConfig(certificateGenerationRequest = certificateGenerationRequest)

        return request<CertificateGenerationRequest, CertificateKeyPair>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cryptoCertificatekeypairsGenerateCreate
     *
     * @param certificateGenerationRequest 
     * @return RequestConfig
     */
    fun cryptoCertificatekeypairsGenerateCreateRequestConfig(certificateGenerationRequest: CertificateGenerationRequest) : RequestConfig<CertificateGenerationRequest> {
        val localVariableBody = certificateGenerationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crypto/certificatekeypairs/generate/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param hasKey Only return certificate-key pairs with keys (optional)
     * @param includeDetails  (optional, default to true)
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedCertificateKeyPairList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cryptoCertificatekeypairsList(hasKey: kotlin.Boolean? = null, includeDetails: kotlin.Boolean? = true, managed: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedCertificateKeyPairList {
        val localVarResponse = cryptoCertificatekeypairsListWithHttpInfo(hasKey = hasKey, includeDetails = includeDetails, managed = managed, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedCertificateKeyPairList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param hasKey Only return certificate-key pairs with keys (optional)
     * @param includeDetails  (optional, default to true)
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedCertificateKeyPairList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cryptoCertificatekeypairsListWithHttpInfo(hasKey: kotlin.Boolean?, includeDetails: kotlin.Boolean?, managed: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedCertificateKeyPairList?> {
        val localVariableConfig = cryptoCertificatekeypairsListRequestConfig(hasKey = hasKey, includeDetails = includeDetails, managed = managed, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedCertificateKeyPairList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cryptoCertificatekeypairsList
     *
     * @param hasKey Only return certificate-key pairs with keys (optional)
     * @param includeDetails  (optional, default to true)
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun cryptoCertificatekeypairsListRequestConfig(hasKey: kotlin.Boolean?, includeDetails: kotlin.Boolean?, managed: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (hasKey != null) {
                    put("has_key", listOf(hasKey.toString()))
                }
                if (includeDetails != null) {
                    put("include_details", listOf(includeDetails.toString()))
                }
                if (managed != null) {
                    put("managed", listOf(managed.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crypto/certificatekeypairs/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param patchedCertificateKeyPairRequest  (optional)
     * @return CertificateKeyPair
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cryptoCertificatekeypairsPartialUpdate(kpUuid: java.util.UUID, patchedCertificateKeyPairRequest: PatchedCertificateKeyPairRequest? = null) : CertificateKeyPair {
        val localVarResponse = cryptoCertificatekeypairsPartialUpdateWithHttpInfo(kpUuid = kpUuid, patchedCertificateKeyPairRequest = patchedCertificateKeyPairRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CertificateKeyPair
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param patchedCertificateKeyPairRequest  (optional)
     * @return ApiResponse<CertificateKeyPair?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cryptoCertificatekeypairsPartialUpdateWithHttpInfo(kpUuid: java.util.UUID, patchedCertificateKeyPairRequest: PatchedCertificateKeyPairRequest?) : ApiResponse<CertificateKeyPair?> {
        val localVariableConfig = cryptoCertificatekeypairsPartialUpdateRequestConfig(kpUuid = kpUuid, patchedCertificateKeyPairRequest = patchedCertificateKeyPairRequest)

        return request<PatchedCertificateKeyPairRequest, CertificateKeyPair>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cryptoCertificatekeypairsPartialUpdate
     *
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param patchedCertificateKeyPairRequest  (optional)
     * @return RequestConfig
     */
    fun cryptoCertificatekeypairsPartialUpdateRequestConfig(kpUuid: java.util.UUID, patchedCertificateKeyPairRequest: PatchedCertificateKeyPairRequest?) : RequestConfig<PatchedCertificateKeyPairRequest> {
        val localVariableBody = patchedCertificateKeyPairRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/crypto/certificatekeypairs/{kp_uuid}/".replace("{"+"kp_uuid"+"}", encodeURIComponent(kpUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @return CertificateKeyPair
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cryptoCertificatekeypairsRetrieve(kpUuid: java.util.UUID) : CertificateKeyPair {
        val localVarResponse = cryptoCertificatekeypairsRetrieveWithHttpInfo(kpUuid = kpUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CertificateKeyPair
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @return ApiResponse<CertificateKeyPair?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cryptoCertificatekeypairsRetrieveWithHttpInfo(kpUuid: java.util.UUID) : ApiResponse<CertificateKeyPair?> {
        val localVariableConfig = cryptoCertificatekeypairsRetrieveRequestConfig(kpUuid = kpUuid)

        return request<Unit, CertificateKeyPair>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cryptoCertificatekeypairsRetrieve
     *
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @return RequestConfig
     */
    fun cryptoCertificatekeypairsRetrieveRequestConfig(kpUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crypto/certificatekeypairs/{kp_uuid}/".replace("{"+"kp_uuid"+"}", encodeURIComponent(kpUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param certificateKeyPairRequest 
     * @return CertificateKeyPair
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cryptoCertificatekeypairsUpdate(kpUuid: java.util.UUID, certificateKeyPairRequest: CertificateKeyPairRequest) : CertificateKeyPair {
        val localVarResponse = cryptoCertificatekeypairsUpdateWithHttpInfo(kpUuid = kpUuid, certificateKeyPairRequest = certificateKeyPairRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CertificateKeyPair
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CertificateKeyPair Viewset
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param certificateKeyPairRequest 
     * @return ApiResponse<CertificateKeyPair?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cryptoCertificatekeypairsUpdateWithHttpInfo(kpUuid: java.util.UUID, certificateKeyPairRequest: CertificateKeyPairRequest) : ApiResponse<CertificateKeyPair?> {
        val localVariableConfig = cryptoCertificatekeypairsUpdateRequestConfig(kpUuid = kpUuid, certificateKeyPairRequest = certificateKeyPairRequest)

        return request<CertificateKeyPairRequest, CertificateKeyPair>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cryptoCertificatekeypairsUpdate
     *
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param certificateKeyPairRequest 
     * @return RequestConfig
     */
    fun cryptoCertificatekeypairsUpdateRequestConfig(kpUuid: java.util.UUID, certificateKeyPairRequest: CertificateKeyPairRequest) : RequestConfig<CertificateKeyPairRequest> {
        val localVariableBody = certificateKeyPairRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/crypto/certificatekeypairs/{kp_uuid}/".replace("{"+"kp_uuid"+"}", encodeURIComponent(kpUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cryptoCertificatekeypairsUsedByList(kpUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = cryptoCertificatekeypairsUsedByListWithHttpInfo(kpUuid = kpUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cryptoCertificatekeypairsUsedByListWithHttpInfo(kpUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = cryptoCertificatekeypairsUsedByListRequestConfig(kpUuid = kpUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cryptoCertificatekeypairsUsedByList
     *
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @return RequestConfig
     */
    fun cryptoCertificatekeypairsUsedByListRequestConfig(kpUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crypto/certificatekeypairs/{kp_uuid}/used_by/".replace("{"+"kp_uuid"+"}", encodeURIComponent(kpUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Return certificate-key pairs certificate and log access
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param download  (optional)
     * @return CertificateData
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cryptoCertificatekeypairsViewCertificateRetrieve(kpUuid: java.util.UUID, download: kotlin.Boolean? = null) : CertificateData {
        val localVarResponse = cryptoCertificatekeypairsViewCertificateRetrieveWithHttpInfo(kpUuid = kpUuid, download = download)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CertificateData
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Return certificate-key pairs certificate and log access
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param download  (optional)
     * @return ApiResponse<CertificateData?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cryptoCertificatekeypairsViewCertificateRetrieveWithHttpInfo(kpUuid: java.util.UUID, download: kotlin.Boolean?) : ApiResponse<CertificateData?> {
        val localVariableConfig = cryptoCertificatekeypairsViewCertificateRetrieveRequestConfig(kpUuid = kpUuid, download = download)

        return request<Unit, CertificateData>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cryptoCertificatekeypairsViewCertificateRetrieve
     *
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param download  (optional)
     * @return RequestConfig
     */
    fun cryptoCertificatekeypairsViewCertificateRetrieveRequestConfig(kpUuid: java.util.UUID, download: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (download != null) {
                    put("download", listOf(download.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crypto/certificatekeypairs/{kp_uuid}/view_certificate/".replace("{"+"kp_uuid"+"}", encodeURIComponent(kpUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Return certificate-key pairs private key and log access
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param download  (optional)
     * @return CertificateData
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cryptoCertificatekeypairsViewPrivateKeyRetrieve(kpUuid: java.util.UUID, download: kotlin.Boolean? = null) : CertificateData {
        val localVarResponse = cryptoCertificatekeypairsViewPrivateKeyRetrieveWithHttpInfo(kpUuid = kpUuid, download = download)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CertificateData
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Return certificate-key pairs private key and log access
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param download  (optional)
     * @return ApiResponse<CertificateData?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cryptoCertificatekeypairsViewPrivateKeyRetrieveWithHttpInfo(kpUuid: java.util.UUID, download: kotlin.Boolean?) : ApiResponse<CertificateData?> {
        val localVariableConfig = cryptoCertificatekeypairsViewPrivateKeyRetrieveRequestConfig(kpUuid = kpUuid, download = download)

        return request<Unit, CertificateData>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cryptoCertificatekeypairsViewPrivateKeyRetrieve
     *
     * @param kpUuid A UUID string identifying this Certificate-Key Pair.
     * @param download  (optional)
     * @return RequestConfig
     */
    fun cryptoCertificatekeypairsViewPrivateKeyRetrieveRequestConfig(kpUuid: java.util.UUID, download: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (download != null) {
                    put("download", listOf(download.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crypto/certificatekeypairs/{kp_uuid}/view_private_key/".replace("{"+"kp_uuid"+"}", encodeURIComponent(kpUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
