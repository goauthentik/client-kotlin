/**
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2023.10.2
 * Contact: hello@goauthentik.io
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.Cache
import io.goauthentik.api.models.DummyPolicy
import io.goauthentik.api.models.DummyPolicyRequest
import io.goauthentik.api.models.EventMatcherPolicy
import io.goauthentik.api.models.EventMatcherPolicyRequest
import io.goauthentik.api.models.ExpressionPolicy
import io.goauthentik.api.models.ExpressionPolicyRequest
import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.PaginatedDummyPolicyList
import io.goauthentik.api.models.PaginatedEventMatcherPolicyList
import io.goauthentik.api.models.PaginatedExpressionPolicyList
import io.goauthentik.api.models.PaginatedPasswordExpiryPolicyList
import io.goauthentik.api.models.PaginatedPasswordPolicyList
import io.goauthentik.api.models.PaginatedPolicyBindingList
import io.goauthentik.api.models.PaginatedPolicyList
import io.goauthentik.api.models.PaginatedReputationList
import io.goauthentik.api.models.PaginatedReputationPolicyList
import io.goauthentik.api.models.PasswordExpiryPolicy
import io.goauthentik.api.models.PasswordExpiryPolicyRequest
import io.goauthentik.api.models.PasswordPolicy
import io.goauthentik.api.models.PasswordPolicyRequest
import io.goauthentik.api.models.PatchedDummyPolicyRequest
import io.goauthentik.api.models.PatchedEventMatcherPolicyRequest
import io.goauthentik.api.models.PatchedExpressionPolicyRequest
import io.goauthentik.api.models.PatchedPasswordExpiryPolicyRequest
import io.goauthentik.api.models.PatchedPasswordPolicyRequest
import io.goauthentik.api.models.PatchedPolicyBindingRequest
import io.goauthentik.api.models.PatchedReputationPolicyRequest
import io.goauthentik.api.models.Policy
import io.goauthentik.api.models.PolicyBinding
import io.goauthentik.api.models.PolicyBindingRequest
import io.goauthentik.api.models.PolicyTestRequest
import io.goauthentik.api.models.PolicyTestResult
import io.goauthentik.api.models.Reputation
import io.goauthentik.api.models.ReputationPolicy
import io.goauthentik.api.models.ReputationPolicyRequest
import io.goauthentik.api.models.TypeCreate
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.ValidationError

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class PoliciesApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * Clear policy cache
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesAllCacheClearCreate() : Unit {
        val localVarResponse = policiesAllCacheClearCreateWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Clear policy cache
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesAllCacheClearCreateWithHttpInfo() : ApiResponse<Unit?> {
        val localVariableConfig = policiesAllCacheClearCreateRequestConfig()

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesAllCacheClearCreate
     *
     * @return RequestConfig
     */
    fun policiesAllCacheClearCreateRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/policies/all/cache_clear/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Info about cached policies
     * @return Cache
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesAllCacheInfoRetrieve() : Cache {
        val localVarResponse = policiesAllCacheInfoRetrieveWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Cache
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Info about cached policies
     * @return ApiResponse<Cache?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesAllCacheInfoRetrieveWithHttpInfo() : ApiResponse<Cache?> {
        val localVariableConfig = policiesAllCacheInfoRetrieveRequestConfig()

        return request<Unit, Cache>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesAllCacheInfoRetrieve
     *
     * @return RequestConfig
     */
    fun policiesAllCacheInfoRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/all/cache_info/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Policy Viewset
     * @param policyUuid A UUID string identifying this Policy.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesAllDestroy(policyUuid: java.util.UUID) : Unit {
        val localVarResponse = policiesAllDestroyWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Policy Viewset
     * @param policyUuid A UUID string identifying this Policy.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesAllDestroyWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = policiesAllDestroyRequestConfig(policyUuid = policyUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesAllDestroy
     *
     * @param policyUuid A UUID string identifying this Policy.
     * @return RequestConfig
     */
    fun policiesAllDestroyRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/policies/all/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Policy Viewset
     * @param bindingsIsnull  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param promptstageIsnull  (optional)
     * @param search A search term. (optional)
     * @return PaginatedPolicyList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesAllList(bindingsIsnull: kotlin.Boolean? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, promptstageIsnull: kotlin.Boolean? = null, search: kotlin.String? = null) : PaginatedPolicyList {
        val localVarResponse = policiesAllListWithHttpInfo(bindingsIsnull = bindingsIsnull, ordering = ordering, page = page, pageSize = pageSize, promptstageIsnull = promptstageIsnull, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPolicyList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Policy Viewset
     * @param bindingsIsnull  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param promptstageIsnull  (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedPolicyList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesAllListWithHttpInfo(bindingsIsnull: kotlin.Boolean?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, promptstageIsnull: kotlin.Boolean?, search: kotlin.String?) : ApiResponse<PaginatedPolicyList?> {
        val localVariableConfig = policiesAllListRequestConfig(bindingsIsnull = bindingsIsnull, ordering = ordering, page = page, pageSize = pageSize, promptstageIsnull = promptstageIsnull, search = search)

        return request<Unit, PaginatedPolicyList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesAllList
     *
     * @param bindingsIsnull  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param promptstageIsnull  (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun policiesAllListRequestConfig(bindingsIsnull: kotlin.Boolean?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, promptstageIsnull: kotlin.Boolean?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (bindingsIsnull != null) {
                    put("bindings__isnull", listOf(bindingsIsnull.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (promptstageIsnull != null) {
                    put("promptstage__isnull", listOf(promptstageIsnull.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/all/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Policy Viewset
     * @param policyUuid A UUID string identifying this Policy.
     * @return Policy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesAllRetrieve(policyUuid: java.util.UUID) : Policy {
        val localVarResponse = policiesAllRetrieveWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Policy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Policy Viewset
     * @param policyUuid A UUID string identifying this Policy.
     * @return ApiResponse<Policy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesAllRetrieveWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<Policy?> {
        val localVariableConfig = policiesAllRetrieveRequestConfig(policyUuid = policyUuid)

        return request<Unit, Policy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesAllRetrieve
     *
     * @param policyUuid A UUID string identifying this Policy.
     * @return RequestConfig
     */
    fun policiesAllRetrieveRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/all/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Test policy
     * @param policyUuid A UUID string identifying this Policy.
     * @param policyTestRequest 
     * @return PolicyTestResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesAllTestCreate(policyUuid: java.util.UUID, policyTestRequest: PolicyTestRequest) : PolicyTestResult {
        val localVarResponse = policiesAllTestCreateWithHttpInfo(policyUuid = policyUuid, policyTestRequest = policyTestRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyTestResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Test policy
     * @param policyUuid A UUID string identifying this Policy.
     * @param policyTestRequest 
     * @return ApiResponse<PolicyTestResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesAllTestCreateWithHttpInfo(policyUuid: java.util.UUID, policyTestRequest: PolicyTestRequest) : ApiResponse<PolicyTestResult?> {
        val localVariableConfig = policiesAllTestCreateRequestConfig(policyUuid = policyUuid, policyTestRequest = policyTestRequest)

        return request<PolicyTestRequest, PolicyTestResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesAllTestCreate
     *
     * @param policyUuid A UUID string identifying this Policy.
     * @param policyTestRequest 
     * @return RequestConfig
     */
    fun policiesAllTestCreateRequestConfig(policyUuid: java.util.UUID, policyTestRequest: PolicyTestRequest) : RequestConfig<PolicyTestRequest> {
        val localVariableBody = policyTestRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/policies/all/{policy_uuid}/test/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all creatable policy types
     * @return kotlin.collections.List<TypeCreate>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesAllTypesList() : kotlin.collections.List<TypeCreate> {
        val localVarResponse = policiesAllTypesListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TypeCreate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all creatable policy types
     * @return ApiResponse<kotlin.collections.List<TypeCreate>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesAllTypesListWithHttpInfo() : ApiResponse<kotlin.collections.List<TypeCreate>?> {
        val localVariableConfig = policiesAllTypesListRequestConfig()

        return request<Unit, kotlin.collections.List<TypeCreate>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesAllTypesList
     *
     * @return RequestConfig
     */
    fun policiesAllTypesListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/all/types/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Policy.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesAllUsedByList(policyUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = policiesAllUsedByListWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Policy.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesAllUsedByListWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = policiesAllUsedByListRequestConfig(policyUuid = policyUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesAllUsedByList
     *
     * @param policyUuid A UUID string identifying this Policy.
     * @return RequestConfig
     */
    fun policiesAllUsedByListRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/all/{policy_uuid}/used_by/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param policyBindingRequest 
     * @return PolicyBinding
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesBindingsCreate(policyBindingRequest: PolicyBindingRequest) : PolicyBinding {
        val localVarResponse = policiesBindingsCreateWithHttpInfo(policyBindingRequest = policyBindingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyBinding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param policyBindingRequest 
     * @return ApiResponse<PolicyBinding?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesBindingsCreateWithHttpInfo(policyBindingRequest: PolicyBindingRequest) : ApiResponse<PolicyBinding?> {
        val localVariableConfig = policiesBindingsCreateRequestConfig(policyBindingRequest = policyBindingRequest)

        return request<PolicyBindingRequest, PolicyBinding>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesBindingsCreate
     *
     * @param policyBindingRequest 
     * @return RequestConfig
     */
    fun policiesBindingsCreateRequestConfig(policyBindingRequest: PolicyBindingRequest) : RequestConfig<PolicyBindingRequest> {
        val localVariableBody = policyBindingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/policies/bindings/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesBindingsDestroy(policyBindingUuid: java.util.UUID) : Unit {
        val localVarResponse = policiesBindingsDestroyWithHttpInfo(policyBindingUuid = policyBindingUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesBindingsDestroyWithHttpInfo(policyBindingUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = policiesBindingsDestroyRequestConfig(policyBindingUuid = policyBindingUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesBindingsDestroy
     *
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @return RequestConfig
     */
    fun policiesBindingsDestroyRequestConfig(policyBindingUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/policies/bindings/{policy_binding_uuid}/".replace("{"+"policy_binding_uuid"+"}", encodeURIComponent(policyBindingUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param enabled  (optional)
     * @param order  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policy  (optional)
     * @param policyIsnull  (optional)
     * @param search A search term. (optional)
     * @param target  (optional)
     * @param targetIn  (optional)
     * @param timeout  (optional)
     * @return PaginatedPolicyBindingList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesBindingsList(enabled: kotlin.Boolean? = null, order: kotlin.Int? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, policy: java.util.UUID? = null, policyIsnull: kotlin.Boolean? = null, search: kotlin.String? = null, target: java.util.UUID? = null, targetIn: kotlin.collections.List<java.util.UUID>? = null, timeout: kotlin.Int? = null) : PaginatedPolicyBindingList {
        val localVarResponse = policiesBindingsListWithHttpInfo(enabled = enabled, order = order, ordering = ordering, page = page, pageSize = pageSize, policy = policy, policyIsnull = policyIsnull, search = search, target = target, targetIn = targetIn, timeout = timeout)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPolicyBindingList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param enabled  (optional)
     * @param order  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policy  (optional)
     * @param policyIsnull  (optional)
     * @param search A search term. (optional)
     * @param target  (optional)
     * @param targetIn  (optional)
     * @param timeout  (optional)
     * @return ApiResponse<PaginatedPolicyBindingList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesBindingsListWithHttpInfo(enabled: kotlin.Boolean?, order: kotlin.Int?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policy: java.util.UUID?, policyIsnull: kotlin.Boolean?, search: kotlin.String?, target: java.util.UUID?, targetIn: kotlin.collections.List<java.util.UUID>?, timeout: kotlin.Int?) : ApiResponse<PaginatedPolicyBindingList?> {
        val localVariableConfig = policiesBindingsListRequestConfig(enabled = enabled, order = order, ordering = ordering, page = page, pageSize = pageSize, policy = policy, policyIsnull = policyIsnull, search = search, target = target, targetIn = targetIn, timeout = timeout)

        return request<Unit, PaginatedPolicyBindingList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesBindingsList
     *
     * @param enabled  (optional)
     * @param order  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policy  (optional)
     * @param policyIsnull  (optional)
     * @param search A search term. (optional)
     * @param target  (optional)
     * @param targetIn  (optional)
     * @param timeout  (optional)
     * @return RequestConfig
     */
    fun policiesBindingsListRequestConfig(enabled: kotlin.Boolean?, order: kotlin.Int?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policy: java.util.UUID?, policyIsnull: kotlin.Boolean?, search: kotlin.String?, target: java.util.UUID?, targetIn: kotlin.collections.List<java.util.UUID>?, timeout: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (enabled != null) {
                    put("enabled", listOf(enabled.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (policy != null) {
                    put("policy", listOf(policy.toString()))
                }
                if (policyIsnull != null) {
                    put("policy__isnull", listOf(policyIsnull.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (target != null) {
                    put("target", listOf(target.toString()))
                }
                if (targetIn != null) {
                    put("target_in", toMultiValue(targetIn.toList(), "multi"))
                }
                if (timeout != null) {
                    put("timeout", listOf(timeout.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/bindings/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @param patchedPolicyBindingRequest  (optional)
     * @return PolicyBinding
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesBindingsPartialUpdate(policyBindingUuid: java.util.UUID, patchedPolicyBindingRequest: PatchedPolicyBindingRequest? = null) : PolicyBinding {
        val localVarResponse = policiesBindingsPartialUpdateWithHttpInfo(policyBindingUuid = policyBindingUuid, patchedPolicyBindingRequest = patchedPolicyBindingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyBinding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @param patchedPolicyBindingRequest  (optional)
     * @return ApiResponse<PolicyBinding?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesBindingsPartialUpdateWithHttpInfo(policyBindingUuid: java.util.UUID, patchedPolicyBindingRequest: PatchedPolicyBindingRequest?) : ApiResponse<PolicyBinding?> {
        val localVariableConfig = policiesBindingsPartialUpdateRequestConfig(policyBindingUuid = policyBindingUuid, patchedPolicyBindingRequest = patchedPolicyBindingRequest)

        return request<PatchedPolicyBindingRequest, PolicyBinding>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesBindingsPartialUpdate
     *
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @param patchedPolicyBindingRequest  (optional)
     * @return RequestConfig
     */
    fun policiesBindingsPartialUpdateRequestConfig(policyBindingUuid: java.util.UUID, patchedPolicyBindingRequest: PatchedPolicyBindingRequest?) : RequestConfig<PatchedPolicyBindingRequest> {
        val localVariableBody = patchedPolicyBindingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/policies/bindings/{policy_binding_uuid}/".replace("{"+"policy_binding_uuid"+"}", encodeURIComponent(policyBindingUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @return PolicyBinding
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesBindingsRetrieve(policyBindingUuid: java.util.UUID) : PolicyBinding {
        val localVarResponse = policiesBindingsRetrieveWithHttpInfo(policyBindingUuid = policyBindingUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyBinding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @return ApiResponse<PolicyBinding?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesBindingsRetrieveWithHttpInfo(policyBindingUuid: java.util.UUID) : ApiResponse<PolicyBinding?> {
        val localVariableConfig = policiesBindingsRetrieveRequestConfig(policyBindingUuid = policyBindingUuid)

        return request<Unit, PolicyBinding>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesBindingsRetrieve
     *
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @return RequestConfig
     */
    fun policiesBindingsRetrieveRequestConfig(policyBindingUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/bindings/{policy_binding_uuid}/".replace("{"+"policy_binding_uuid"+"}", encodeURIComponent(policyBindingUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @param policyBindingRequest 
     * @return PolicyBinding
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesBindingsUpdate(policyBindingUuid: java.util.UUID, policyBindingRequest: PolicyBindingRequest) : PolicyBinding {
        val localVarResponse = policiesBindingsUpdateWithHttpInfo(policyBindingUuid = policyBindingUuid, policyBindingRequest = policyBindingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyBinding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PolicyBinding Viewset
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @param policyBindingRequest 
     * @return ApiResponse<PolicyBinding?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesBindingsUpdateWithHttpInfo(policyBindingUuid: java.util.UUID, policyBindingRequest: PolicyBindingRequest) : ApiResponse<PolicyBinding?> {
        val localVariableConfig = policiesBindingsUpdateRequestConfig(policyBindingUuid = policyBindingUuid, policyBindingRequest = policyBindingRequest)

        return request<PolicyBindingRequest, PolicyBinding>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesBindingsUpdate
     *
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @param policyBindingRequest 
     * @return RequestConfig
     */
    fun policiesBindingsUpdateRequestConfig(policyBindingUuid: java.util.UUID, policyBindingRequest: PolicyBindingRequest) : RequestConfig<PolicyBindingRequest> {
        val localVariableBody = policyBindingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/policies/bindings/{policy_binding_uuid}/".replace("{"+"policy_binding_uuid"+"}", encodeURIComponent(policyBindingUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesBindingsUsedByList(policyBindingUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = policiesBindingsUsedByListWithHttpInfo(policyBindingUuid = policyBindingUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesBindingsUsedByListWithHttpInfo(policyBindingUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = policiesBindingsUsedByListRequestConfig(policyBindingUuid = policyBindingUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesBindingsUsedByList
     *
     * @param policyBindingUuid A UUID string identifying this Policy Binding.
     * @return RequestConfig
     */
    fun policiesBindingsUsedByListRequestConfig(policyBindingUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/bindings/{policy_binding_uuid}/used_by/".replace("{"+"policy_binding_uuid"+"}", encodeURIComponent(policyBindingUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Dummy Viewset
     * @param dummyPolicyRequest 
     * @return DummyPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesDummyCreate(dummyPolicyRequest: DummyPolicyRequest) : DummyPolicy {
        val localVarResponse = policiesDummyCreateWithHttpInfo(dummyPolicyRequest = dummyPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DummyPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Dummy Viewset
     * @param dummyPolicyRequest 
     * @return ApiResponse<DummyPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesDummyCreateWithHttpInfo(dummyPolicyRequest: DummyPolicyRequest) : ApiResponse<DummyPolicy?> {
        val localVariableConfig = policiesDummyCreateRequestConfig(dummyPolicyRequest = dummyPolicyRequest)

        return request<DummyPolicyRequest, DummyPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesDummyCreate
     *
     * @param dummyPolicyRequest 
     * @return RequestConfig
     */
    fun policiesDummyCreateRequestConfig(dummyPolicyRequest: DummyPolicyRequest) : RequestConfig<DummyPolicyRequest> {
        val localVariableBody = dummyPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/policies/dummy/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Dummy Viewset
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesDummyDestroy(policyUuid: java.util.UUID) : Unit {
        val localVarResponse = policiesDummyDestroyWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Dummy Viewset
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesDummyDestroyWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = policiesDummyDestroyRequestConfig(policyUuid = policyUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesDummyDestroy
     *
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @return RequestConfig
     */
    fun policiesDummyDestroyRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/policies/dummy/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Dummy Viewset
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param result  (optional)
     * @param search A search term. (optional)
     * @param waitMax  (optional)
     * @param waitMin  (optional)
     * @return PaginatedDummyPolicyList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesDummyList(created: java.time.OffsetDateTime? = null, executionLogging: kotlin.Boolean? = null, lastUpdated: java.time.OffsetDateTime? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, policyUuid: java.util.UUID? = null, result: kotlin.Boolean? = null, search: kotlin.String? = null, waitMax: kotlin.Int? = null, waitMin: kotlin.Int? = null) : PaginatedDummyPolicyList {
        val localVarResponse = policiesDummyListWithHttpInfo(created = created, executionLogging = executionLogging, lastUpdated = lastUpdated, name = name, ordering = ordering, page = page, pageSize = pageSize, policyUuid = policyUuid, result = result, search = search, waitMax = waitMax, waitMin = waitMin)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDummyPolicyList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Dummy Viewset
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param result  (optional)
     * @param search A search term. (optional)
     * @param waitMax  (optional)
     * @param waitMin  (optional)
     * @return ApiResponse<PaginatedDummyPolicyList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesDummyListWithHttpInfo(created: java.time.OffsetDateTime?, executionLogging: kotlin.Boolean?, lastUpdated: java.time.OffsetDateTime?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyUuid: java.util.UUID?, result: kotlin.Boolean?, search: kotlin.String?, waitMax: kotlin.Int?, waitMin: kotlin.Int?) : ApiResponse<PaginatedDummyPolicyList?> {
        val localVariableConfig = policiesDummyListRequestConfig(created = created, executionLogging = executionLogging, lastUpdated = lastUpdated, name = name, ordering = ordering, page = page, pageSize = pageSize, policyUuid = policyUuid, result = result, search = search, waitMax = waitMax, waitMin = waitMin)

        return request<Unit, PaginatedDummyPolicyList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesDummyList
     *
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param result  (optional)
     * @param search A search term. (optional)
     * @param waitMax  (optional)
     * @param waitMin  (optional)
     * @return RequestConfig
     */
    fun policiesDummyListRequestConfig(created: java.time.OffsetDateTime?, executionLogging: kotlin.Boolean?, lastUpdated: java.time.OffsetDateTime?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyUuid: java.util.UUID?, result: kotlin.Boolean?, search: kotlin.String?, waitMax: kotlin.Int?, waitMin: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (created != null) {
                    put("created", listOf(parseDateToQueryString(created)))
                }
                if (executionLogging != null) {
                    put("execution_logging", listOf(executionLogging.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(parseDateToQueryString(lastUpdated)))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (policyUuid != null) {
                    put("policy_uuid", listOf(policyUuid.toString()))
                }
                if (result != null) {
                    put("result", listOf(result.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (waitMax != null) {
                    put("wait_max", listOf(waitMax.toString()))
                }
                if (waitMin != null) {
                    put("wait_min", listOf(waitMin.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/dummy/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Dummy Viewset
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @param patchedDummyPolicyRequest  (optional)
     * @return DummyPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesDummyPartialUpdate(policyUuid: java.util.UUID, patchedDummyPolicyRequest: PatchedDummyPolicyRequest? = null) : DummyPolicy {
        val localVarResponse = policiesDummyPartialUpdateWithHttpInfo(policyUuid = policyUuid, patchedDummyPolicyRequest = patchedDummyPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DummyPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Dummy Viewset
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @param patchedDummyPolicyRequest  (optional)
     * @return ApiResponse<DummyPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesDummyPartialUpdateWithHttpInfo(policyUuid: java.util.UUID, patchedDummyPolicyRequest: PatchedDummyPolicyRequest?) : ApiResponse<DummyPolicy?> {
        val localVariableConfig = policiesDummyPartialUpdateRequestConfig(policyUuid = policyUuid, patchedDummyPolicyRequest = patchedDummyPolicyRequest)

        return request<PatchedDummyPolicyRequest, DummyPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesDummyPartialUpdate
     *
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @param patchedDummyPolicyRequest  (optional)
     * @return RequestConfig
     */
    fun policiesDummyPartialUpdateRequestConfig(policyUuid: java.util.UUID, patchedDummyPolicyRequest: PatchedDummyPolicyRequest?) : RequestConfig<PatchedDummyPolicyRequest> {
        val localVariableBody = patchedDummyPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/policies/dummy/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Dummy Viewset
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @return DummyPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesDummyRetrieve(policyUuid: java.util.UUID) : DummyPolicy {
        val localVarResponse = policiesDummyRetrieveWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DummyPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Dummy Viewset
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @return ApiResponse<DummyPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesDummyRetrieveWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<DummyPolicy?> {
        val localVariableConfig = policiesDummyRetrieveRequestConfig(policyUuid = policyUuid)

        return request<Unit, DummyPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesDummyRetrieve
     *
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @return RequestConfig
     */
    fun policiesDummyRetrieveRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/dummy/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Dummy Viewset
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @param dummyPolicyRequest 
     * @return DummyPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesDummyUpdate(policyUuid: java.util.UUID, dummyPolicyRequest: DummyPolicyRequest) : DummyPolicy {
        val localVarResponse = policiesDummyUpdateWithHttpInfo(policyUuid = policyUuid, dummyPolicyRequest = dummyPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DummyPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Dummy Viewset
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @param dummyPolicyRequest 
     * @return ApiResponse<DummyPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesDummyUpdateWithHttpInfo(policyUuid: java.util.UUID, dummyPolicyRequest: DummyPolicyRequest) : ApiResponse<DummyPolicy?> {
        val localVariableConfig = policiesDummyUpdateRequestConfig(policyUuid = policyUuid, dummyPolicyRequest = dummyPolicyRequest)

        return request<DummyPolicyRequest, DummyPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesDummyUpdate
     *
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @param dummyPolicyRequest 
     * @return RequestConfig
     */
    fun policiesDummyUpdateRequestConfig(policyUuid: java.util.UUID, dummyPolicyRequest: DummyPolicyRequest) : RequestConfig<DummyPolicyRequest> {
        val localVariableBody = dummyPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/policies/dummy/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesDummyUsedByList(policyUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = policiesDummyUsedByListWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesDummyUsedByListWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = policiesDummyUsedByListRequestConfig(policyUuid = policyUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesDummyUsedByList
     *
     * @param policyUuid A UUID string identifying this Dummy Policy.
     * @return RequestConfig
     */
    fun policiesDummyUsedByListRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/dummy/{policy_uuid}/used_by/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param eventMatcherPolicyRequest 
     * @return EventMatcherPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesEventMatcherCreate(eventMatcherPolicyRequest: EventMatcherPolicyRequest) : EventMatcherPolicy {
        val localVarResponse = policiesEventMatcherCreateWithHttpInfo(eventMatcherPolicyRequest = eventMatcherPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventMatcherPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param eventMatcherPolicyRequest 
     * @return ApiResponse<EventMatcherPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesEventMatcherCreateWithHttpInfo(eventMatcherPolicyRequest: EventMatcherPolicyRequest) : ApiResponse<EventMatcherPolicy?> {
        val localVariableConfig = policiesEventMatcherCreateRequestConfig(eventMatcherPolicyRequest = eventMatcherPolicyRequest)

        return request<EventMatcherPolicyRequest, EventMatcherPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesEventMatcherCreate
     *
     * @param eventMatcherPolicyRequest 
     * @return RequestConfig
     */
    fun policiesEventMatcherCreateRequestConfig(eventMatcherPolicyRequest: EventMatcherPolicyRequest) : RequestConfig<EventMatcherPolicyRequest> {
        val localVariableBody = eventMatcherPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/policies/event_matcher/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesEventMatcherDestroy(policyUuid: java.util.UUID) : Unit {
        val localVarResponse = policiesEventMatcherDestroyWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesEventMatcherDestroyWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = policiesEventMatcherDestroyRequestConfig(policyUuid = policyUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesEventMatcherDestroy
     *
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @return RequestConfig
     */
    fun policiesEventMatcherDestroyRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/policies/event_matcher/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter action
     */
     enum class Action_policiesEventMatcherList(val value: kotlin.String) {
         @Json(name = "authorize_application") authorizeApplication("authorize_application"),
         @Json(name = "configuration_error") configurationError("configuration_error"),
         @Json(name = "custom_") custom("custom_"),
         @Json(name = "email_sent") emailSent("email_sent"),
         @Json(name = "flow_execution") flowExecution("flow_execution"),
         @Json(name = "impersonation_ended") impersonationEnded("impersonation_ended"),
         @Json(name = "impersonation_started") impersonationStarted("impersonation_started"),
         @Json(name = "invitation_used") invitationUsed("invitation_used"),
         @Json(name = "login") login("login"),
         @Json(name = "login_failed") loginFailed("login_failed"),
         @Json(name = "logout") logout("logout"),
         @Json(name = "model_created") modelCreated("model_created"),
         @Json(name = "model_deleted") modelDeleted("model_deleted"),
         @Json(name = "model_updated") modelUpdated("model_updated"),
         @Json(name = "password_set") passwordSet("password_set"),
         @Json(name = "policy_exception") policyException("policy_exception"),
         @Json(name = "policy_execution") policyExecution("policy_execution"),
         @Json(name = "property_mapping_exception") propertyMappingException("property_mapping_exception"),
         @Json(name = "secret_rotate") secretRotate("secret_rotate"),
         @Json(name = "secret_view") secretView("secret_view"),
         @Json(name = "source_linked") sourceLinked("source_linked"),
         @Json(name = "suspicious_request") suspiciousRequest("suspicious_request"),
         @Json(name = "system_exception") systemException("system_exception"),
         @Json(name = "system_task_exception") systemTaskException("system_task_exception"),
         @Json(name = "system_task_execution") systemTaskExecution("system_task_execution"),
         @Json(name = "update_available") updateAvailable("update_available"),
         @Json(name = "user_write") userWrite("user_write"),
     }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param action Match created events with this action type. When left empty, all action types will be matched.  * &#x60;login&#x60; - Login * &#x60;login_failed&#x60; - Login Failed * &#x60;logout&#x60; - Logout * &#x60;user_write&#x60; - User Write * &#x60;suspicious_request&#x60; - Suspicious Request * &#x60;password_set&#x60; - Password Set * &#x60;secret_view&#x60; - Secret View * &#x60;secret_rotate&#x60; - Secret Rotate * &#x60;invitation_used&#x60; - Invite Used * &#x60;authorize_application&#x60; - Authorize Application * &#x60;source_linked&#x60; - Source Linked * &#x60;impersonation_started&#x60; - Impersonation Started * &#x60;impersonation_ended&#x60; - Impersonation Ended * &#x60;flow_execution&#x60; - Flow Execution * &#x60;policy_execution&#x60; - Policy Execution * &#x60;policy_exception&#x60; - Policy Exception * &#x60;property_mapping_exception&#x60; - Property Mapping Exception * &#x60;system_task_execution&#x60; - System Task Execution * &#x60;system_task_exception&#x60; - System Task Exception * &#x60;system_exception&#x60; - System Exception * &#x60;configuration_error&#x60; - Configuration Error * &#x60;model_created&#x60; - Model Created * &#x60;model_updated&#x60; - Model Updated * &#x60;model_deleted&#x60; - Model Deleted * &#x60;email_sent&#x60; - Email Sent * &#x60;update_available&#x60; - Update Available * &#x60;custom_&#x60; - Custom Prefix (optional)
     * @param app  (optional)
     * @param clientIp  (optional)
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param model  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @return PaginatedEventMatcherPolicyList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesEventMatcherList(action: Action_policiesEventMatcherList? = null, app: kotlin.String? = null, clientIp: kotlin.String? = null, created: java.time.OffsetDateTime? = null, executionLogging: kotlin.Boolean? = null, lastUpdated: java.time.OffsetDateTime? = null, model: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, policyUuid: java.util.UUID? = null, search: kotlin.String? = null) : PaginatedEventMatcherPolicyList {
        val localVarResponse = policiesEventMatcherListWithHttpInfo(action = action, app = app, clientIp = clientIp, created = created, executionLogging = executionLogging, lastUpdated = lastUpdated, model = model, name = name, ordering = ordering, page = page, pageSize = pageSize, policyUuid = policyUuid, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedEventMatcherPolicyList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param action Match created events with this action type. When left empty, all action types will be matched.  * &#x60;login&#x60; - Login * &#x60;login_failed&#x60; - Login Failed * &#x60;logout&#x60; - Logout * &#x60;user_write&#x60; - User Write * &#x60;suspicious_request&#x60; - Suspicious Request * &#x60;password_set&#x60; - Password Set * &#x60;secret_view&#x60; - Secret View * &#x60;secret_rotate&#x60; - Secret Rotate * &#x60;invitation_used&#x60; - Invite Used * &#x60;authorize_application&#x60; - Authorize Application * &#x60;source_linked&#x60; - Source Linked * &#x60;impersonation_started&#x60; - Impersonation Started * &#x60;impersonation_ended&#x60; - Impersonation Ended * &#x60;flow_execution&#x60; - Flow Execution * &#x60;policy_execution&#x60; - Policy Execution * &#x60;policy_exception&#x60; - Policy Exception * &#x60;property_mapping_exception&#x60; - Property Mapping Exception * &#x60;system_task_execution&#x60; - System Task Execution * &#x60;system_task_exception&#x60; - System Task Exception * &#x60;system_exception&#x60; - System Exception * &#x60;configuration_error&#x60; - Configuration Error * &#x60;model_created&#x60; - Model Created * &#x60;model_updated&#x60; - Model Updated * &#x60;model_deleted&#x60; - Model Deleted * &#x60;email_sent&#x60; - Email Sent * &#x60;update_available&#x60; - Update Available * &#x60;custom_&#x60; - Custom Prefix (optional)
     * @param app  (optional)
     * @param clientIp  (optional)
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param model  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedEventMatcherPolicyList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesEventMatcherListWithHttpInfo(action: Action_policiesEventMatcherList?, app: kotlin.String?, clientIp: kotlin.String?, created: java.time.OffsetDateTime?, executionLogging: kotlin.Boolean?, lastUpdated: java.time.OffsetDateTime?, model: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyUuid: java.util.UUID?, search: kotlin.String?) : ApiResponse<PaginatedEventMatcherPolicyList?> {
        val localVariableConfig = policiesEventMatcherListRequestConfig(action = action, app = app, clientIp = clientIp, created = created, executionLogging = executionLogging, lastUpdated = lastUpdated, model = model, name = name, ordering = ordering, page = page, pageSize = pageSize, policyUuid = policyUuid, search = search)

        return request<Unit, PaginatedEventMatcherPolicyList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesEventMatcherList
     *
     * @param action Match created events with this action type. When left empty, all action types will be matched.  * &#x60;login&#x60; - Login * &#x60;login_failed&#x60; - Login Failed * &#x60;logout&#x60; - Logout * &#x60;user_write&#x60; - User Write * &#x60;suspicious_request&#x60; - Suspicious Request * &#x60;password_set&#x60; - Password Set * &#x60;secret_view&#x60; - Secret View * &#x60;secret_rotate&#x60; - Secret Rotate * &#x60;invitation_used&#x60; - Invite Used * &#x60;authorize_application&#x60; - Authorize Application * &#x60;source_linked&#x60; - Source Linked * &#x60;impersonation_started&#x60; - Impersonation Started * &#x60;impersonation_ended&#x60; - Impersonation Ended * &#x60;flow_execution&#x60; - Flow Execution * &#x60;policy_execution&#x60; - Policy Execution * &#x60;policy_exception&#x60; - Policy Exception * &#x60;property_mapping_exception&#x60; - Property Mapping Exception * &#x60;system_task_execution&#x60; - System Task Execution * &#x60;system_task_exception&#x60; - System Task Exception * &#x60;system_exception&#x60; - System Exception * &#x60;configuration_error&#x60; - Configuration Error * &#x60;model_created&#x60; - Model Created * &#x60;model_updated&#x60; - Model Updated * &#x60;model_deleted&#x60; - Model Deleted * &#x60;email_sent&#x60; - Email Sent * &#x60;update_available&#x60; - Update Available * &#x60;custom_&#x60; - Custom Prefix (optional)
     * @param app  (optional)
     * @param clientIp  (optional)
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param model  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun policiesEventMatcherListRequestConfig(action: Action_policiesEventMatcherList?, app: kotlin.String?, clientIp: kotlin.String?, created: java.time.OffsetDateTime?, executionLogging: kotlin.Boolean?, lastUpdated: java.time.OffsetDateTime?, model: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyUuid: java.util.UUID?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (action != null) {
                    put("action", listOf(action.toString()))
                }
                if (app != null) {
                    put("app", listOf(app.toString()))
                }
                if (clientIp != null) {
                    put("client_ip", listOf(clientIp.toString()))
                }
                if (created != null) {
                    put("created", listOf(parseDateToQueryString(created)))
                }
                if (executionLogging != null) {
                    put("execution_logging", listOf(executionLogging.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(parseDateToQueryString(lastUpdated)))
                }
                if (model != null) {
                    put("model", listOf(model.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (policyUuid != null) {
                    put("policy_uuid", listOf(policyUuid.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/event_matcher/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @param patchedEventMatcherPolicyRequest  (optional)
     * @return EventMatcherPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesEventMatcherPartialUpdate(policyUuid: java.util.UUID, patchedEventMatcherPolicyRequest: PatchedEventMatcherPolicyRequest? = null) : EventMatcherPolicy {
        val localVarResponse = policiesEventMatcherPartialUpdateWithHttpInfo(policyUuid = policyUuid, patchedEventMatcherPolicyRequest = patchedEventMatcherPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventMatcherPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @param patchedEventMatcherPolicyRequest  (optional)
     * @return ApiResponse<EventMatcherPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesEventMatcherPartialUpdateWithHttpInfo(policyUuid: java.util.UUID, patchedEventMatcherPolicyRequest: PatchedEventMatcherPolicyRequest?) : ApiResponse<EventMatcherPolicy?> {
        val localVariableConfig = policiesEventMatcherPartialUpdateRequestConfig(policyUuid = policyUuid, patchedEventMatcherPolicyRequest = patchedEventMatcherPolicyRequest)

        return request<PatchedEventMatcherPolicyRequest, EventMatcherPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesEventMatcherPartialUpdate
     *
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @param patchedEventMatcherPolicyRequest  (optional)
     * @return RequestConfig
     */
    fun policiesEventMatcherPartialUpdateRequestConfig(policyUuid: java.util.UUID, patchedEventMatcherPolicyRequest: PatchedEventMatcherPolicyRequest?) : RequestConfig<PatchedEventMatcherPolicyRequest> {
        val localVariableBody = patchedEventMatcherPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/policies/event_matcher/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @return EventMatcherPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesEventMatcherRetrieve(policyUuid: java.util.UUID) : EventMatcherPolicy {
        val localVarResponse = policiesEventMatcherRetrieveWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventMatcherPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @return ApiResponse<EventMatcherPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesEventMatcherRetrieveWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<EventMatcherPolicy?> {
        val localVariableConfig = policiesEventMatcherRetrieveRequestConfig(policyUuid = policyUuid)

        return request<Unit, EventMatcherPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesEventMatcherRetrieve
     *
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @return RequestConfig
     */
    fun policiesEventMatcherRetrieveRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/event_matcher/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @param eventMatcherPolicyRequest 
     * @return EventMatcherPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesEventMatcherUpdate(policyUuid: java.util.UUID, eventMatcherPolicyRequest: EventMatcherPolicyRequest) : EventMatcherPolicy {
        val localVarResponse = policiesEventMatcherUpdateWithHttpInfo(policyUuid = policyUuid, eventMatcherPolicyRequest = eventMatcherPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventMatcherPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Matcher Policy Viewset
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @param eventMatcherPolicyRequest 
     * @return ApiResponse<EventMatcherPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesEventMatcherUpdateWithHttpInfo(policyUuid: java.util.UUID, eventMatcherPolicyRequest: EventMatcherPolicyRequest) : ApiResponse<EventMatcherPolicy?> {
        val localVariableConfig = policiesEventMatcherUpdateRequestConfig(policyUuid = policyUuid, eventMatcherPolicyRequest = eventMatcherPolicyRequest)

        return request<EventMatcherPolicyRequest, EventMatcherPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesEventMatcherUpdate
     *
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @param eventMatcherPolicyRequest 
     * @return RequestConfig
     */
    fun policiesEventMatcherUpdateRequestConfig(policyUuid: java.util.UUID, eventMatcherPolicyRequest: EventMatcherPolicyRequest) : RequestConfig<EventMatcherPolicyRequest> {
        val localVariableBody = eventMatcherPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/policies/event_matcher/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesEventMatcherUsedByList(policyUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = policiesEventMatcherUsedByListWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesEventMatcherUsedByListWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = policiesEventMatcherUsedByListRequestConfig(policyUuid = policyUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesEventMatcherUsedByList
     *
     * @param policyUuid A UUID string identifying this Event Matcher Policy.
     * @return RequestConfig
     */
    fun policiesEventMatcherUsedByListRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/event_matcher/{policy_uuid}/used_by/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param expressionPolicyRequest 
     * @return ExpressionPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesExpressionCreate(expressionPolicyRequest: ExpressionPolicyRequest) : ExpressionPolicy {
        val localVarResponse = policiesExpressionCreateWithHttpInfo(expressionPolicyRequest = expressionPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExpressionPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param expressionPolicyRequest 
     * @return ApiResponse<ExpressionPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesExpressionCreateWithHttpInfo(expressionPolicyRequest: ExpressionPolicyRequest) : ApiResponse<ExpressionPolicy?> {
        val localVariableConfig = policiesExpressionCreateRequestConfig(expressionPolicyRequest = expressionPolicyRequest)

        return request<ExpressionPolicyRequest, ExpressionPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesExpressionCreate
     *
     * @param expressionPolicyRequest 
     * @return RequestConfig
     */
    fun policiesExpressionCreateRequestConfig(expressionPolicyRequest: ExpressionPolicyRequest) : RequestConfig<ExpressionPolicyRequest> {
        val localVariableBody = expressionPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/policies/expression/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesExpressionDestroy(policyUuid: java.util.UUID) : Unit {
        val localVarResponse = policiesExpressionDestroyWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesExpressionDestroyWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = policiesExpressionDestroyRequestConfig(policyUuid = policyUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesExpressionDestroy
     *
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @return RequestConfig
     */
    fun policiesExpressionDestroyRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/policies/expression/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param expression  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @return PaginatedExpressionPolicyList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesExpressionList(created: java.time.OffsetDateTime? = null, executionLogging: kotlin.Boolean? = null, expression: kotlin.String? = null, lastUpdated: java.time.OffsetDateTime? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, policyUuid: java.util.UUID? = null, search: kotlin.String? = null) : PaginatedExpressionPolicyList {
        val localVarResponse = policiesExpressionListWithHttpInfo(created = created, executionLogging = executionLogging, expression = expression, lastUpdated = lastUpdated, name = name, ordering = ordering, page = page, pageSize = pageSize, policyUuid = policyUuid, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedExpressionPolicyList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param expression  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedExpressionPolicyList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesExpressionListWithHttpInfo(created: java.time.OffsetDateTime?, executionLogging: kotlin.Boolean?, expression: kotlin.String?, lastUpdated: java.time.OffsetDateTime?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyUuid: java.util.UUID?, search: kotlin.String?) : ApiResponse<PaginatedExpressionPolicyList?> {
        val localVariableConfig = policiesExpressionListRequestConfig(created = created, executionLogging = executionLogging, expression = expression, lastUpdated = lastUpdated, name = name, ordering = ordering, page = page, pageSize = pageSize, policyUuid = policyUuid, search = search)

        return request<Unit, PaginatedExpressionPolicyList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesExpressionList
     *
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param expression  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun policiesExpressionListRequestConfig(created: java.time.OffsetDateTime?, executionLogging: kotlin.Boolean?, expression: kotlin.String?, lastUpdated: java.time.OffsetDateTime?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyUuid: java.util.UUID?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (created != null) {
                    put("created", listOf(parseDateToQueryString(created)))
                }
                if (executionLogging != null) {
                    put("execution_logging", listOf(executionLogging.toString()))
                }
                if (expression != null) {
                    put("expression", listOf(expression.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(parseDateToQueryString(lastUpdated)))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (policyUuid != null) {
                    put("policy_uuid", listOf(policyUuid.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/expression/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @param patchedExpressionPolicyRequest  (optional)
     * @return ExpressionPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesExpressionPartialUpdate(policyUuid: java.util.UUID, patchedExpressionPolicyRequest: PatchedExpressionPolicyRequest? = null) : ExpressionPolicy {
        val localVarResponse = policiesExpressionPartialUpdateWithHttpInfo(policyUuid = policyUuid, patchedExpressionPolicyRequest = patchedExpressionPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExpressionPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @param patchedExpressionPolicyRequest  (optional)
     * @return ApiResponse<ExpressionPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesExpressionPartialUpdateWithHttpInfo(policyUuid: java.util.UUID, patchedExpressionPolicyRequest: PatchedExpressionPolicyRequest?) : ApiResponse<ExpressionPolicy?> {
        val localVariableConfig = policiesExpressionPartialUpdateRequestConfig(policyUuid = policyUuid, patchedExpressionPolicyRequest = patchedExpressionPolicyRequest)

        return request<PatchedExpressionPolicyRequest, ExpressionPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesExpressionPartialUpdate
     *
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @param patchedExpressionPolicyRequest  (optional)
     * @return RequestConfig
     */
    fun policiesExpressionPartialUpdateRequestConfig(policyUuid: java.util.UUID, patchedExpressionPolicyRequest: PatchedExpressionPolicyRequest?) : RequestConfig<PatchedExpressionPolicyRequest> {
        val localVariableBody = patchedExpressionPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/policies/expression/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @return ExpressionPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesExpressionRetrieve(policyUuid: java.util.UUID) : ExpressionPolicy {
        val localVarResponse = policiesExpressionRetrieveWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExpressionPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @return ApiResponse<ExpressionPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesExpressionRetrieveWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<ExpressionPolicy?> {
        val localVariableConfig = policiesExpressionRetrieveRequestConfig(policyUuid = policyUuid)

        return request<Unit, ExpressionPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesExpressionRetrieve
     *
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @return RequestConfig
     */
    fun policiesExpressionRetrieveRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/expression/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @param expressionPolicyRequest 
     * @return ExpressionPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesExpressionUpdate(policyUuid: java.util.UUID, expressionPolicyRequest: ExpressionPolicyRequest) : ExpressionPolicy {
        val localVarResponse = policiesExpressionUpdateWithHttpInfo(policyUuid = policyUuid, expressionPolicyRequest = expressionPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExpressionPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @param expressionPolicyRequest 
     * @return ApiResponse<ExpressionPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesExpressionUpdateWithHttpInfo(policyUuid: java.util.UUID, expressionPolicyRequest: ExpressionPolicyRequest) : ApiResponse<ExpressionPolicy?> {
        val localVariableConfig = policiesExpressionUpdateRequestConfig(policyUuid = policyUuid, expressionPolicyRequest = expressionPolicyRequest)

        return request<ExpressionPolicyRequest, ExpressionPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesExpressionUpdate
     *
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @param expressionPolicyRequest 
     * @return RequestConfig
     */
    fun policiesExpressionUpdateRequestConfig(policyUuid: java.util.UUID, expressionPolicyRequest: ExpressionPolicyRequest) : RequestConfig<ExpressionPolicyRequest> {
        val localVariableBody = expressionPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/policies/expression/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesExpressionUsedByList(policyUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = policiesExpressionUsedByListWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesExpressionUsedByListWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = policiesExpressionUsedByListRequestConfig(policyUuid = policyUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesExpressionUsedByList
     *
     * @param policyUuid A UUID string identifying this Expression Policy.
     * @return RequestConfig
     */
    fun policiesExpressionUsedByListRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/expression/{policy_uuid}/used_by/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Policy Viewset
     * @param passwordPolicyRequest 
     * @return PasswordPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordCreate(passwordPolicyRequest: PasswordPolicyRequest) : PasswordPolicy {
        val localVarResponse = policiesPasswordCreateWithHttpInfo(passwordPolicyRequest = passwordPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Policy Viewset
     * @param passwordPolicyRequest 
     * @return ApiResponse<PasswordPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordCreateWithHttpInfo(passwordPolicyRequest: PasswordPolicyRequest) : ApiResponse<PasswordPolicy?> {
        val localVariableConfig = policiesPasswordCreateRequestConfig(passwordPolicyRequest = passwordPolicyRequest)

        return request<PasswordPolicyRequest, PasswordPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordCreate
     *
     * @param passwordPolicyRequest 
     * @return RequestConfig
     */
    fun policiesPasswordCreateRequestConfig(passwordPolicyRequest: PasswordPolicyRequest) : RequestConfig<PasswordPolicyRequest> {
        val localVariableBody = passwordPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/policies/password/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Policy Viewset
     * @param policyUuid A UUID string identifying this Password Policy.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordDestroy(policyUuid: java.util.UUID) : Unit {
        val localVarResponse = policiesPasswordDestroyWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Policy Viewset
     * @param policyUuid A UUID string identifying this Password Policy.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordDestroyWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = policiesPasswordDestroyRequestConfig(policyUuid = policyUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordDestroy
     *
     * @param policyUuid A UUID string identifying this Password Policy.
     * @return RequestConfig
     */
    fun policiesPasswordDestroyRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/policies/password/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Expiry Viewset
     * @param passwordExpiryPolicyRequest 
     * @return PasswordExpiryPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordExpiryCreate(passwordExpiryPolicyRequest: PasswordExpiryPolicyRequest) : PasswordExpiryPolicy {
        val localVarResponse = policiesPasswordExpiryCreateWithHttpInfo(passwordExpiryPolicyRequest = passwordExpiryPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordExpiryPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Expiry Viewset
     * @param passwordExpiryPolicyRequest 
     * @return ApiResponse<PasswordExpiryPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordExpiryCreateWithHttpInfo(passwordExpiryPolicyRequest: PasswordExpiryPolicyRequest) : ApiResponse<PasswordExpiryPolicy?> {
        val localVariableConfig = policiesPasswordExpiryCreateRequestConfig(passwordExpiryPolicyRequest = passwordExpiryPolicyRequest)

        return request<PasswordExpiryPolicyRequest, PasswordExpiryPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordExpiryCreate
     *
     * @param passwordExpiryPolicyRequest 
     * @return RequestConfig
     */
    fun policiesPasswordExpiryCreateRequestConfig(passwordExpiryPolicyRequest: PasswordExpiryPolicyRequest) : RequestConfig<PasswordExpiryPolicyRequest> {
        val localVariableBody = passwordExpiryPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/policies/password_expiry/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Expiry Viewset
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordExpiryDestroy(policyUuid: java.util.UUID) : Unit {
        val localVarResponse = policiesPasswordExpiryDestroyWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Expiry Viewset
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordExpiryDestroyWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = policiesPasswordExpiryDestroyRequestConfig(policyUuid = policyUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordExpiryDestroy
     *
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @return RequestConfig
     */
    fun policiesPasswordExpiryDestroyRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/policies/password_expiry/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Expiry Viewset
     * @param created  (optional)
     * @param days  (optional)
     * @param denyOnly  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @return PaginatedPasswordExpiryPolicyList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordExpiryList(created: java.time.OffsetDateTime? = null, days: kotlin.Int? = null, denyOnly: kotlin.Boolean? = null, executionLogging: kotlin.Boolean? = null, lastUpdated: java.time.OffsetDateTime? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, policyUuid: java.util.UUID? = null, search: kotlin.String? = null) : PaginatedPasswordExpiryPolicyList {
        val localVarResponse = policiesPasswordExpiryListWithHttpInfo(created = created, days = days, denyOnly = denyOnly, executionLogging = executionLogging, lastUpdated = lastUpdated, name = name, ordering = ordering, page = page, pageSize = pageSize, policyUuid = policyUuid, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPasswordExpiryPolicyList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Expiry Viewset
     * @param created  (optional)
     * @param days  (optional)
     * @param denyOnly  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedPasswordExpiryPolicyList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordExpiryListWithHttpInfo(created: java.time.OffsetDateTime?, days: kotlin.Int?, denyOnly: kotlin.Boolean?, executionLogging: kotlin.Boolean?, lastUpdated: java.time.OffsetDateTime?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyUuid: java.util.UUID?, search: kotlin.String?) : ApiResponse<PaginatedPasswordExpiryPolicyList?> {
        val localVariableConfig = policiesPasswordExpiryListRequestConfig(created = created, days = days, denyOnly = denyOnly, executionLogging = executionLogging, lastUpdated = lastUpdated, name = name, ordering = ordering, page = page, pageSize = pageSize, policyUuid = policyUuid, search = search)

        return request<Unit, PaginatedPasswordExpiryPolicyList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordExpiryList
     *
     * @param created  (optional)
     * @param days  (optional)
     * @param denyOnly  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun policiesPasswordExpiryListRequestConfig(created: java.time.OffsetDateTime?, days: kotlin.Int?, denyOnly: kotlin.Boolean?, executionLogging: kotlin.Boolean?, lastUpdated: java.time.OffsetDateTime?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyUuid: java.util.UUID?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (created != null) {
                    put("created", listOf(parseDateToQueryString(created)))
                }
                if (days != null) {
                    put("days", listOf(days.toString()))
                }
                if (denyOnly != null) {
                    put("deny_only", listOf(denyOnly.toString()))
                }
                if (executionLogging != null) {
                    put("execution_logging", listOf(executionLogging.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(parseDateToQueryString(lastUpdated)))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (policyUuid != null) {
                    put("policy_uuid", listOf(policyUuid.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/password_expiry/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Expiry Viewset
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @param patchedPasswordExpiryPolicyRequest  (optional)
     * @return PasswordExpiryPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordExpiryPartialUpdate(policyUuid: java.util.UUID, patchedPasswordExpiryPolicyRequest: PatchedPasswordExpiryPolicyRequest? = null) : PasswordExpiryPolicy {
        val localVarResponse = policiesPasswordExpiryPartialUpdateWithHttpInfo(policyUuid = policyUuid, patchedPasswordExpiryPolicyRequest = patchedPasswordExpiryPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordExpiryPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Expiry Viewset
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @param patchedPasswordExpiryPolicyRequest  (optional)
     * @return ApiResponse<PasswordExpiryPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordExpiryPartialUpdateWithHttpInfo(policyUuid: java.util.UUID, patchedPasswordExpiryPolicyRequest: PatchedPasswordExpiryPolicyRequest?) : ApiResponse<PasswordExpiryPolicy?> {
        val localVariableConfig = policiesPasswordExpiryPartialUpdateRequestConfig(policyUuid = policyUuid, patchedPasswordExpiryPolicyRequest = patchedPasswordExpiryPolicyRequest)

        return request<PatchedPasswordExpiryPolicyRequest, PasswordExpiryPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordExpiryPartialUpdate
     *
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @param patchedPasswordExpiryPolicyRequest  (optional)
     * @return RequestConfig
     */
    fun policiesPasswordExpiryPartialUpdateRequestConfig(policyUuid: java.util.UUID, patchedPasswordExpiryPolicyRequest: PatchedPasswordExpiryPolicyRequest?) : RequestConfig<PatchedPasswordExpiryPolicyRequest> {
        val localVariableBody = patchedPasswordExpiryPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/policies/password_expiry/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Expiry Viewset
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @return PasswordExpiryPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordExpiryRetrieve(policyUuid: java.util.UUID) : PasswordExpiryPolicy {
        val localVarResponse = policiesPasswordExpiryRetrieveWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordExpiryPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Expiry Viewset
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @return ApiResponse<PasswordExpiryPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordExpiryRetrieveWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<PasswordExpiryPolicy?> {
        val localVariableConfig = policiesPasswordExpiryRetrieveRequestConfig(policyUuid = policyUuid)

        return request<Unit, PasswordExpiryPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordExpiryRetrieve
     *
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @return RequestConfig
     */
    fun policiesPasswordExpiryRetrieveRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/password_expiry/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Expiry Viewset
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @param passwordExpiryPolicyRequest 
     * @return PasswordExpiryPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordExpiryUpdate(policyUuid: java.util.UUID, passwordExpiryPolicyRequest: PasswordExpiryPolicyRequest) : PasswordExpiryPolicy {
        val localVarResponse = policiesPasswordExpiryUpdateWithHttpInfo(policyUuid = policyUuid, passwordExpiryPolicyRequest = passwordExpiryPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordExpiryPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Expiry Viewset
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @param passwordExpiryPolicyRequest 
     * @return ApiResponse<PasswordExpiryPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordExpiryUpdateWithHttpInfo(policyUuid: java.util.UUID, passwordExpiryPolicyRequest: PasswordExpiryPolicyRequest) : ApiResponse<PasswordExpiryPolicy?> {
        val localVariableConfig = policiesPasswordExpiryUpdateRequestConfig(policyUuid = policyUuid, passwordExpiryPolicyRequest = passwordExpiryPolicyRequest)

        return request<PasswordExpiryPolicyRequest, PasswordExpiryPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordExpiryUpdate
     *
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @param passwordExpiryPolicyRequest 
     * @return RequestConfig
     */
    fun policiesPasswordExpiryUpdateRequestConfig(policyUuid: java.util.UUID, passwordExpiryPolicyRequest: PasswordExpiryPolicyRequest) : RequestConfig<PasswordExpiryPolicyRequest> {
        val localVariableBody = passwordExpiryPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/policies/password_expiry/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordExpiryUsedByList(policyUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = policiesPasswordExpiryUsedByListWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordExpiryUsedByListWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = policiesPasswordExpiryUsedByListRequestConfig(policyUuid = policyUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordExpiryUsedByList
     *
     * @param policyUuid A UUID string identifying this Password Expiry Policy.
     * @return RequestConfig
     */
    fun policiesPasswordExpiryUsedByListRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/password_expiry/{policy_uuid}/used_by/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Policy Viewset
     * @param amountDigits  (optional)
     * @param amountLowercase  (optional)
     * @param amountSymbols  (optional)
     * @param amountUppercase  (optional)
     * @param checkHaveIBeenPwned  (optional)
     * @param checkStaticRules  (optional)
     * @param checkZxcvbn  (optional)
     * @param created  (optional)
     * @param errorMessage  (optional)
     * @param executionLogging  (optional)
     * @param hibpAllowedCount  (optional)
     * @param lastUpdated  (optional)
     * @param lengthMin  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param passwordField  (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @param symbolCharset  (optional)
     * @param zxcvbnScoreThreshold  (optional)
     * @return PaginatedPasswordPolicyList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordList(amountDigits: kotlin.Int? = null, amountLowercase: kotlin.Int? = null, amountSymbols: kotlin.Int? = null, amountUppercase: kotlin.Int? = null, checkHaveIBeenPwned: kotlin.Boolean? = null, checkStaticRules: kotlin.Boolean? = null, checkZxcvbn: kotlin.Boolean? = null, created: java.time.OffsetDateTime? = null, errorMessage: kotlin.String? = null, executionLogging: kotlin.Boolean? = null, hibpAllowedCount: kotlin.Int? = null, lastUpdated: java.time.OffsetDateTime? = null, lengthMin: kotlin.Int? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, passwordField: kotlin.String? = null, policyUuid: java.util.UUID? = null, search: kotlin.String? = null, symbolCharset: kotlin.String? = null, zxcvbnScoreThreshold: kotlin.Int? = null) : PaginatedPasswordPolicyList {
        val localVarResponse = policiesPasswordListWithHttpInfo(amountDigits = amountDigits, amountLowercase = amountLowercase, amountSymbols = amountSymbols, amountUppercase = amountUppercase, checkHaveIBeenPwned = checkHaveIBeenPwned, checkStaticRules = checkStaticRules, checkZxcvbn = checkZxcvbn, created = created, errorMessage = errorMessage, executionLogging = executionLogging, hibpAllowedCount = hibpAllowedCount, lastUpdated = lastUpdated, lengthMin = lengthMin, name = name, ordering = ordering, page = page, pageSize = pageSize, passwordField = passwordField, policyUuid = policyUuid, search = search, symbolCharset = symbolCharset, zxcvbnScoreThreshold = zxcvbnScoreThreshold)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPasswordPolicyList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Policy Viewset
     * @param amountDigits  (optional)
     * @param amountLowercase  (optional)
     * @param amountSymbols  (optional)
     * @param amountUppercase  (optional)
     * @param checkHaveIBeenPwned  (optional)
     * @param checkStaticRules  (optional)
     * @param checkZxcvbn  (optional)
     * @param created  (optional)
     * @param errorMessage  (optional)
     * @param executionLogging  (optional)
     * @param hibpAllowedCount  (optional)
     * @param lastUpdated  (optional)
     * @param lengthMin  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param passwordField  (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @param symbolCharset  (optional)
     * @param zxcvbnScoreThreshold  (optional)
     * @return ApiResponse<PaginatedPasswordPolicyList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordListWithHttpInfo(amountDigits: kotlin.Int?, amountLowercase: kotlin.Int?, amountSymbols: kotlin.Int?, amountUppercase: kotlin.Int?, checkHaveIBeenPwned: kotlin.Boolean?, checkStaticRules: kotlin.Boolean?, checkZxcvbn: kotlin.Boolean?, created: java.time.OffsetDateTime?, errorMessage: kotlin.String?, executionLogging: kotlin.Boolean?, hibpAllowedCount: kotlin.Int?, lastUpdated: java.time.OffsetDateTime?, lengthMin: kotlin.Int?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, passwordField: kotlin.String?, policyUuid: java.util.UUID?, search: kotlin.String?, symbolCharset: kotlin.String?, zxcvbnScoreThreshold: kotlin.Int?) : ApiResponse<PaginatedPasswordPolicyList?> {
        val localVariableConfig = policiesPasswordListRequestConfig(amountDigits = amountDigits, amountLowercase = amountLowercase, amountSymbols = amountSymbols, amountUppercase = amountUppercase, checkHaveIBeenPwned = checkHaveIBeenPwned, checkStaticRules = checkStaticRules, checkZxcvbn = checkZxcvbn, created = created, errorMessage = errorMessage, executionLogging = executionLogging, hibpAllowedCount = hibpAllowedCount, lastUpdated = lastUpdated, lengthMin = lengthMin, name = name, ordering = ordering, page = page, pageSize = pageSize, passwordField = passwordField, policyUuid = policyUuid, search = search, symbolCharset = symbolCharset, zxcvbnScoreThreshold = zxcvbnScoreThreshold)

        return request<Unit, PaginatedPasswordPolicyList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordList
     *
     * @param amountDigits  (optional)
     * @param amountLowercase  (optional)
     * @param amountSymbols  (optional)
     * @param amountUppercase  (optional)
     * @param checkHaveIBeenPwned  (optional)
     * @param checkStaticRules  (optional)
     * @param checkZxcvbn  (optional)
     * @param created  (optional)
     * @param errorMessage  (optional)
     * @param executionLogging  (optional)
     * @param hibpAllowedCount  (optional)
     * @param lastUpdated  (optional)
     * @param lengthMin  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param passwordField  (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @param symbolCharset  (optional)
     * @param zxcvbnScoreThreshold  (optional)
     * @return RequestConfig
     */
    fun policiesPasswordListRequestConfig(amountDigits: kotlin.Int?, amountLowercase: kotlin.Int?, amountSymbols: kotlin.Int?, amountUppercase: kotlin.Int?, checkHaveIBeenPwned: kotlin.Boolean?, checkStaticRules: kotlin.Boolean?, checkZxcvbn: kotlin.Boolean?, created: java.time.OffsetDateTime?, errorMessage: kotlin.String?, executionLogging: kotlin.Boolean?, hibpAllowedCount: kotlin.Int?, lastUpdated: java.time.OffsetDateTime?, lengthMin: kotlin.Int?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, passwordField: kotlin.String?, policyUuid: java.util.UUID?, search: kotlin.String?, symbolCharset: kotlin.String?, zxcvbnScoreThreshold: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (amountDigits != null) {
                    put("amount_digits", listOf(amountDigits.toString()))
                }
                if (amountLowercase != null) {
                    put("amount_lowercase", listOf(amountLowercase.toString()))
                }
                if (amountSymbols != null) {
                    put("amount_symbols", listOf(amountSymbols.toString()))
                }
                if (amountUppercase != null) {
                    put("amount_uppercase", listOf(amountUppercase.toString()))
                }
                if (checkHaveIBeenPwned != null) {
                    put("check_have_i_been_pwned", listOf(checkHaveIBeenPwned.toString()))
                }
                if (checkStaticRules != null) {
                    put("check_static_rules", listOf(checkStaticRules.toString()))
                }
                if (checkZxcvbn != null) {
                    put("check_zxcvbn", listOf(checkZxcvbn.toString()))
                }
                if (created != null) {
                    put("created", listOf(parseDateToQueryString(created)))
                }
                if (errorMessage != null) {
                    put("error_message", listOf(errorMessage.toString()))
                }
                if (executionLogging != null) {
                    put("execution_logging", listOf(executionLogging.toString()))
                }
                if (hibpAllowedCount != null) {
                    put("hibp_allowed_count", listOf(hibpAllowedCount.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(parseDateToQueryString(lastUpdated)))
                }
                if (lengthMin != null) {
                    put("length_min", listOf(lengthMin.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (passwordField != null) {
                    put("password_field", listOf(passwordField.toString()))
                }
                if (policyUuid != null) {
                    put("policy_uuid", listOf(policyUuid.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (symbolCharset != null) {
                    put("symbol_charset", listOf(symbolCharset.toString()))
                }
                if (zxcvbnScoreThreshold != null) {
                    put("zxcvbn_score_threshold", listOf(zxcvbnScoreThreshold.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/password/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Policy Viewset
     * @param policyUuid A UUID string identifying this Password Policy.
     * @param patchedPasswordPolicyRequest  (optional)
     * @return PasswordPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordPartialUpdate(policyUuid: java.util.UUID, patchedPasswordPolicyRequest: PatchedPasswordPolicyRequest? = null) : PasswordPolicy {
        val localVarResponse = policiesPasswordPartialUpdateWithHttpInfo(policyUuid = policyUuid, patchedPasswordPolicyRequest = patchedPasswordPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Policy Viewset
     * @param policyUuid A UUID string identifying this Password Policy.
     * @param patchedPasswordPolicyRequest  (optional)
     * @return ApiResponse<PasswordPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordPartialUpdateWithHttpInfo(policyUuid: java.util.UUID, patchedPasswordPolicyRequest: PatchedPasswordPolicyRequest?) : ApiResponse<PasswordPolicy?> {
        val localVariableConfig = policiesPasswordPartialUpdateRequestConfig(policyUuid = policyUuid, patchedPasswordPolicyRequest = patchedPasswordPolicyRequest)

        return request<PatchedPasswordPolicyRequest, PasswordPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordPartialUpdate
     *
     * @param policyUuid A UUID string identifying this Password Policy.
     * @param patchedPasswordPolicyRequest  (optional)
     * @return RequestConfig
     */
    fun policiesPasswordPartialUpdateRequestConfig(policyUuid: java.util.UUID, patchedPasswordPolicyRequest: PatchedPasswordPolicyRequest?) : RequestConfig<PatchedPasswordPolicyRequest> {
        val localVariableBody = patchedPasswordPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/policies/password/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Policy Viewset
     * @param policyUuid A UUID string identifying this Password Policy.
     * @return PasswordPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordRetrieve(policyUuid: java.util.UUID) : PasswordPolicy {
        val localVarResponse = policiesPasswordRetrieveWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Policy Viewset
     * @param policyUuid A UUID string identifying this Password Policy.
     * @return ApiResponse<PasswordPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordRetrieveWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<PasswordPolicy?> {
        val localVariableConfig = policiesPasswordRetrieveRequestConfig(policyUuid = policyUuid)

        return request<Unit, PasswordPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordRetrieve
     *
     * @param policyUuid A UUID string identifying this Password Policy.
     * @return RequestConfig
     */
    fun policiesPasswordRetrieveRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/password/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Password Policy Viewset
     * @param policyUuid A UUID string identifying this Password Policy.
     * @param passwordPolicyRequest 
     * @return PasswordPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordUpdate(policyUuid: java.util.UUID, passwordPolicyRequest: PasswordPolicyRequest) : PasswordPolicy {
        val localVarResponse = policiesPasswordUpdateWithHttpInfo(policyUuid = policyUuid, passwordPolicyRequest = passwordPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Password Policy Viewset
     * @param policyUuid A UUID string identifying this Password Policy.
     * @param passwordPolicyRequest 
     * @return ApiResponse<PasswordPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordUpdateWithHttpInfo(policyUuid: java.util.UUID, passwordPolicyRequest: PasswordPolicyRequest) : ApiResponse<PasswordPolicy?> {
        val localVariableConfig = policiesPasswordUpdateRequestConfig(policyUuid = policyUuid, passwordPolicyRequest = passwordPolicyRequest)

        return request<PasswordPolicyRequest, PasswordPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordUpdate
     *
     * @param policyUuid A UUID string identifying this Password Policy.
     * @param passwordPolicyRequest 
     * @return RequestConfig
     */
    fun policiesPasswordUpdateRequestConfig(policyUuid: java.util.UUID, passwordPolicyRequest: PasswordPolicyRequest) : RequestConfig<PasswordPolicyRequest> {
        val localVariableBody = passwordPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/policies/password/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Password Policy.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesPasswordUsedByList(policyUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = policiesPasswordUsedByListWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Password Policy.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesPasswordUsedByListWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = policiesPasswordUsedByListRequestConfig(policyUuid = policyUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesPasswordUsedByList
     *
     * @param policyUuid A UUID string identifying this Password Policy.
     * @return RequestConfig
     */
    fun policiesPasswordUsedByListRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/password/{policy_uuid}/used_by/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param reputationPolicyRequest 
     * @return ReputationPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesReputationCreate(reputationPolicyRequest: ReputationPolicyRequest) : ReputationPolicy {
        val localVarResponse = policiesReputationCreateWithHttpInfo(reputationPolicyRequest = reputationPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReputationPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param reputationPolicyRequest 
     * @return ApiResponse<ReputationPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesReputationCreateWithHttpInfo(reputationPolicyRequest: ReputationPolicyRequest) : ApiResponse<ReputationPolicy?> {
        val localVariableConfig = policiesReputationCreateRequestConfig(reputationPolicyRequest = reputationPolicyRequest)

        return request<ReputationPolicyRequest, ReputationPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesReputationCreate
     *
     * @param reputationPolicyRequest 
     * @return RequestConfig
     */
    fun policiesReputationCreateRequestConfig(reputationPolicyRequest: ReputationPolicyRequest) : RequestConfig<ReputationPolicyRequest> {
        val localVariableBody = reputationPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/policies/reputation/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesReputationDestroy(policyUuid: java.util.UUID) : Unit {
        val localVarResponse = policiesReputationDestroyWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesReputationDestroyWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = policiesReputationDestroyRequestConfig(policyUuid = policyUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesReputationDestroy
     *
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @return RequestConfig
     */
    fun policiesReputationDestroyRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/policies/reputation/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param checkIp  (optional)
     * @param checkUsername  (optional)
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @param threshold  (optional)
     * @return PaginatedReputationPolicyList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesReputationList(checkIp: kotlin.Boolean? = null, checkUsername: kotlin.Boolean? = null, created: java.time.OffsetDateTime? = null, executionLogging: kotlin.Boolean? = null, lastUpdated: java.time.OffsetDateTime? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, policyUuid: java.util.UUID? = null, search: kotlin.String? = null, threshold: kotlin.Int? = null) : PaginatedReputationPolicyList {
        val localVarResponse = policiesReputationListWithHttpInfo(checkIp = checkIp, checkUsername = checkUsername, created = created, executionLogging = executionLogging, lastUpdated = lastUpdated, name = name, ordering = ordering, page = page, pageSize = pageSize, policyUuid = policyUuid, search = search, threshold = threshold)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedReputationPolicyList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param checkIp  (optional)
     * @param checkUsername  (optional)
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @param threshold  (optional)
     * @return ApiResponse<PaginatedReputationPolicyList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesReputationListWithHttpInfo(checkIp: kotlin.Boolean?, checkUsername: kotlin.Boolean?, created: java.time.OffsetDateTime?, executionLogging: kotlin.Boolean?, lastUpdated: java.time.OffsetDateTime?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyUuid: java.util.UUID?, search: kotlin.String?, threshold: kotlin.Int?) : ApiResponse<PaginatedReputationPolicyList?> {
        val localVariableConfig = policiesReputationListRequestConfig(checkIp = checkIp, checkUsername = checkUsername, created = created, executionLogging = executionLogging, lastUpdated = lastUpdated, name = name, ordering = ordering, page = page, pageSize = pageSize, policyUuid = policyUuid, search = search, threshold = threshold)

        return request<Unit, PaginatedReputationPolicyList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesReputationList
     *
     * @param checkIp  (optional)
     * @param checkUsername  (optional)
     * @param created  (optional)
     * @param executionLogging  (optional)
     * @param lastUpdated  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyUuid  (optional)
     * @param search A search term. (optional)
     * @param threshold  (optional)
     * @return RequestConfig
     */
    fun policiesReputationListRequestConfig(checkIp: kotlin.Boolean?, checkUsername: kotlin.Boolean?, created: java.time.OffsetDateTime?, executionLogging: kotlin.Boolean?, lastUpdated: java.time.OffsetDateTime?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyUuid: java.util.UUID?, search: kotlin.String?, threshold: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (checkIp != null) {
                    put("check_ip", listOf(checkIp.toString()))
                }
                if (checkUsername != null) {
                    put("check_username", listOf(checkUsername.toString()))
                }
                if (created != null) {
                    put("created", listOf(parseDateToQueryString(created)))
                }
                if (executionLogging != null) {
                    put("execution_logging", listOf(executionLogging.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(parseDateToQueryString(lastUpdated)))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (policyUuid != null) {
                    put("policy_uuid", listOf(policyUuid.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (threshold != null) {
                    put("threshold", listOf(threshold.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/reputation/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @param patchedReputationPolicyRequest  (optional)
     * @return ReputationPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesReputationPartialUpdate(policyUuid: java.util.UUID, patchedReputationPolicyRequest: PatchedReputationPolicyRequest? = null) : ReputationPolicy {
        val localVarResponse = policiesReputationPartialUpdateWithHttpInfo(policyUuid = policyUuid, patchedReputationPolicyRequest = patchedReputationPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReputationPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @param patchedReputationPolicyRequest  (optional)
     * @return ApiResponse<ReputationPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesReputationPartialUpdateWithHttpInfo(policyUuid: java.util.UUID, patchedReputationPolicyRequest: PatchedReputationPolicyRequest?) : ApiResponse<ReputationPolicy?> {
        val localVariableConfig = policiesReputationPartialUpdateRequestConfig(policyUuid = policyUuid, patchedReputationPolicyRequest = patchedReputationPolicyRequest)

        return request<PatchedReputationPolicyRequest, ReputationPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesReputationPartialUpdate
     *
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @param patchedReputationPolicyRequest  (optional)
     * @return RequestConfig
     */
    fun policiesReputationPartialUpdateRequestConfig(policyUuid: java.util.UUID, patchedReputationPolicyRequest: PatchedReputationPolicyRequest?) : RequestConfig<PatchedReputationPolicyRequest> {
        val localVariableBody = patchedReputationPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/policies/reputation/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @return ReputationPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesReputationRetrieve(policyUuid: java.util.UUID) : ReputationPolicy {
        val localVarResponse = policiesReputationRetrieveWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReputationPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @return ApiResponse<ReputationPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesReputationRetrieveWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<ReputationPolicy?> {
        val localVariableConfig = policiesReputationRetrieveRequestConfig(policyUuid = policyUuid)

        return request<Unit, ReputationPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesReputationRetrieve
     *
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @return RequestConfig
     */
    fun policiesReputationRetrieveRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/reputation/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Reputation Viewset
     * @param reputationUuid A UUID string identifying this Reputation Score.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesReputationScoresDestroy(reputationUuid: java.util.UUID) : Unit {
        val localVarResponse = policiesReputationScoresDestroyWithHttpInfo(reputationUuid = reputationUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Reputation Viewset
     * @param reputationUuid A UUID string identifying this Reputation Score.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesReputationScoresDestroyWithHttpInfo(reputationUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = policiesReputationScoresDestroyRequestConfig(reputationUuid = reputationUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesReputationScoresDestroy
     *
     * @param reputationUuid A UUID string identifying this Reputation Score.
     * @return RequestConfig
     */
    fun policiesReputationScoresDestroyRequestConfig(reputationUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/policies/reputation/scores/{reputation_uuid}/".replace("{"+"reputation_uuid"+"}", encodeURIComponent(reputationUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Reputation Viewset
     * @param identifier  (optional)
     * @param ip  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param score  (optional)
     * @param search A search term. (optional)
     * @return PaginatedReputationList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesReputationScoresList(identifier: kotlin.String? = null, ip: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, score: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedReputationList {
        val localVarResponse = policiesReputationScoresListWithHttpInfo(identifier = identifier, ip = ip, ordering = ordering, page = page, pageSize = pageSize, score = score, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedReputationList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Reputation Viewset
     * @param identifier  (optional)
     * @param ip  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param score  (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedReputationList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesReputationScoresListWithHttpInfo(identifier: kotlin.String?, ip: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, score: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedReputationList?> {
        val localVariableConfig = policiesReputationScoresListRequestConfig(identifier = identifier, ip = ip, ordering = ordering, page = page, pageSize = pageSize, score = score, search = search)

        return request<Unit, PaginatedReputationList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesReputationScoresList
     *
     * @param identifier  (optional)
     * @param ip  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param score  (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun policiesReputationScoresListRequestConfig(identifier: kotlin.String?, ip: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, score: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (identifier != null) {
                    put("identifier", listOf(identifier.toString()))
                }
                if (ip != null) {
                    put("ip", listOf(ip.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (score != null) {
                    put("score", listOf(score.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/reputation/scores/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Reputation Viewset
     * @param reputationUuid A UUID string identifying this Reputation Score.
     * @return Reputation
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesReputationScoresRetrieve(reputationUuid: java.util.UUID) : Reputation {
        val localVarResponse = policiesReputationScoresRetrieveWithHttpInfo(reputationUuid = reputationUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Reputation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Reputation Viewset
     * @param reputationUuid A UUID string identifying this Reputation Score.
     * @return ApiResponse<Reputation?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesReputationScoresRetrieveWithHttpInfo(reputationUuid: java.util.UUID) : ApiResponse<Reputation?> {
        val localVariableConfig = policiesReputationScoresRetrieveRequestConfig(reputationUuid = reputationUuid)

        return request<Unit, Reputation>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesReputationScoresRetrieve
     *
     * @param reputationUuid A UUID string identifying this Reputation Score.
     * @return RequestConfig
     */
    fun policiesReputationScoresRetrieveRequestConfig(reputationUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/reputation/scores/{reputation_uuid}/".replace("{"+"reputation_uuid"+"}", encodeURIComponent(reputationUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param reputationUuid A UUID string identifying this Reputation Score.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesReputationScoresUsedByList(reputationUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = policiesReputationScoresUsedByListWithHttpInfo(reputationUuid = reputationUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param reputationUuid A UUID string identifying this Reputation Score.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesReputationScoresUsedByListWithHttpInfo(reputationUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = policiesReputationScoresUsedByListRequestConfig(reputationUuid = reputationUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesReputationScoresUsedByList
     *
     * @param reputationUuid A UUID string identifying this Reputation Score.
     * @return RequestConfig
     */
    fun policiesReputationScoresUsedByListRequestConfig(reputationUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/reputation/scores/{reputation_uuid}/used_by/".replace("{"+"reputation_uuid"+"}", encodeURIComponent(reputationUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @param reputationPolicyRequest 
     * @return ReputationPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesReputationUpdate(policyUuid: java.util.UUID, reputationPolicyRequest: ReputationPolicyRequest) : ReputationPolicy {
        val localVarResponse = policiesReputationUpdateWithHttpInfo(policyUuid = policyUuid, reputationPolicyRequest = reputationPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReputationPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Reputation Policy Viewset
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @param reputationPolicyRequest 
     * @return ApiResponse<ReputationPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesReputationUpdateWithHttpInfo(policyUuid: java.util.UUID, reputationPolicyRequest: ReputationPolicyRequest) : ApiResponse<ReputationPolicy?> {
        val localVariableConfig = policiesReputationUpdateRequestConfig(policyUuid = policyUuid, reputationPolicyRequest = reputationPolicyRequest)

        return request<ReputationPolicyRequest, ReputationPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesReputationUpdate
     *
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @param reputationPolicyRequest 
     * @return RequestConfig
     */
    fun policiesReputationUpdateRequestConfig(policyUuid: java.util.UUID, reputationPolicyRequest: ReputationPolicyRequest) : RequestConfig<ReputationPolicyRequest> {
        val localVariableBody = reputationPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/policies/reputation/{policy_uuid}/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun policiesReputationUsedByList(policyUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = policiesReputationUsedByListWithHttpInfo(policyUuid = policyUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun policiesReputationUsedByListWithHttpInfo(policyUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = policiesReputationUsedByListRequestConfig(policyUuid = policyUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation policiesReputationUsedByList
     *
     * @param policyUuid A UUID string identifying this Reputation Policy.
     * @return RequestConfig
     */
    fun policiesReputationUsedByListRequestConfig(policyUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/policies/reputation/{policy_uuid}/used_by/".replace("{"+"policy_uuid"+"}", encodeURIComponent(policyUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
