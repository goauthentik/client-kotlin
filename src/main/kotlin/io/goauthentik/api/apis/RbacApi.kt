/**
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2023.10.3
 * Contact: hello@goauthentik.io
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.PaginatedExtraRoleObjectPermissionList
import io.goauthentik.api.models.PaginatedExtraUserObjectPermissionList
import io.goauthentik.api.models.PaginatedPermissionList
import io.goauthentik.api.models.PaginatedRoleAssignedObjectPermissionList
import io.goauthentik.api.models.PaginatedRoleList
import io.goauthentik.api.models.PaginatedUserAssignedObjectPermissionList
import io.goauthentik.api.models.PatchedPermissionAssignRequest
import io.goauthentik.api.models.PatchedRoleRequest
import io.goauthentik.api.models.Permission
import io.goauthentik.api.models.PermissionAssignRequest
import io.goauthentik.api.models.Role
import io.goauthentik.api.models.RoleRequest
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.ValidationError

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class RbacApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * Assign permission(s) to role. When &#x60;object_pk&#x60; is set, the permissions are only assigned to the specific object, otherwise they are assigned globally.
     * @param uuid A UUID string identifying this Role.
     * @param permissionAssignRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacPermissionsAssignedByRolesAssignCreate(uuid: java.util.UUID, permissionAssignRequest: PermissionAssignRequest) : Unit {
        val localVarResponse = rbacPermissionsAssignedByRolesAssignCreateWithHttpInfo(uuid = uuid, permissionAssignRequest = permissionAssignRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Assign permission(s) to role. When &#x60;object_pk&#x60; is set, the permissions are only assigned to the specific object, otherwise they are assigned globally.
     * @param uuid A UUID string identifying this Role.
     * @param permissionAssignRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacPermissionsAssignedByRolesAssignCreateWithHttpInfo(uuid: java.util.UUID, permissionAssignRequest: PermissionAssignRequest) : ApiResponse<Unit?> {
        val localVariableConfig = rbacPermissionsAssignedByRolesAssignCreateRequestConfig(uuid = uuid, permissionAssignRequest = permissionAssignRequest)

        return request<PermissionAssignRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacPermissionsAssignedByRolesAssignCreate
     *
     * @param uuid A UUID string identifying this Role.
     * @param permissionAssignRequest 
     * @return RequestConfig
     */
    fun rbacPermissionsAssignedByRolesAssignCreateRequestConfig(uuid: java.util.UUID, permissionAssignRequest: PermissionAssignRequest) : RequestConfig<PermissionAssignRequest> {
        val localVariableBody = permissionAssignRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rbac/permissions/assigned_by_roles/{uuid}/assign/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter model
     */
     enum class Model_rbacPermissionsAssignedByRolesList(val value: kotlin.String) {
         @Json(name = "authentik_blueprints.blueprintinstance") blueprintsPeriodBlueprintinstance("authentik_blueprints.blueprintinstance"),
         @Json(name = "authentik_core.application") corePeriodApplication("authentik_core.application"),
         @Json(name = "authentik_core.group") corePeriodGroup("authentik_core.group"),
         @Json(name = "authentik_core.token") corePeriodToken("authentik_core.token"),
         @Json(name = "authentik_core.user") corePeriodUser("authentik_core.user"),
         @Json(name = "authentik_crypto.certificatekeypair") cryptoPeriodCertificatekeypair("authentik_crypto.certificatekeypair"),
         @Json(name = "authentik_enterprise.license") enterprisePeriodLicense("authentik_enterprise.license"),
         @Json(name = "authentik_events.event") eventsPeriodEvent("authentik_events.event"),
         @Json(name = "authentik_events.notification") eventsPeriodNotification("authentik_events.notification"),
         @Json(name = "authentik_events.notificationrule") eventsPeriodNotificationrule("authentik_events.notificationrule"),
         @Json(name = "authentik_events.notificationtransport") eventsPeriodNotificationtransport("authentik_events.notificationtransport"),
         @Json(name = "authentik_events.notificationwebhookmapping") eventsPeriodNotificationwebhookmapping("authentik_events.notificationwebhookmapping"),
         @Json(name = "authentik_flows.flow") flowsPeriodFlow("authentik_flows.flow"),
         @Json(name = "authentik_flows.flowstagebinding") flowsPeriodFlowstagebinding("authentik_flows.flowstagebinding"),
         @Json(name = "authentik_outposts.dockerserviceconnection") outpostsPeriodDockerserviceconnection("authentik_outposts.dockerserviceconnection"),
         @Json(name = "authentik_outposts.kubernetesserviceconnection") outpostsPeriodKubernetesserviceconnection("authentik_outposts.kubernetesserviceconnection"),
         @Json(name = "authentik_outposts.outpost") outpostsPeriodOutpost("authentik_outposts.outpost"),
         @Json(name = "authentik_policies.policybinding") policiesPeriodPolicybinding("authentik_policies.policybinding"),
         @Json(name = "authentik_policies_dummy.dummypolicy") policiesDummyPeriodDummypolicy("authentik_policies_dummy.dummypolicy"),
         @Json(name = "authentik_policies_event_matcher.eventmatcherpolicy") policiesEventMatcherPeriodEventmatcherpolicy("authentik_policies_event_matcher.eventmatcherpolicy"),
         @Json(name = "authentik_policies_expiry.passwordexpirypolicy") policiesExpiryPeriodPasswordexpirypolicy("authentik_policies_expiry.passwordexpirypolicy"),
         @Json(name = "authentik_policies_expression.expressionpolicy") policiesExpressionPeriodExpressionpolicy("authentik_policies_expression.expressionpolicy"),
         @Json(name = "authentik_policies_password.passwordpolicy") policiesPasswordPeriodPasswordpolicy("authentik_policies_password.passwordpolicy"),
         @Json(name = "authentik_policies_reputation.reputation") policiesReputationPeriodReputation("authentik_policies_reputation.reputation"),
         @Json(name = "authentik_policies_reputation.reputationpolicy") policiesReputationPeriodReputationpolicy("authentik_policies_reputation.reputationpolicy"),
         @Json(name = "authentik_providers_ldap.ldapprovider") providersLdapPeriodLdapprovider("authentik_providers_ldap.ldapprovider"),
         @Json(name = "authentik_providers_oauth2.accesstoken") providersOauth2PeriodAccesstoken("authentik_providers_oauth2.accesstoken"),
         @Json(name = "authentik_providers_oauth2.authorizationcode") providersOauth2PeriodAuthorizationcode("authentik_providers_oauth2.authorizationcode"),
         @Json(name = "authentik_providers_oauth2.oauth2provider") providersOauth2PeriodOauth2provider("authentik_providers_oauth2.oauth2provider"),
         @Json(name = "authentik_providers_oauth2.refreshtoken") providersOauth2PeriodRefreshtoken("authentik_providers_oauth2.refreshtoken"),
         @Json(name = "authentik_providers_oauth2.scopemapping") providersOauth2PeriodScopemapping("authentik_providers_oauth2.scopemapping"),
         @Json(name = "authentik_providers_proxy.proxyprovider") providersProxyPeriodProxyprovider("authentik_providers_proxy.proxyprovider"),
         @Json(name = "authentik_providers_radius.radiusprovider") providersRadiusPeriodRadiusprovider("authentik_providers_radius.radiusprovider"),
         @Json(name = "authentik_providers_saml.samlpropertymapping") providersSamlPeriodSamlpropertymapping("authentik_providers_saml.samlpropertymapping"),
         @Json(name = "authentik_providers_saml.samlprovider") providersSamlPeriodSamlprovider("authentik_providers_saml.samlprovider"),
         @Json(name = "authentik_providers_scim.scimmapping") providersScimPeriodScimmapping("authentik_providers_scim.scimmapping"),
         @Json(name = "authentik_providers_scim.scimprovider") providersScimPeriodScimprovider("authentik_providers_scim.scimprovider"),
         @Json(name = "authentik_rbac.role") rbacPeriodRole("authentik_rbac.role"),
         @Json(name = "authentik_sources_ldap.ldappropertymapping") sourcesLdapPeriodLdappropertymapping("authentik_sources_ldap.ldappropertymapping"),
         @Json(name = "authentik_sources_ldap.ldapsource") sourcesLdapPeriodLdapsource("authentik_sources_ldap.ldapsource"),
         @Json(name = "authentik_sources_oauth.oauthsource") sourcesOauthPeriodOauthsource("authentik_sources_oauth.oauthsource"),
         @Json(name = "authentik_sources_oauth.useroauthsourceconnection") sourcesOauthPeriodUseroauthsourceconnection("authentik_sources_oauth.useroauthsourceconnection"),
         @Json(name = "authentik_sources_plex.plexsource") sourcesPlexPeriodPlexsource("authentik_sources_plex.plexsource"),
         @Json(name = "authentik_sources_plex.plexsourceconnection") sourcesPlexPeriodPlexsourceconnection("authentik_sources_plex.plexsourceconnection"),
         @Json(name = "authentik_sources_saml.samlsource") sourcesSamlPeriodSamlsource("authentik_sources_saml.samlsource"),
         @Json(name = "authentik_sources_saml.usersamlsourceconnection") sourcesSamlPeriodUsersamlsourceconnection("authentik_sources_saml.usersamlsourceconnection"),
         @Json(name = "authentik_stages_authenticator_duo.authenticatorduostage") stagesAuthenticatorDuoPeriodAuthenticatorduostage("authentik_stages_authenticator_duo.authenticatorduostage"),
         @Json(name = "authentik_stages_authenticator_duo.duodevice") stagesAuthenticatorDuoPeriodDuodevice("authentik_stages_authenticator_duo.duodevice"),
         @Json(name = "authentik_stages_authenticator_sms.authenticatorsmsstage") stagesAuthenticatorSmsPeriodAuthenticatorsmsstage("authentik_stages_authenticator_sms.authenticatorsmsstage"),
         @Json(name = "authentik_stages_authenticator_sms.smsdevice") stagesAuthenticatorSmsPeriodSmsdevice("authentik_stages_authenticator_sms.smsdevice"),
         @Json(name = "authentik_stages_authenticator_static.authenticatorstaticstage") stagesAuthenticatorStaticPeriodAuthenticatorstaticstage("authentik_stages_authenticator_static.authenticatorstaticstage"),
         @Json(name = "authentik_stages_authenticator_static.staticdevice") stagesAuthenticatorStaticPeriodStaticdevice("authentik_stages_authenticator_static.staticdevice"),
         @Json(name = "authentik_stages_authenticator_totp.authenticatortotpstage") stagesAuthenticatorTotpPeriodAuthenticatortotpstage("authentik_stages_authenticator_totp.authenticatortotpstage"),
         @Json(name = "authentik_stages_authenticator_totp.totpdevice") stagesAuthenticatorTotpPeriodTotpdevice("authentik_stages_authenticator_totp.totpdevice"),
         @Json(name = "authentik_stages_authenticator_validate.authenticatorvalidatestage") stagesAuthenticatorValidatePeriodAuthenticatorvalidatestage("authentik_stages_authenticator_validate.authenticatorvalidatestage"),
         @Json(name = "authentik_stages_authenticator_webauthn.authenticatewebauthnstage") stagesAuthenticatorWebauthnPeriodAuthenticatewebauthnstage("authentik_stages_authenticator_webauthn.authenticatewebauthnstage"),
         @Json(name = "authentik_stages_authenticator_webauthn.webauthndevice") stagesAuthenticatorWebauthnPeriodWebauthndevice("authentik_stages_authenticator_webauthn.webauthndevice"),
         @Json(name = "authentik_stages_captcha.captchastage") stagesCaptchaPeriodCaptchastage("authentik_stages_captcha.captchastage"),
         @Json(name = "authentik_stages_consent.consentstage") stagesConsentPeriodConsentstage("authentik_stages_consent.consentstage"),
         @Json(name = "authentik_stages_consent.userconsent") stagesConsentPeriodUserconsent("authentik_stages_consent.userconsent"),
         @Json(name = "authentik_stages_deny.denystage") stagesDenyPeriodDenystage("authentik_stages_deny.denystage"),
         @Json(name = "authentik_stages_dummy.dummystage") stagesDummyPeriodDummystage("authentik_stages_dummy.dummystage"),
         @Json(name = "authentik_stages_email.emailstage") stagesEmailPeriodEmailstage("authentik_stages_email.emailstage"),
         @Json(name = "authentik_stages_identification.identificationstage") stagesIdentificationPeriodIdentificationstage("authentik_stages_identification.identificationstage"),
         @Json(name = "authentik_stages_invitation.invitation") stagesInvitationPeriodInvitation("authentik_stages_invitation.invitation"),
         @Json(name = "authentik_stages_invitation.invitationstage") stagesInvitationPeriodInvitationstage("authentik_stages_invitation.invitationstage"),
         @Json(name = "authentik_stages_password.passwordstage") stagesPasswordPeriodPasswordstage("authentik_stages_password.passwordstage"),
         @Json(name = "authentik_stages_prompt.prompt") stagesPromptPeriodPrompt("authentik_stages_prompt.prompt"),
         @Json(name = "authentik_stages_prompt.promptstage") stagesPromptPeriodPromptstage("authentik_stages_prompt.promptstage"),
         @Json(name = "authentik_stages_user_delete.userdeletestage") stagesUserDeletePeriodUserdeletestage("authentik_stages_user_delete.userdeletestage"),
         @Json(name = "authentik_stages_user_login.userloginstage") stagesUserLoginPeriodUserloginstage("authentik_stages_user_login.userloginstage"),
         @Json(name = "authentik_stages_user_logout.userlogoutstage") stagesUserLogoutPeriodUserlogoutstage("authentik_stages_user_logout.userlogoutstage"),
         @Json(name = "authentik_stages_user_write.userwritestage") stagesUserWritePeriodUserwritestage("authentik_stages_user_write.userwritestage"),
         @Json(name = "authentik_tenants.tenant") tenantsPeriodTenant("authentik_tenants.tenant"),
     }

    /**
     * 
     * Get assigned object permissions for a single object
     * @param model * &#x60;authentik_crypto.certificatekeypair&#x60; - Certificate-Key Pair * &#x60;authentik_events.event&#x60; - Event * &#x60;authentik_events.notificationtransport&#x60; - Notification Transport * &#x60;authentik_events.notification&#x60; - Notification * &#x60;authentik_events.notificationrule&#x60; - Notification Rule * &#x60;authentik_events.notificationwebhookmapping&#x60; - Webhook Mapping * &#x60;authentik_flows.flow&#x60; - Flow * &#x60;authentik_flows.flowstagebinding&#x60; - Flow Stage Binding * &#x60;authentik_outposts.dockerserviceconnection&#x60; - Docker Service-Connection * &#x60;authentik_outposts.kubernetesserviceconnection&#x60; - Kubernetes Service-Connection * &#x60;authentik_outposts.outpost&#x60; - Outpost * &#x60;authentik_policies_dummy.dummypolicy&#x60; - Dummy Policy * &#x60;authentik_policies_event_matcher.eventmatcherpolicy&#x60; - Event Matcher Policy * &#x60;authentik_policies_expiry.passwordexpirypolicy&#x60; - Password Expiry Policy * &#x60;authentik_policies_expression.expressionpolicy&#x60; - Expression Policy * &#x60;authentik_policies_password.passwordpolicy&#x60; - Password Policy * &#x60;authentik_policies_reputation.reputationpolicy&#x60; - Reputation Policy * &#x60;authentik_policies_reputation.reputation&#x60; - Reputation Score * &#x60;authentik_policies.policybinding&#x60; - Policy Binding * &#x60;authentik_providers_ldap.ldapprovider&#x60; - LDAP Provider * &#x60;authentik_providers_oauth2.scopemapping&#x60; - Scope Mapping * &#x60;authentik_providers_oauth2.oauth2provider&#x60; - OAuth2/OpenID Provider * &#x60;authentik_providers_oauth2.authorizationcode&#x60; - Authorization Code * &#x60;authentik_providers_oauth2.accesstoken&#x60; - OAuth2 Access Token * &#x60;authentik_providers_oauth2.refreshtoken&#x60; - OAuth2 Refresh Token * &#x60;authentik_providers_proxy.proxyprovider&#x60; - Proxy Provider * &#x60;authentik_providers_radius.radiusprovider&#x60; - Radius Provider * &#x60;authentik_providers_saml.samlprovider&#x60; - SAML Provider * &#x60;authentik_providers_saml.samlpropertymapping&#x60; - SAML Property Mapping * &#x60;authentik_providers_scim.scimprovider&#x60; - SCIM Provider * &#x60;authentik_providers_scim.scimmapping&#x60; - SCIM Mapping * &#x60;authentik_rbac.role&#x60; - Role * &#x60;authentik_sources_ldap.ldapsource&#x60; - LDAP Source * &#x60;authentik_sources_ldap.ldappropertymapping&#x60; - LDAP Property Mapping * &#x60;authentik_sources_oauth.oauthsource&#x60; - OAuth Source * &#x60;authentik_sources_oauth.useroauthsourceconnection&#x60; - User OAuth Source Connection * &#x60;authentik_sources_plex.plexsource&#x60; - Plex Source * &#x60;authentik_sources_plex.plexsourceconnection&#x60; - User Plex Source Connection * &#x60;authentik_sources_saml.samlsource&#x60; - SAML Source * &#x60;authentik_sources_saml.usersamlsourceconnection&#x60; - User SAML Source Connection * &#x60;authentik_stages_authenticator_duo.authenticatorduostage&#x60; - Duo Authenticator Setup Stage * &#x60;authentik_stages_authenticator_duo.duodevice&#x60; - Duo Device * &#x60;authentik_stages_authenticator_sms.authenticatorsmsstage&#x60; - SMS Authenticator Setup Stage * &#x60;authentik_stages_authenticator_sms.smsdevice&#x60; - SMS Device * &#x60;authentik_stages_authenticator_static.authenticatorstaticstage&#x60; - Static Authenticator Stage * &#x60;authentik_stages_authenticator_static.staticdevice&#x60; - Static Device * &#x60;authentik_stages_authenticator_totp.authenticatortotpstage&#x60; - TOTP Authenticator Setup Stage * &#x60;authentik_stages_authenticator_totp.totpdevice&#x60; - TOTP Device * &#x60;authentik_stages_authenticator_validate.authenticatorvalidatestage&#x60; - Authenticator Validation Stage * &#x60;authentik_stages_authenticator_webauthn.authenticatewebauthnstage&#x60; - WebAuthn Authenticator Setup Stage * &#x60;authentik_stages_authenticator_webauthn.webauthndevice&#x60; - WebAuthn Device * &#x60;authentik_stages_captcha.captchastage&#x60; - Captcha Stage * &#x60;authentik_stages_consent.consentstage&#x60; - Consent Stage * &#x60;authentik_stages_consent.userconsent&#x60; - User Consent * &#x60;authentik_stages_deny.denystage&#x60; - Deny Stage * &#x60;authentik_stages_dummy.dummystage&#x60; - Dummy Stage * &#x60;authentik_stages_email.emailstage&#x60; - Email Stage * &#x60;authentik_stages_identification.identificationstage&#x60; - Identification Stage * &#x60;authentik_stages_invitation.invitationstage&#x60; - Invitation Stage * &#x60;authentik_stages_invitation.invitation&#x60; - Invitation * &#x60;authentik_stages_password.passwordstage&#x60; - Password Stage * &#x60;authentik_stages_prompt.prompt&#x60; - Prompt * &#x60;authentik_stages_prompt.promptstage&#x60; - Prompt Stage * &#x60;authentik_stages_user_delete.userdeletestage&#x60; - User Delete Stage * &#x60;authentik_stages_user_login.userloginstage&#x60; - User Login Stage * &#x60;authentik_stages_user_logout.userlogoutstage&#x60; - User Logout Stage * &#x60;authentik_stages_user_write.userwritestage&#x60; - User Write Stage * &#x60;authentik_tenants.tenant&#x60; - Tenant * &#x60;authentik_blueprints.blueprintinstance&#x60; - Blueprint Instance * &#x60;authentik_core.group&#x60; - Group * &#x60;authentik_core.user&#x60; - User * &#x60;authentik_core.application&#x60; - Application * &#x60;authentik_core.token&#x60; - Token * &#x60;authentik_enterprise.license&#x60; - License
     * @param objectPk  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedRoleAssignedObjectPermissionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacPermissionsAssignedByRolesList(model: Model_rbacPermissionsAssignedByRolesList, objectPk: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedRoleAssignedObjectPermissionList {
        val localVarResponse = rbacPermissionsAssignedByRolesListWithHttpInfo(model = model, objectPk = objectPk, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedRoleAssignedObjectPermissionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get assigned object permissions for a single object
     * @param model * &#x60;authentik_crypto.certificatekeypair&#x60; - Certificate-Key Pair * &#x60;authentik_events.event&#x60; - Event * &#x60;authentik_events.notificationtransport&#x60; - Notification Transport * &#x60;authentik_events.notification&#x60; - Notification * &#x60;authentik_events.notificationrule&#x60; - Notification Rule * &#x60;authentik_events.notificationwebhookmapping&#x60; - Webhook Mapping * &#x60;authentik_flows.flow&#x60; - Flow * &#x60;authentik_flows.flowstagebinding&#x60; - Flow Stage Binding * &#x60;authentik_outposts.dockerserviceconnection&#x60; - Docker Service-Connection * &#x60;authentik_outposts.kubernetesserviceconnection&#x60; - Kubernetes Service-Connection * &#x60;authentik_outposts.outpost&#x60; - Outpost * &#x60;authentik_policies_dummy.dummypolicy&#x60; - Dummy Policy * &#x60;authentik_policies_event_matcher.eventmatcherpolicy&#x60; - Event Matcher Policy * &#x60;authentik_policies_expiry.passwordexpirypolicy&#x60; - Password Expiry Policy * &#x60;authentik_policies_expression.expressionpolicy&#x60; - Expression Policy * &#x60;authentik_policies_password.passwordpolicy&#x60; - Password Policy * &#x60;authentik_policies_reputation.reputationpolicy&#x60; - Reputation Policy * &#x60;authentik_policies_reputation.reputation&#x60; - Reputation Score * &#x60;authentik_policies.policybinding&#x60; - Policy Binding * &#x60;authentik_providers_ldap.ldapprovider&#x60; - LDAP Provider * &#x60;authentik_providers_oauth2.scopemapping&#x60; - Scope Mapping * &#x60;authentik_providers_oauth2.oauth2provider&#x60; - OAuth2/OpenID Provider * &#x60;authentik_providers_oauth2.authorizationcode&#x60; - Authorization Code * &#x60;authentik_providers_oauth2.accesstoken&#x60; - OAuth2 Access Token * &#x60;authentik_providers_oauth2.refreshtoken&#x60; - OAuth2 Refresh Token * &#x60;authentik_providers_proxy.proxyprovider&#x60; - Proxy Provider * &#x60;authentik_providers_radius.radiusprovider&#x60; - Radius Provider * &#x60;authentik_providers_saml.samlprovider&#x60; - SAML Provider * &#x60;authentik_providers_saml.samlpropertymapping&#x60; - SAML Property Mapping * &#x60;authentik_providers_scim.scimprovider&#x60; - SCIM Provider * &#x60;authentik_providers_scim.scimmapping&#x60; - SCIM Mapping * &#x60;authentik_rbac.role&#x60; - Role * &#x60;authentik_sources_ldap.ldapsource&#x60; - LDAP Source * &#x60;authentik_sources_ldap.ldappropertymapping&#x60; - LDAP Property Mapping * &#x60;authentik_sources_oauth.oauthsource&#x60; - OAuth Source * &#x60;authentik_sources_oauth.useroauthsourceconnection&#x60; - User OAuth Source Connection * &#x60;authentik_sources_plex.plexsource&#x60; - Plex Source * &#x60;authentik_sources_plex.plexsourceconnection&#x60; - User Plex Source Connection * &#x60;authentik_sources_saml.samlsource&#x60; - SAML Source * &#x60;authentik_sources_saml.usersamlsourceconnection&#x60; - User SAML Source Connection * &#x60;authentik_stages_authenticator_duo.authenticatorduostage&#x60; - Duo Authenticator Setup Stage * &#x60;authentik_stages_authenticator_duo.duodevice&#x60; - Duo Device * &#x60;authentik_stages_authenticator_sms.authenticatorsmsstage&#x60; - SMS Authenticator Setup Stage * &#x60;authentik_stages_authenticator_sms.smsdevice&#x60; - SMS Device * &#x60;authentik_stages_authenticator_static.authenticatorstaticstage&#x60; - Static Authenticator Stage * &#x60;authentik_stages_authenticator_static.staticdevice&#x60; - Static Device * &#x60;authentik_stages_authenticator_totp.authenticatortotpstage&#x60; - TOTP Authenticator Setup Stage * &#x60;authentik_stages_authenticator_totp.totpdevice&#x60; - TOTP Device * &#x60;authentik_stages_authenticator_validate.authenticatorvalidatestage&#x60; - Authenticator Validation Stage * &#x60;authentik_stages_authenticator_webauthn.authenticatewebauthnstage&#x60; - WebAuthn Authenticator Setup Stage * &#x60;authentik_stages_authenticator_webauthn.webauthndevice&#x60; - WebAuthn Device * &#x60;authentik_stages_captcha.captchastage&#x60; - Captcha Stage * &#x60;authentik_stages_consent.consentstage&#x60; - Consent Stage * &#x60;authentik_stages_consent.userconsent&#x60; - User Consent * &#x60;authentik_stages_deny.denystage&#x60; - Deny Stage * &#x60;authentik_stages_dummy.dummystage&#x60; - Dummy Stage * &#x60;authentik_stages_email.emailstage&#x60; - Email Stage * &#x60;authentik_stages_identification.identificationstage&#x60; - Identification Stage * &#x60;authentik_stages_invitation.invitationstage&#x60; - Invitation Stage * &#x60;authentik_stages_invitation.invitation&#x60; - Invitation * &#x60;authentik_stages_password.passwordstage&#x60; - Password Stage * &#x60;authentik_stages_prompt.prompt&#x60; - Prompt * &#x60;authentik_stages_prompt.promptstage&#x60; - Prompt Stage * &#x60;authentik_stages_user_delete.userdeletestage&#x60; - User Delete Stage * &#x60;authentik_stages_user_login.userloginstage&#x60; - User Login Stage * &#x60;authentik_stages_user_logout.userlogoutstage&#x60; - User Logout Stage * &#x60;authentik_stages_user_write.userwritestage&#x60; - User Write Stage * &#x60;authentik_tenants.tenant&#x60; - Tenant * &#x60;authentik_blueprints.blueprintinstance&#x60; - Blueprint Instance * &#x60;authentik_core.group&#x60; - Group * &#x60;authentik_core.user&#x60; - User * &#x60;authentik_core.application&#x60; - Application * &#x60;authentik_core.token&#x60; - Token * &#x60;authentik_enterprise.license&#x60; - License
     * @param objectPk  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedRoleAssignedObjectPermissionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacPermissionsAssignedByRolesListWithHttpInfo(model: Model_rbacPermissionsAssignedByRolesList, objectPk: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedRoleAssignedObjectPermissionList?> {
        val localVariableConfig = rbacPermissionsAssignedByRolesListRequestConfig(model = model, objectPk = objectPk, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedRoleAssignedObjectPermissionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacPermissionsAssignedByRolesList
     *
     * @param model * &#x60;authentik_crypto.certificatekeypair&#x60; - Certificate-Key Pair * &#x60;authentik_events.event&#x60; - Event * &#x60;authentik_events.notificationtransport&#x60; - Notification Transport * &#x60;authentik_events.notification&#x60; - Notification * &#x60;authentik_events.notificationrule&#x60; - Notification Rule * &#x60;authentik_events.notificationwebhookmapping&#x60; - Webhook Mapping * &#x60;authentik_flows.flow&#x60; - Flow * &#x60;authentik_flows.flowstagebinding&#x60; - Flow Stage Binding * &#x60;authentik_outposts.dockerserviceconnection&#x60; - Docker Service-Connection * &#x60;authentik_outposts.kubernetesserviceconnection&#x60; - Kubernetes Service-Connection * &#x60;authentik_outposts.outpost&#x60; - Outpost * &#x60;authentik_policies_dummy.dummypolicy&#x60; - Dummy Policy * &#x60;authentik_policies_event_matcher.eventmatcherpolicy&#x60; - Event Matcher Policy * &#x60;authentik_policies_expiry.passwordexpirypolicy&#x60; - Password Expiry Policy * &#x60;authentik_policies_expression.expressionpolicy&#x60; - Expression Policy * &#x60;authentik_policies_password.passwordpolicy&#x60; - Password Policy * &#x60;authentik_policies_reputation.reputationpolicy&#x60; - Reputation Policy * &#x60;authentik_policies_reputation.reputation&#x60; - Reputation Score * &#x60;authentik_policies.policybinding&#x60; - Policy Binding * &#x60;authentik_providers_ldap.ldapprovider&#x60; - LDAP Provider * &#x60;authentik_providers_oauth2.scopemapping&#x60; - Scope Mapping * &#x60;authentik_providers_oauth2.oauth2provider&#x60; - OAuth2/OpenID Provider * &#x60;authentik_providers_oauth2.authorizationcode&#x60; - Authorization Code * &#x60;authentik_providers_oauth2.accesstoken&#x60; - OAuth2 Access Token * &#x60;authentik_providers_oauth2.refreshtoken&#x60; - OAuth2 Refresh Token * &#x60;authentik_providers_proxy.proxyprovider&#x60; - Proxy Provider * &#x60;authentik_providers_radius.radiusprovider&#x60; - Radius Provider * &#x60;authentik_providers_saml.samlprovider&#x60; - SAML Provider * &#x60;authentik_providers_saml.samlpropertymapping&#x60; - SAML Property Mapping * &#x60;authentik_providers_scim.scimprovider&#x60; - SCIM Provider * &#x60;authentik_providers_scim.scimmapping&#x60; - SCIM Mapping * &#x60;authentik_rbac.role&#x60; - Role * &#x60;authentik_sources_ldap.ldapsource&#x60; - LDAP Source * &#x60;authentik_sources_ldap.ldappropertymapping&#x60; - LDAP Property Mapping * &#x60;authentik_sources_oauth.oauthsource&#x60; - OAuth Source * &#x60;authentik_sources_oauth.useroauthsourceconnection&#x60; - User OAuth Source Connection * &#x60;authentik_sources_plex.plexsource&#x60; - Plex Source * &#x60;authentik_sources_plex.plexsourceconnection&#x60; - User Plex Source Connection * &#x60;authentik_sources_saml.samlsource&#x60; - SAML Source * &#x60;authentik_sources_saml.usersamlsourceconnection&#x60; - User SAML Source Connection * &#x60;authentik_stages_authenticator_duo.authenticatorduostage&#x60; - Duo Authenticator Setup Stage * &#x60;authentik_stages_authenticator_duo.duodevice&#x60; - Duo Device * &#x60;authentik_stages_authenticator_sms.authenticatorsmsstage&#x60; - SMS Authenticator Setup Stage * &#x60;authentik_stages_authenticator_sms.smsdevice&#x60; - SMS Device * &#x60;authentik_stages_authenticator_static.authenticatorstaticstage&#x60; - Static Authenticator Stage * &#x60;authentik_stages_authenticator_static.staticdevice&#x60; - Static Device * &#x60;authentik_stages_authenticator_totp.authenticatortotpstage&#x60; - TOTP Authenticator Setup Stage * &#x60;authentik_stages_authenticator_totp.totpdevice&#x60; - TOTP Device * &#x60;authentik_stages_authenticator_validate.authenticatorvalidatestage&#x60; - Authenticator Validation Stage * &#x60;authentik_stages_authenticator_webauthn.authenticatewebauthnstage&#x60; - WebAuthn Authenticator Setup Stage * &#x60;authentik_stages_authenticator_webauthn.webauthndevice&#x60; - WebAuthn Device * &#x60;authentik_stages_captcha.captchastage&#x60; - Captcha Stage * &#x60;authentik_stages_consent.consentstage&#x60; - Consent Stage * &#x60;authentik_stages_consent.userconsent&#x60; - User Consent * &#x60;authentik_stages_deny.denystage&#x60; - Deny Stage * &#x60;authentik_stages_dummy.dummystage&#x60; - Dummy Stage * &#x60;authentik_stages_email.emailstage&#x60; - Email Stage * &#x60;authentik_stages_identification.identificationstage&#x60; - Identification Stage * &#x60;authentik_stages_invitation.invitationstage&#x60; - Invitation Stage * &#x60;authentik_stages_invitation.invitation&#x60; - Invitation * &#x60;authentik_stages_password.passwordstage&#x60; - Password Stage * &#x60;authentik_stages_prompt.prompt&#x60; - Prompt * &#x60;authentik_stages_prompt.promptstage&#x60; - Prompt Stage * &#x60;authentik_stages_user_delete.userdeletestage&#x60; - User Delete Stage * &#x60;authentik_stages_user_login.userloginstage&#x60; - User Login Stage * &#x60;authentik_stages_user_logout.userlogoutstage&#x60; - User Logout Stage * &#x60;authentik_stages_user_write.userwritestage&#x60; - User Write Stage * &#x60;authentik_tenants.tenant&#x60; - Tenant * &#x60;authentik_blueprints.blueprintinstance&#x60; - Blueprint Instance * &#x60;authentik_core.group&#x60; - Group * &#x60;authentik_core.user&#x60; - User * &#x60;authentik_core.application&#x60; - Application * &#x60;authentik_core.token&#x60; - Token * &#x60;authentik_enterprise.license&#x60; - License
     * @param objectPk  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun rbacPermissionsAssignedByRolesListRequestConfig(model: Model_rbacPermissionsAssignedByRolesList, objectPk: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("model", listOf(model.toString()))
                if (objectPk != null) {
                    put("object_pk", listOf(objectPk.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rbac/permissions/assigned_by_roles/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Unassign permission(s) to role. When &#x60;object_pk&#x60; is set, the permissions are only assigned to the specific object, otherwise they are assigned globally.
     * @param uuid A UUID string identifying this Role.
     * @param patchedPermissionAssignRequest  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacPermissionsAssignedByRolesUnassignPartialUpdate(uuid: java.util.UUID, patchedPermissionAssignRequest: PatchedPermissionAssignRequest? = null) : Unit {
        val localVarResponse = rbacPermissionsAssignedByRolesUnassignPartialUpdateWithHttpInfo(uuid = uuid, patchedPermissionAssignRequest = patchedPermissionAssignRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Unassign permission(s) to role. When &#x60;object_pk&#x60; is set, the permissions are only assigned to the specific object, otherwise they are assigned globally.
     * @param uuid A UUID string identifying this Role.
     * @param patchedPermissionAssignRequest  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacPermissionsAssignedByRolesUnassignPartialUpdateWithHttpInfo(uuid: java.util.UUID, patchedPermissionAssignRequest: PatchedPermissionAssignRequest?) : ApiResponse<Unit?> {
        val localVariableConfig = rbacPermissionsAssignedByRolesUnassignPartialUpdateRequestConfig(uuid = uuid, patchedPermissionAssignRequest = patchedPermissionAssignRequest)

        return request<PatchedPermissionAssignRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacPermissionsAssignedByRolesUnassignPartialUpdate
     *
     * @param uuid A UUID string identifying this Role.
     * @param patchedPermissionAssignRequest  (optional)
     * @return RequestConfig
     */
    fun rbacPermissionsAssignedByRolesUnassignPartialUpdateRequestConfig(uuid: java.util.UUID, patchedPermissionAssignRequest: PatchedPermissionAssignRequest?) : RequestConfig<PatchedPermissionAssignRequest> {
        val localVariableBody = patchedPermissionAssignRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/rbac/permissions/assigned_by_roles/{uuid}/unassign/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Assign permission(s) to user
     * @param id A unique integer value identifying this User.
     * @param permissionAssignRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacPermissionsAssignedByUsersAssignCreate(id: kotlin.Int, permissionAssignRequest: PermissionAssignRequest) : Unit {
        val localVarResponse = rbacPermissionsAssignedByUsersAssignCreateWithHttpInfo(id = id, permissionAssignRequest = permissionAssignRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Assign permission(s) to user
     * @param id A unique integer value identifying this User.
     * @param permissionAssignRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacPermissionsAssignedByUsersAssignCreateWithHttpInfo(id: kotlin.Int, permissionAssignRequest: PermissionAssignRequest) : ApiResponse<Unit?> {
        val localVariableConfig = rbacPermissionsAssignedByUsersAssignCreateRequestConfig(id = id, permissionAssignRequest = permissionAssignRequest)

        return request<PermissionAssignRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacPermissionsAssignedByUsersAssignCreate
     *
     * @param id A unique integer value identifying this User.
     * @param permissionAssignRequest 
     * @return RequestConfig
     */
    fun rbacPermissionsAssignedByUsersAssignCreateRequestConfig(id: kotlin.Int, permissionAssignRequest: PermissionAssignRequest) : RequestConfig<PermissionAssignRequest> {
        val localVariableBody = permissionAssignRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rbac/permissions/assigned_by_users/{id}/assign/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter model
     */
     enum class Model_rbacPermissionsAssignedByUsersList(val value: kotlin.String) {
         @Json(name = "authentik_blueprints.blueprintinstance") blueprintsPeriodBlueprintinstance("authentik_blueprints.blueprintinstance"),
         @Json(name = "authentik_core.application") corePeriodApplication("authentik_core.application"),
         @Json(name = "authentik_core.group") corePeriodGroup("authentik_core.group"),
         @Json(name = "authentik_core.token") corePeriodToken("authentik_core.token"),
         @Json(name = "authentik_core.user") corePeriodUser("authentik_core.user"),
         @Json(name = "authentik_crypto.certificatekeypair") cryptoPeriodCertificatekeypair("authentik_crypto.certificatekeypair"),
         @Json(name = "authentik_enterprise.license") enterprisePeriodLicense("authentik_enterprise.license"),
         @Json(name = "authentik_events.event") eventsPeriodEvent("authentik_events.event"),
         @Json(name = "authentik_events.notification") eventsPeriodNotification("authentik_events.notification"),
         @Json(name = "authentik_events.notificationrule") eventsPeriodNotificationrule("authentik_events.notificationrule"),
         @Json(name = "authentik_events.notificationtransport") eventsPeriodNotificationtransport("authentik_events.notificationtransport"),
         @Json(name = "authentik_events.notificationwebhookmapping") eventsPeriodNotificationwebhookmapping("authentik_events.notificationwebhookmapping"),
         @Json(name = "authentik_flows.flow") flowsPeriodFlow("authentik_flows.flow"),
         @Json(name = "authentik_flows.flowstagebinding") flowsPeriodFlowstagebinding("authentik_flows.flowstagebinding"),
         @Json(name = "authentik_outposts.dockerserviceconnection") outpostsPeriodDockerserviceconnection("authentik_outposts.dockerserviceconnection"),
         @Json(name = "authentik_outposts.kubernetesserviceconnection") outpostsPeriodKubernetesserviceconnection("authentik_outposts.kubernetesserviceconnection"),
         @Json(name = "authentik_outposts.outpost") outpostsPeriodOutpost("authentik_outposts.outpost"),
         @Json(name = "authentik_policies.policybinding") policiesPeriodPolicybinding("authentik_policies.policybinding"),
         @Json(name = "authentik_policies_dummy.dummypolicy") policiesDummyPeriodDummypolicy("authentik_policies_dummy.dummypolicy"),
         @Json(name = "authentik_policies_event_matcher.eventmatcherpolicy") policiesEventMatcherPeriodEventmatcherpolicy("authentik_policies_event_matcher.eventmatcherpolicy"),
         @Json(name = "authentik_policies_expiry.passwordexpirypolicy") policiesExpiryPeriodPasswordexpirypolicy("authentik_policies_expiry.passwordexpirypolicy"),
         @Json(name = "authentik_policies_expression.expressionpolicy") policiesExpressionPeriodExpressionpolicy("authentik_policies_expression.expressionpolicy"),
         @Json(name = "authentik_policies_password.passwordpolicy") policiesPasswordPeriodPasswordpolicy("authentik_policies_password.passwordpolicy"),
         @Json(name = "authentik_policies_reputation.reputation") policiesReputationPeriodReputation("authentik_policies_reputation.reputation"),
         @Json(name = "authentik_policies_reputation.reputationpolicy") policiesReputationPeriodReputationpolicy("authentik_policies_reputation.reputationpolicy"),
         @Json(name = "authentik_providers_ldap.ldapprovider") providersLdapPeriodLdapprovider("authentik_providers_ldap.ldapprovider"),
         @Json(name = "authentik_providers_oauth2.accesstoken") providersOauth2PeriodAccesstoken("authentik_providers_oauth2.accesstoken"),
         @Json(name = "authentik_providers_oauth2.authorizationcode") providersOauth2PeriodAuthorizationcode("authentik_providers_oauth2.authorizationcode"),
         @Json(name = "authentik_providers_oauth2.oauth2provider") providersOauth2PeriodOauth2provider("authentik_providers_oauth2.oauth2provider"),
         @Json(name = "authentik_providers_oauth2.refreshtoken") providersOauth2PeriodRefreshtoken("authentik_providers_oauth2.refreshtoken"),
         @Json(name = "authentik_providers_oauth2.scopemapping") providersOauth2PeriodScopemapping("authentik_providers_oauth2.scopemapping"),
         @Json(name = "authentik_providers_proxy.proxyprovider") providersProxyPeriodProxyprovider("authentik_providers_proxy.proxyprovider"),
         @Json(name = "authentik_providers_radius.radiusprovider") providersRadiusPeriodRadiusprovider("authentik_providers_radius.radiusprovider"),
         @Json(name = "authentik_providers_saml.samlpropertymapping") providersSamlPeriodSamlpropertymapping("authentik_providers_saml.samlpropertymapping"),
         @Json(name = "authentik_providers_saml.samlprovider") providersSamlPeriodSamlprovider("authentik_providers_saml.samlprovider"),
         @Json(name = "authentik_providers_scim.scimmapping") providersScimPeriodScimmapping("authentik_providers_scim.scimmapping"),
         @Json(name = "authentik_providers_scim.scimprovider") providersScimPeriodScimprovider("authentik_providers_scim.scimprovider"),
         @Json(name = "authentik_rbac.role") rbacPeriodRole("authentik_rbac.role"),
         @Json(name = "authentik_sources_ldap.ldappropertymapping") sourcesLdapPeriodLdappropertymapping("authentik_sources_ldap.ldappropertymapping"),
         @Json(name = "authentik_sources_ldap.ldapsource") sourcesLdapPeriodLdapsource("authentik_sources_ldap.ldapsource"),
         @Json(name = "authentik_sources_oauth.oauthsource") sourcesOauthPeriodOauthsource("authentik_sources_oauth.oauthsource"),
         @Json(name = "authentik_sources_oauth.useroauthsourceconnection") sourcesOauthPeriodUseroauthsourceconnection("authentik_sources_oauth.useroauthsourceconnection"),
         @Json(name = "authentik_sources_plex.plexsource") sourcesPlexPeriodPlexsource("authentik_sources_plex.plexsource"),
         @Json(name = "authentik_sources_plex.plexsourceconnection") sourcesPlexPeriodPlexsourceconnection("authentik_sources_plex.plexsourceconnection"),
         @Json(name = "authentik_sources_saml.samlsource") sourcesSamlPeriodSamlsource("authentik_sources_saml.samlsource"),
         @Json(name = "authentik_sources_saml.usersamlsourceconnection") sourcesSamlPeriodUsersamlsourceconnection("authentik_sources_saml.usersamlsourceconnection"),
         @Json(name = "authentik_stages_authenticator_duo.authenticatorduostage") stagesAuthenticatorDuoPeriodAuthenticatorduostage("authentik_stages_authenticator_duo.authenticatorduostage"),
         @Json(name = "authentik_stages_authenticator_duo.duodevice") stagesAuthenticatorDuoPeriodDuodevice("authentik_stages_authenticator_duo.duodevice"),
         @Json(name = "authentik_stages_authenticator_sms.authenticatorsmsstage") stagesAuthenticatorSmsPeriodAuthenticatorsmsstage("authentik_stages_authenticator_sms.authenticatorsmsstage"),
         @Json(name = "authentik_stages_authenticator_sms.smsdevice") stagesAuthenticatorSmsPeriodSmsdevice("authentik_stages_authenticator_sms.smsdevice"),
         @Json(name = "authentik_stages_authenticator_static.authenticatorstaticstage") stagesAuthenticatorStaticPeriodAuthenticatorstaticstage("authentik_stages_authenticator_static.authenticatorstaticstage"),
         @Json(name = "authentik_stages_authenticator_static.staticdevice") stagesAuthenticatorStaticPeriodStaticdevice("authentik_stages_authenticator_static.staticdevice"),
         @Json(name = "authentik_stages_authenticator_totp.authenticatortotpstage") stagesAuthenticatorTotpPeriodAuthenticatortotpstage("authentik_stages_authenticator_totp.authenticatortotpstage"),
         @Json(name = "authentik_stages_authenticator_totp.totpdevice") stagesAuthenticatorTotpPeriodTotpdevice("authentik_stages_authenticator_totp.totpdevice"),
         @Json(name = "authentik_stages_authenticator_validate.authenticatorvalidatestage") stagesAuthenticatorValidatePeriodAuthenticatorvalidatestage("authentik_stages_authenticator_validate.authenticatorvalidatestage"),
         @Json(name = "authentik_stages_authenticator_webauthn.authenticatewebauthnstage") stagesAuthenticatorWebauthnPeriodAuthenticatewebauthnstage("authentik_stages_authenticator_webauthn.authenticatewebauthnstage"),
         @Json(name = "authentik_stages_authenticator_webauthn.webauthndevice") stagesAuthenticatorWebauthnPeriodWebauthndevice("authentik_stages_authenticator_webauthn.webauthndevice"),
         @Json(name = "authentik_stages_captcha.captchastage") stagesCaptchaPeriodCaptchastage("authentik_stages_captcha.captchastage"),
         @Json(name = "authentik_stages_consent.consentstage") stagesConsentPeriodConsentstage("authentik_stages_consent.consentstage"),
         @Json(name = "authentik_stages_consent.userconsent") stagesConsentPeriodUserconsent("authentik_stages_consent.userconsent"),
         @Json(name = "authentik_stages_deny.denystage") stagesDenyPeriodDenystage("authentik_stages_deny.denystage"),
         @Json(name = "authentik_stages_dummy.dummystage") stagesDummyPeriodDummystage("authentik_stages_dummy.dummystage"),
         @Json(name = "authentik_stages_email.emailstage") stagesEmailPeriodEmailstage("authentik_stages_email.emailstage"),
         @Json(name = "authentik_stages_identification.identificationstage") stagesIdentificationPeriodIdentificationstage("authentik_stages_identification.identificationstage"),
         @Json(name = "authentik_stages_invitation.invitation") stagesInvitationPeriodInvitation("authentik_stages_invitation.invitation"),
         @Json(name = "authentik_stages_invitation.invitationstage") stagesInvitationPeriodInvitationstage("authentik_stages_invitation.invitationstage"),
         @Json(name = "authentik_stages_password.passwordstage") stagesPasswordPeriodPasswordstage("authentik_stages_password.passwordstage"),
         @Json(name = "authentik_stages_prompt.prompt") stagesPromptPeriodPrompt("authentik_stages_prompt.prompt"),
         @Json(name = "authentik_stages_prompt.promptstage") stagesPromptPeriodPromptstage("authentik_stages_prompt.promptstage"),
         @Json(name = "authentik_stages_user_delete.userdeletestage") stagesUserDeletePeriodUserdeletestage("authentik_stages_user_delete.userdeletestage"),
         @Json(name = "authentik_stages_user_login.userloginstage") stagesUserLoginPeriodUserloginstage("authentik_stages_user_login.userloginstage"),
         @Json(name = "authentik_stages_user_logout.userlogoutstage") stagesUserLogoutPeriodUserlogoutstage("authentik_stages_user_logout.userlogoutstage"),
         @Json(name = "authentik_stages_user_write.userwritestage") stagesUserWritePeriodUserwritestage("authentik_stages_user_write.userwritestage"),
         @Json(name = "authentik_tenants.tenant") tenantsPeriodTenant("authentik_tenants.tenant"),
     }

    /**
     * 
     * Get assigned object permissions for a single object
     * @param model * &#x60;authentik_crypto.certificatekeypair&#x60; - Certificate-Key Pair * &#x60;authentik_events.event&#x60; - Event * &#x60;authentik_events.notificationtransport&#x60; - Notification Transport * &#x60;authentik_events.notification&#x60; - Notification * &#x60;authentik_events.notificationrule&#x60; - Notification Rule * &#x60;authentik_events.notificationwebhookmapping&#x60; - Webhook Mapping * &#x60;authentik_flows.flow&#x60; - Flow * &#x60;authentik_flows.flowstagebinding&#x60; - Flow Stage Binding * &#x60;authentik_outposts.dockerserviceconnection&#x60; - Docker Service-Connection * &#x60;authentik_outposts.kubernetesserviceconnection&#x60; - Kubernetes Service-Connection * &#x60;authentik_outposts.outpost&#x60; - Outpost * &#x60;authentik_policies_dummy.dummypolicy&#x60; - Dummy Policy * &#x60;authentik_policies_event_matcher.eventmatcherpolicy&#x60; - Event Matcher Policy * &#x60;authentik_policies_expiry.passwordexpirypolicy&#x60; - Password Expiry Policy * &#x60;authentik_policies_expression.expressionpolicy&#x60; - Expression Policy * &#x60;authentik_policies_password.passwordpolicy&#x60; - Password Policy * &#x60;authentik_policies_reputation.reputationpolicy&#x60; - Reputation Policy * &#x60;authentik_policies_reputation.reputation&#x60; - Reputation Score * &#x60;authentik_policies.policybinding&#x60; - Policy Binding * &#x60;authentik_providers_ldap.ldapprovider&#x60; - LDAP Provider * &#x60;authentik_providers_oauth2.scopemapping&#x60; - Scope Mapping * &#x60;authentik_providers_oauth2.oauth2provider&#x60; - OAuth2/OpenID Provider * &#x60;authentik_providers_oauth2.authorizationcode&#x60; - Authorization Code * &#x60;authentik_providers_oauth2.accesstoken&#x60; - OAuth2 Access Token * &#x60;authentik_providers_oauth2.refreshtoken&#x60; - OAuth2 Refresh Token * &#x60;authentik_providers_proxy.proxyprovider&#x60; - Proxy Provider * &#x60;authentik_providers_radius.radiusprovider&#x60; - Radius Provider * &#x60;authentik_providers_saml.samlprovider&#x60; - SAML Provider * &#x60;authentik_providers_saml.samlpropertymapping&#x60; - SAML Property Mapping * &#x60;authentik_providers_scim.scimprovider&#x60; - SCIM Provider * &#x60;authentik_providers_scim.scimmapping&#x60; - SCIM Mapping * &#x60;authentik_rbac.role&#x60; - Role * &#x60;authentik_sources_ldap.ldapsource&#x60; - LDAP Source * &#x60;authentik_sources_ldap.ldappropertymapping&#x60; - LDAP Property Mapping * &#x60;authentik_sources_oauth.oauthsource&#x60; - OAuth Source * &#x60;authentik_sources_oauth.useroauthsourceconnection&#x60; - User OAuth Source Connection * &#x60;authentik_sources_plex.plexsource&#x60; - Plex Source * &#x60;authentik_sources_plex.plexsourceconnection&#x60; - User Plex Source Connection * &#x60;authentik_sources_saml.samlsource&#x60; - SAML Source * &#x60;authentik_sources_saml.usersamlsourceconnection&#x60; - User SAML Source Connection * &#x60;authentik_stages_authenticator_duo.authenticatorduostage&#x60; - Duo Authenticator Setup Stage * &#x60;authentik_stages_authenticator_duo.duodevice&#x60; - Duo Device * &#x60;authentik_stages_authenticator_sms.authenticatorsmsstage&#x60; - SMS Authenticator Setup Stage * &#x60;authentik_stages_authenticator_sms.smsdevice&#x60; - SMS Device * &#x60;authentik_stages_authenticator_static.authenticatorstaticstage&#x60; - Static Authenticator Stage * &#x60;authentik_stages_authenticator_static.staticdevice&#x60; - Static Device * &#x60;authentik_stages_authenticator_totp.authenticatortotpstage&#x60; - TOTP Authenticator Setup Stage * &#x60;authentik_stages_authenticator_totp.totpdevice&#x60; - TOTP Device * &#x60;authentik_stages_authenticator_validate.authenticatorvalidatestage&#x60; - Authenticator Validation Stage * &#x60;authentik_stages_authenticator_webauthn.authenticatewebauthnstage&#x60; - WebAuthn Authenticator Setup Stage * &#x60;authentik_stages_authenticator_webauthn.webauthndevice&#x60; - WebAuthn Device * &#x60;authentik_stages_captcha.captchastage&#x60; - Captcha Stage * &#x60;authentik_stages_consent.consentstage&#x60; - Consent Stage * &#x60;authentik_stages_consent.userconsent&#x60; - User Consent * &#x60;authentik_stages_deny.denystage&#x60; - Deny Stage * &#x60;authentik_stages_dummy.dummystage&#x60; - Dummy Stage * &#x60;authentik_stages_email.emailstage&#x60; - Email Stage * &#x60;authentik_stages_identification.identificationstage&#x60; - Identification Stage * &#x60;authentik_stages_invitation.invitationstage&#x60; - Invitation Stage * &#x60;authentik_stages_invitation.invitation&#x60; - Invitation * &#x60;authentik_stages_password.passwordstage&#x60; - Password Stage * &#x60;authentik_stages_prompt.prompt&#x60; - Prompt * &#x60;authentik_stages_prompt.promptstage&#x60; - Prompt Stage * &#x60;authentik_stages_user_delete.userdeletestage&#x60; - User Delete Stage * &#x60;authentik_stages_user_login.userloginstage&#x60; - User Login Stage * &#x60;authentik_stages_user_logout.userlogoutstage&#x60; - User Logout Stage * &#x60;authentik_stages_user_write.userwritestage&#x60; - User Write Stage * &#x60;authentik_tenants.tenant&#x60; - Tenant * &#x60;authentik_blueprints.blueprintinstance&#x60; - Blueprint Instance * &#x60;authentik_core.group&#x60; - Group * &#x60;authentik_core.user&#x60; - User * &#x60;authentik_core.application&#x60; - Application * &#x60;authentik_core.token&#x60; - Token * &#x60;authentik_enterprise.license&#x60; - License
     * @param objectPk  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedUserAssignedObjectPermissionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacPermissionsAssignedByUsersList(model: Model_rbacPermissionsAssignedByUsersList, objectPk: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedUserAssignedObjectPermissionList {
        val localVarResponse = rbacPermissionsAssignedByUsersListWithHttpInfo(model = model, objectPk = objectPk, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedUserAssignedObjectPermissionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get assigned object permissions for a single object
     * @param model * &#x60;authentik_crypto.certificatekeypair&#x60; - Certificate-Key Pair * &#x60;authentik_events.event&#x60; - Event * &#x60;authentik_events.notificationtransport&#x60; - Notification Transport * &#x60;authentik_events.notification&#x60; - Notification * &#x60;authentik_events.notificationrule&#x60; - Notification Rule * &#x60;authentik_events.notificationwebhookmapping&#x60; - Webhook Mapping * &#x60;authentik_flows.flow&#x60; - Flow * &#x60;authentik_flows.flowstagebinding&#x60; - Flow Stage Binding * &#x60;authentik_outposts.dockerserviceconnection&#x60; - Docker Service-Connection * &#x60;authentik_outposts.kubernetesserviceconnection&#x60; - Kubernetes Service-Connection * &#x60;authentik_outposts.outpost&#x60; - Outpost * &#x60;authentik_policies_dummy.dummypolicy&#x60; - Dummy Policy * &#x60;authentik_policies_event_matcher.eventmatcherpolicy&#x60; - Event Matcher Policy * &#x60;authentik_policies_expiry.passwordexpirypolicy&#x60; - Password Expiry Policy * &#x60;authentik_policies_expression.expressionpolicy&#x60; - Expression Policy * &#x60;authentik_policies_password.passwordpolicy&#x60; - Password Policy * &#x60;authentik_policies_reputation.reputationpolicy&#x60; - Reputation Policy * &#x60;authentik_policies_reputation.reputation&#x60; - Reputation Score * &#x60;authentik_policies.policybinding&#x60; - Policy Binding * &#x60;authentik_providers_ldap.ldapprovider&#x60; - LDAP Provider * &#x60;authentik_providers_oauth2.scopemapping&#x60; - Scope Mapping * &#x60;authentik_providers_oauth2.oauth2provider&#x60; - OAuth2/OpenID Provider * &#x60;authentik_providers_oauth2.authorizationcode&#x60; - Authorization Code * &#x60;authentik_providers_oauth2.accesstoken&#x60; - OAuth2 Access Token * &#x60;authentik_providers_oauth2.refreshtoken&#x60; - OAuth2 Refresh Token * &#x60;authentik_providers_proxy.proxyprovider&#x60; - Proxy Provider * &#x60;authentik_providers_radius.radiusprovider&#x60; - Radius Provider * &#x60;authentik_providers_saml.samlprovider&#x60; - SAML Provider * &#x60;authentik_providers_saml.samlpropertymapping&#x60; - SAML Property Mapping * &#x60;authentik_providers_scim.scimprovider&#x60; - SCIM Provider * &#x60;authentik_providers_scim.scimmapping&#x60; - SCIM Mapping * &#x60;authentik_rbac.role&#x60; - Role * &#x60;authentik_sources_ldap.ldapsource&#x60; - LDAP Source * &#x60;authentik_sources_ldap.ldappropertymapping&#x60; - LDAP Property Mapping * &#x60;authentik_sources_oauth.oauthsource&#x60; - OAuth Source * &#x60;authentik_sources_oauth.useroauthsourceconnection&#x60; - User OAuth Source Connection * &#x60;authentik_sources_plex.plexsource&#x60; - Plex Source * &#x60;authentik_sources_plex.plexsourceconnection&#x60; - User Plex Source Connection * &#x60;authentik_sources_saml.samlsource&#x60; - SAML Source * &#x60;authentik_sources_saml.usersamlsourceconnection&#x60; - User SAML Source Connection * &#x60;authentik_stages_authenticator_duo.authenticatorduostage&#x60; - Duo Authenticator Setup Stage * &#x60;authentik_stages_authenticator_duo.duodevice&#x60; - Duo Device * &#x60;authentik_stages_authenticator_sms.authenticatorsmsstage&#x60; - SMS Authenticator Setup Stage * &#x60;authentik_stages_authenticator_sms.smsdevice&#x60; - SMS Device * &#x60;authentik_stages_authenticator_static.authenticatorstaticstage&#x60; - Static Authenticator Stage * &#x60;authentik_stages_authenticator_static.staticdevice&#x60; - Static Device * &#x60;authentik_stages_authenticator_totp.authenticatortotpstage&#x60; - TOTP Authenticator Setup Stage * &#x60;authentik_stages_authenticator_totp.totpdevice&#x60; - TOTP Device * &#x60;authentik_stages_authenticator_validate.authenticatorvalidatestage&#x60; - Authenticator Validation Stage * &#x60;authentik_stages_authenticator_webauthn.authenticatewebauthnstage&#x60; - WebAuthn Authenticator Setup Stage * &#x60;authentik_stages_authenticator_webauthn.webauthndevice&#x60; - WebAuthn Device * &#x60;authentik_stages_captcha.captchastage&#x60; - Captcha Stage * &#x60;authentik_stages_consent.consentstage&#x60; - Consent Stage * &#x60;authentik_stages_consent.userconsent&#x60; - User Consent * &#x60;authentik_stages_deny.denystage&#x60; - Deny Stage * &#x60;authentik_stages_dummy.dummystage&#x60; - Dummy Stage * &#x60;authentik_stages_email.emailstage&#x60; - Email Stage * &#x60;authentik_stages_identification.identificationstage&#x60; - Identification Stage * &#x60;authentik_stages_invitation.invitationstage&#x60; - Invitation Stage * &#x60;authentik_stages_invitation.invitation&#x60; - Invitation * &#x60;authentik_stages_password.passwordstage&#x60; - Password Stage * &#x60;authentik_stages_prompt.prompt&#x60; - Prompt * &#x60;authentik_stages_prompt.promptstage&#x60; - Prompt Stage * &#x60;authentik_stages_user_delete.userdeletestage&#x60; - User Delete Stage * &#x60;authentik_stages_user_login.userloginstage&#x60; - User Login Stage * &#x60;authentik_stages_user_logout.userlogoutstage&#x60; - User Logout Stage * &#x60;authentik_stages_user_write.userwritestage&#x60; - User Write Stage * &#x60;authentik_tenants.tenant&#x60; - Tenant * &#x60;authentik_blueprints.blueprintinstance&#x60; - Blueprint Instance * &#x60;authentik_core.group&#x60; - Group * &#x60;authentik_core.user&#x60; - User * &#x60;authentik_core.application&#x60; - Application * &#x60;authentik_core.token&#x60; - Token * &#x60;authentik_enterprise.license&#x60; - License
     * @param objectPk  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedUserAssignedObjectPermissionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacPermissionsAssignedByUsersListWithHttpInfo(model: Model_rbacPermissionsAssignedByUsersList, objectPk: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedUserAssignedObjectPermissionList?> {
        val localVariableConfig = rbacPermissionsAssignedByUsersListRequestConfig(model = model, objectPk = objectPk, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedUserAssignedObjectPermissionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacPermissionsAssignedByUsersList
     *
     * @param model * &#x60;authentik_crypto.certificatekeypair&#x60; - Certificate-Key Pair * &#x60;authentik_events.event&#x60; - Event * &#x60;authentik_events.notificationtransport&#x60; - Notification Transport * &#x60;authentik_events.notification&#x60; - Notification * &#x60;authentik_events.notificationrule&#x60; - Notification Rule * &#x60;authentik_events.notificationwebhookmapping&#x60; - Webhook Mapping * &#x60;authentik_flows.flow&#x60; - Flow * &#x60;authentik_flows.flowstagebinding&#x60; - Flow Stage Binding * &#x60;authentik_outposts.dockerserviceconnection&#x60; - Docker Service-Connection * &#x60;authentik_outposts.kubernetesserviceconnection&#x60; - Kubernetes Service-Connection * &#x60;authentik_outposts.outpost&#x60; - Outpost * &#x60;authentik_policies_dummy.dummypolicy&#x60; - Dummy Policy * &#x60;authentik_policies_event_matcher.eventmatcherpolicy&#x60; - Event Matcher Policy * &#x60;authentik_policies_expiry.passwordexpirypolicy&#x60; - Password Expiry Policy * &#x60;authentik_policies_expression.expressionpolicy&#x60; - Expression Policy * &#x60;authentik_policies_password.passwordpolicy&#x60; - Password Policy * &#x60;authentik_policies_reputation.reputationpolicy&#x60; - Reputation Policy * &#x60;authentik_policies_reputation.reputation&#x60; - Reputation Score * &#x60;authentik_policies.policybinding&#x60; - Policy Binding * &#x60;authentik_providers_ldap.ldapprovider&#x60; - LDAP Provider * &#x60;authentik_providers_oauth2.scopemapping&#x60; - Scope Mapping * &#x60;authentik_providers_oauth2.oauth2provider&#x60; - OAuth2/OpenID Provider * &#x60;authentik_providers_oauth2.authorizationcode&#x60; - Authorization Code * &#x60;authentik_providers_oauth2.accesstoken&#x60; - OAuth2 Access Token * &#x60;authentik_providers_oauth2.refreshtoken&#x60; - OAuth2 Refresh Token * &#x60;authentik_providers_proxy.proxyprovider&#x60; - Proxy Provider * &#x60;authentik_providers_radius.radiusprovider&#x60; - Radius Provider * &#x60;authentik_providers_saml.samlprovider&#x60; - SAML Provider * &#x60;authentik_providers_saml.samlpropertymapping&#x60; - SAML Property Mapping * &#x60;authentik_providers_scim.scimprovider&#x60; - SCIM Provider * &#x60;authentik_providers_scim.scimmapping&#x60; - SCIM Mapping * &#x60;authentik_rbac.role&#x60; - Role * &#x60;authentik_sources_ldap.ldapsource&#x60; - LDAP Source * &#x60;authentik_sources_ldap.ldappropertymapping&#x60; - LDAP Property Mapping * &#x60;authentik_sources_oauth.oauthsource&#x60; - OAuth Source * &#x60;authentik_sources_oauth.useroauthsourceconnection&#x60; - User OAuth Source Connection * &#x60;authentik_sources_plex.plexsource&#x60; - Plex Source * &#x60;authentik_sources_plex.plexsourceconnection&#x60; - User Plex Source Connection * &#x60;authentik_sources_saml.samlsource&#x60; - SAML Source * &#x60;authentik_sources_saml.usersamlsourceconnection&#x60; - User SAML Source Connection * &#x60;authentik_stages_authenticator_duo.authenticatorduostage&#x60; - Duo Authenticator Setup Stage * &#x60;authentik_stages_authenticator_duo.duodevice&#x60; - Duo Device * &#x60;authentik_stages_authenticator_sms.authenticatorsmsstage&#x60; - SMS Authenticator Setup Stage * &#x60;authentik_stages_authenticator_sms.smsdevice&#x60; - SMS Device * &#x60;authentik_stages_authenticator_static.authenticatorstaticstage&#x60; - Static Authenticator Stage * &#x60;authentik_stages_authenticator_static.staticdevice&#x60; - Static Device * &#x60;authentik_stages_authenticator_totp.authenticatortotpstage&#x60; - TOTP Authenticator Setup Stage * &#x60;authentik_stages_authenticator_totp.totpdevice&#x60; - TOTP Device * &#x60;authentik_stages_authenticator_validate.authenticatorvalidatestage&#x60; - Authenticator Validation Stage * &#x60;authentik_stages_authenticator_webauthn.authenticatewebauthnstage&#x60; - WebAuthn Authenticator Setup Stage * &#x60;authentik_stages_authenticator_webauthn.webauthndevice&#x60; - WebAuthn Device * &#x60;authentik_stages_captcha.captchastage&#x60; - Captcha Stage * &#x60;authentik_stages_consent.consentstage&#x60; - Consent Stage * &#x60;authentik_stages_consent.userconsent&#x60; - User Consent * &#x60;authentik_stages_deny.denystage&#x60; - Deny Stage * &#x60;authentik_stages_dummy.dummystage&#x60; - Dummy Stage * &#x60;authentik_stages_email.emailstage&#x60; - Email Stage * &#x60;authentik_stages_identification.identificationstage&#x60; - Identification Stage * &#x60;authentik_stages_invitation.invitationstage&#x60; - Invitation Stage * &#x60;authentik_stages_invitation.invitation&#x60; - Invitation * &#x60;authentik_stages_password.passwordstage&#x60; - Password Stage * &#x60;authentik_stages_prompt.prompt&#x60; - Prompt * &#x60;authentik_stages_prompt.promptstage&#x60; - Prompt Stage * &#x60;authentik_stages_user_delete.userdeletestage&#x60; - User Delete Stage * &#x60;authentik_stages_user_login.userloginstage&#x60; - User Login Stage * &#x60;authentik_stages_user_logout.userlogoutstage&#x60; - User Logout Stage * &#x60;authentik_stages_user_write.userwritestage&#x60; - User Write Stage * &#x60;authentik_tenants.tenant&#x60; - Tenant * &#x60;authentik_blueprints.blueprintinstance&#x60; - Blueprint Instance * &#x60;authentik_core.group&#x60; - Group * &#x60;authentik_core.user&#x60; - User * &#x60;authentik_core.application&#x60; - Application * &#x60;authentik_core.token&#x60; - Token * &#x60;authentik_enterprise.license&#x60; - License
     * @param objectPk  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun rbacPermissionsAssignedByUsersListRequestConfig(model: Model_rbacPermissionsAssignedByUsersList, objectPk: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("model", listOf(model.toString()))
                if (objectPk != null) {
                    put("object_pk", listOf(objectPk.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rbac/permissions/assigned_by_users/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Unassign permission(s) to user. When &#x60;object_pk&#x60; is set, the permissions are only assigned to the specific object, otherwise they are assigned globally.
     * @param id A unique integer value identifying this User.
     * @param patchedPermissionAssignRequest  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacPermissionsAssignedByUsersUnassignPartialUpdate(id: kotlin.Int, patchedPermissionAssignRequest: PatchedPermissionAssignRequest? = null) : Unit {
        val localVarResponse = rbacPermissionsAssignedByUsersUnassignPartialUpdateWithHttpInfo(id = id, patchedPermissionAssignRequest = patchedPermissionAssignRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Unassign permission(s) to user. When &#x60;object_pk&#x60; is set, the permissions are only assigned to the specific object, otherwise they are assigned globally.
     * @param id A unique integer value identifying this User.
     * @param patchedPermissionAssignRequest  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacPermissionsAssignedByUsersUnassignPartialUpdateWithHttpInfo(id: kotlin.Int, patchedPermissionAssignRequest: PatchedPermissionAssignRequest?) : ApiResponse<Unit?> {
        val localVariableConfig = rbacPermissionsAssignedByUsersUnassignPartialUpdateRequestConfig(id = id, patchedPermissionAssignRequest = patchedPermissionAssignRequest)

        return request<PatchedPermissionAssignRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacPermissionsAssignedByUsersUnassignPartialUpdate
     *
     * @param id A unique integer value identifying this User.
     * @param patchedPermissionAssignRequest  (optional)
     * @return RequestConfig
     */
    fun rbacPermissionsAssignedByUsersUnassignPartialUpdateRequestConfig(id: kotlin.Int, patchedPermissionAssignRequest: PatchedPermissionAssignRequest?) : RequestConfig<PatchedPermissionAssignRequest> {
        val localVariableBody = patchedPermissionAssignRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/rbac/permissions/assigned_by_users/{id}/unassign/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Read-only list of all permissions, filterable by model and app
     * @param codename  (optional)
     * @param contentTypeAppLabel  (optional)
     * @param contentTypeModel  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param role  (optional)
     * @param search A search term. (optional)
     * @param user  (optional)
     * @return PaginatedPermissionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacPermissionsList(codename: kotlin.String? = null, contentTypeAppLabel: kotlin.String? = null, contentTypeModel: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, role: kotlin.String? = null, search: kotlin.String? = null, user: kotlin.Int? = null) : PaginatedPermissionList {
        val localVarResponse = rbacPermissionsListWithHttpInfo(codename = codename, contentTypeAppLabel = contentTypeAppLabel, contentTypeModel = contentTypeModel, ordering = ordering, page = page, pageSize = pageSize, role = role, search = search, user = user)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPermissionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Read-only list of all permissions, filterable by model and app
     * @param codename  (optional)
     * @param contentTypeAppLabel  (optional)
     * @param contentTypeModel  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param role  (optional)
     * @param search A search term. (optional)
     * @param user  (optional)
     * @return ApiResponse<PaginatedPermissionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacPermissionsListWithHttpInfo(codename: kotlin.String?, contentTypeAppLabel: kotlin.String?, contentTypeModel: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, role: kotlin.String?, search: kotlin.String?, user: kotlin.Int?) : ApiResponse<PaginatedPermissionList?> {
        val localVariableConfig = rbacPermissionsListRequestConfig(codename = codename, contentTypeAppLabel = contentTypeAppLabel, contentTypeModel = contentTypeModel, ordering = ordering, page = page, pageSize = pageSize, role = role, search = search, user = user)

        return request<Unit, PaginatedPermissionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacPermissionsList
     *
     * @param codename  (optional)
     * @param contentTypeAppLabel  (optional)
     * @param contentTypeModel  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param role  (optional)
     * @param search A search term. (optional)
     * @param user  (optional)
     * @return RequestConfig
     */
    fun rbacPermissionsListRequestConfig(codename: kotlin.String?, contentTypeAppLabel: kotlin.String?, contentTypeModel: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, role: kotlin.String?, search: kotlin.String?, user: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (codename != null) {
                    put("codename", listOf(codename.toString()))
                }
                if (contentTypeAppLabel != null) {
                    put("content_type__app_label", listOf(contentTypeAppLabel.toString()))
                }
                if (contentTypeModel != null) {
                    put("content_type__model", listOf(contentTypeModel.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (role != null) {
                    put("role", listOf(role.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rbac/permissions/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Read-only list of all permissions, filterable by model and app
     * @param id A unique integer value identifying this permission.
     * @return Permission
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacPermissionsRetrieve(id: kotlin.Int) : Permission {
        val localVarResponse = rbacPermissionsRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Permission
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Read-only list of all permissions, filterable by model and app
     * @param id A unique integer value identifying this permission.
     * @return ApiResponse<Permission?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacPermissionsRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<Permission?> {
        val localVariableConfig = rbacPermissionsRetrieveRequestConfig(id = id)

        return request<Unit, Permission>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacPermissionsRetrieve
     *
     * @param id A unique integer value identifying this permission.
     * @return RequestConfig
     */
    fun rbacPermissionsRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rbac/permissions/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a role&#39;s assigned object permissions
     * @param uuid 
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedExtraRoleObjectPermissionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacPermissionsRolesList(uuid: java.util.UUID, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedExtraRoleObjectPermissionList {
        val localVarResponse = rbacPermissionsRolesListWithHttpInfo(uuid = uuid, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedExtraRoleObjectPermissionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a role&#39;s assigned object permissions
     * @param uuid 
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedExtraRoleObjectPermissionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacPermissionsRolesListWithHttpInfo(uuid: java.util.UUID, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedExtraRoleObjectPermissionList?> {
        val localVariableConfig = rbacPermissionsRolesListRequestConfig(uuid = uuid, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedExtraRoleObjectPermissionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacPermissionsRolesList
     *
     * @param uuid 
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun rbacPermissionsRolesListRequestConfig(uuid: java.util.UUID, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                put("uuid", listOf(uuid.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rbac/permissions/roles/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a users&#39;s assigned object permissions
     * @param userId 
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedExtraUserObjectPermissionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacPermissionsUsersList(userId: kotlin.Int, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedExtraUserObjectPermissionList {
        val localVarResponse = rbacPermissionsUsersListWithHttpInfo(userId = userId, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedExtraUserObjectPermissionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a users&#39;s assigned object permissions
     * @param userId 
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedExtraUserObjectPermissionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacPermissionsUsersListWithHttpInfo(userId: kotlin.Int, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedExtraUserObjectPermissionList?> {
        val localVariableConfig = rbacPermissionsUsersListRequestConfig(userId = userId, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedExtraUserObjectPermissionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacPermissionsUsersList
     *
     * @param userId 
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun rbacPermissionsUsersListRequestConfig(userId: kotlin.Int, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                put("user_id", listOf(userId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rbac/permissions/users/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Role viewset
     * @param roleRequest 
     * @return Role
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacRolesCreate(roleRequest: RoleRequest) : Role {
        val localVarResponse = rbacRolesCreateWithHttpInfo(roleRequest = roleRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Role
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Role viewset
     * @param roleRequest 
     * @return ApiResponse<Role?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacRolesCreateWithHttpInfo(roleRequest: RoleRequest) : ApiResponse<Role?> {
        val localVariableConfig = rbacRolesCreateRequestConfig(roleRequest = roleRequest)

        return request<RoleRequest, Role>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacRolesCreate
     *
     * @param roleRequest 
     * @return RequestConfig
     */
    fun rbacRolesCreateRequestConfig(roleRequest: RoleRequest) : RequestConfig<RoleRequest> {
        val localVariableBody = roleRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rbac/roles/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Role viewset
     * @param uuid A UUID string identifying this Role.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacRolesDestroy(uuid: java.util.UUID) : Unit {
        val localVarResponse = rbacRolesDestroyWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Role viewset
     * @param uuid A UUID string identifying this Role.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacRolesDestroyWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = rbacRolesDestroyRequestConfig(uuid = uuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacRolesDestroy
     *
     * @param uuid A UUID string identifying this Role.
     * @return RequestConfig
     */
    fun rbacRolesDestroyRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/rbac/roles/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Role viewset
     * @param groupName  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedRoleList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacRolesList(groupName: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedRoleList {
        val localVarResponse = rbacRolesListWithHttpInfo(groupName = groupName, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedRoleList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Role viewset
     * @param groupName  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedRoleList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacRolesListWithHttpInfo(groupName: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedRoleList?> {
        val localVariableConfig = rbacRolesListRequestConfig(groupName = groupName, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedRoleList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacRolesList
     *
     * @param groupName  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun rbacRolesListRequestConfig(groupName: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (groupName != null) {
                    put("group__name", listOf(groupName.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rbac/roles/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Role viewset
     * @param uuid A UUID string identifying this Role.
     * @param patchedRoleRequest  (optional)
     * @return Role
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacRolesPartialUpdate(uuid: java.util.UUID, patchedRoleRequest: PatchedRoleRequest? = null) : Role {
        val localVarResponse = rbacRolesPartialUpdateWithHttpInfo(uuid = uuid, patchedRoleRequest = patchedRoleRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Role
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Role viewset
     * @param uuid A UUID string identifying this Role.
     * @param patchedRoleRequest  (optional)
     * @return ApiResponse<Role?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacRolesPartialUpdateWithHttpInfo(uuid: java.util.UUID, patchedRoleRequest: PatchedRoleRequest?) : ApiResponse<Role?> {
        val localVariableConfig = rbacRolesPartialUpdateRequestConfig(uuid = uuid, patchedRoleRequest = patchedRoleRequest)

        return request<PatchedRoleRequest, Role>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacRolesPartialUpdate
     *
     * @param uuid A UUID string identifying this Role.
     * @param patchedRoleRequest  (optional)
     * @return RequestConfig
     */
    fun rbacRolesPartialUpdateRequestConfig(uuid: java.util.UUID, patchedRoleRequest: PatchedRoleRequest?) : RequestConfig<PatchedRoleRequest> {
        val localVariableBody = patchedRoleRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/rbac/roles/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Role viewset
     * @param uuid A UUID string identifying this Role.
     * @return Role
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacRolesRetrieve(uuid: java.util.UUID) : Role {
        val localVarResponse = rbacRolesRetrieveWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Role
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Role viewset
     * @param uuid A UUID string identifying this Role.
     * @return ApiResponse<Role?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacRolesRetrieveWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Role?> {
        val localVariableConfig = rbacRolesRetrieveRequestConfig(uuid = uuid)

        return request<Unit, Role>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacRolesRetrieve
     *
     * @param uuid A UUID string identifying this Role.
     * @return RequestConfig
     */
    fun rbacRolesRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rbac/roles/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Role viewset
     * @param uuid A UUID string identifying this Role.
     * @param roleRequest 
     * @return Role
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacRolesUpdate(uuid: java.util.UUID, roleRequest: RoleRequest) : Role {
        val localVarResponse = rbacRolesUpdateWithHttpInfo(uuid = uuid, roleRequest = roleRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Role
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Role viewset
     * @param uuid A UUID string identifying this Role.
     * @param roleRequest 
     * @return ApiResponse<Role?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacRolesUpdateWithHttpInfo(uuid: java.util.UUID, roleRequest: RoleRequest) : ApiResponse<Role?> {
        val localVariableConfig = rbacRolesUpdateRequestConfig(uuid = uuid, roleRequest = roleRequest)

        return request<RoleRequest, Role>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacRolesUpdate
     *
     * @param uuid A UUID string identifying this Role.
     * @param roleRequest 
     * @return RequestConfig
     */
    fun rbacRolesUpdateRequestConfig(uuid: java.util.UUID, roleRequest: RoleRequest) : RequestConfig<RoleRequest> {
        val localVariableBody = roleRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rbac/roles/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Role.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rbacRolesUsedByList(uuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = rbacRolesUsedByListWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Role.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rbacRolesUsedByListWithHttpInfo(uuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = rbacRolesUsedByListRequestConfig(uuid = uuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rbacRolesUsedByList
     *
     * @param uuid A UUID string identifying this Role.
     * @return RequestConfig
     */
    fun rbacRolesUsedByListRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rbac/roles/{uuid}/used_by/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
