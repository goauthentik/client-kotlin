/**
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2023.10.3
 * Contact: hello@goauthentik.io
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.Application
import io.goauthentik.api.models.ApplicationRequest
import io.goauthentik.api.models.AuthenticatedSession
import io.goauthentik.api.models.Coordinate
import io.goauthentik.api.models.CurrentTenant
import io.goauthentik.api.models.FilePathRequest
import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.Group
import io.goauthentik.api.models.GroupRequest
import io.goauthentik.api.models.Link
import io.goauthentik.api.models.PaginatedApplicationList
import io.goauthentik.api.models.PaginatedAuthenticatedSessionList
import io.goauthentik.api.models.PaginatedGroupList
import io.goauthentik.api.models.PaginatedTenantList
import io.goauthentik.api.models.PaginatedTokenList
import io.goauthentik.api.models.PaginatedUserConsentList
import io.goauthentik.api.models.PaginatedUserList
import io.goauthentik.api.models.PatchedApplicationRequest
import io.goauthentik.api.models.PatchedGroupRequest
import io.goauthentik.api.models.PatchedTenantRequest
import io.goauthentik.api.models.PatchedTokenRequest
import io.goauthentik.api.models.PatchedUserRequest
import io.goauthentik.api.models.PolicyTestResult
import io.goauthentik.api.models.SessionUser
import io.goauthentik.api.models.Tenant
import io.goauthentik.api.models.TenantRequest
import io.goauthentik.api.models.Token
import io.goauthentik.api.models.TokenRequest
import io.goauthentik.api.models.TokenSetKeyRequest
import io.goauthentik.api.models.TokenView
import io.goauthentik.api.models.TransactionApplicationRequest
import io.goauthentik.api.models.TransactionApplicationResponse
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.User
import io.goauthentik.api.models.UserAccountRequest
import io.goauthentik.api.models.UserConsent
import io.goauthentik.api.models.UserMetrics
import io.goauthentik.api.models.UserPasswordSetRequest
import io.goauthentik.api.models.UserPath
import io.goauthentik.api.models.UserRequest
import io.goauthentik.api.models.UserServiceAccountRequest
import io.goauthentik.api.models.UserServiceAccountResponse
import io.goauthentik.api.models.ValidationError

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class CoreApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * Check access to a single application by slug
     * @param slug 
     * @param forUser  (optional)
     * @return PolicyTestResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreApplicationsCheckAccessRetrieve(slug: kotlin.String, forUser: kotlin.Int? = null) : PolicyTestResult {
        val localVarResponse = coreApplicationsCheckAccessRetrieveWithHttpInfo(slug = slug, forUser = forUser)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyTestResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Check access to a single application by slug
     * @param slug 
     * @param forUser  (optional)
     * @return ApiResponse<PolicyTestResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreApplicationsCheckAccessRetrieveWithHttpInfo(slug: kotlin.String, forUser: kotlin.Int?) : ApiResponse<PolicyTestResult?> {
        val localVariableConfig = coreApplicationsCheckAccessRetrieveRequestConfig(slug = slug, forUser = forUser)

        return request<Unit, PolicyTestResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreApplicationsCheckAccessRetrieve
     *
     * @param slug 
     * @param forUser  (optional)
     * @return RequestConfig
     */
    fun coreApplicationsCheckAccessRetrieveRequestConfig(slug: kotlin.String, forUser: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (forUser != null) {
                    put("for_user", listOf(forUser.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/applications/{slug}/check_access/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Application Viewset
     * @param applicationRequest 
     * @return Application
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreApplicationsCreate(applicationRequest: ApplicationRequest) : Application {
        val localVarResponse = coreApplicationsCreateWithHttpInfo(applicationRequest = applicationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Application
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Application Viewset
     * @param applicationRequest 
     * @return ApiResponse<Application?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreApplicationsCreateWithHttpInfo(applicationRequest: ApplicationRequest) : ApiResponse<Application?> {
        val localVariableConfig = coreApplicationsCreateRequestConfig(applicationRequest = applicationRequest)

        return request<ApplicationRequest, Application>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreApplicationsCreate
     *
     * @param applicationRequest 
     * @return RequestConfig
     */
    fun coreApplicationsCreateRequestConfig(applicationRequest: ApplicationRequest) : RequestConfig<ApplicationRequest> {
        val localVariableBody = applicationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/applications/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Application Viewset
     * @param slug 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreApplicationsDestroy(slug: kotlin.String) : Unit {
        val localVarResponse = coreApplicationsDestroyWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Application Viewset
     * @param slug 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreApplicationsDestroyWithHttpInfo(slug: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = coreApplicationsDestroyRequestConfig(slug = slug)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreApplicationsDestroy
     *
     * @param slug 
     * @return RequestConfig
     */
    fun coreApplicationsDestroyRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/core/applications/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Custom list method that checks Policy based access instead of guardian
     * @param group  (optional)
     * @param metaDescription  (optional)
     * @param metaLaunchUrl  (optional)
     * @param metaPublisher  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @param superuserFullList  (optional)
     * @return PaginatedApplicationList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreApplicationsList(group: kotlin.String? = null, metaDescription: kotlin.String? = null, metaLaunchUrl: kotlin.String? = null, metaPublisher: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, slug: kotlin.String? = null, superuserFullList: kotlin.Boolean? = null) : PaginatedApplicationList {
        val localVarResponse = coreApplicationsListWithHttpInfo(group = group, metaDescription = metaDescription, metaLaunchUrl = metaLaunchUrl, metaPublisher = metaPublisher, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, slug = slug, superuserFullList = superuserFullList)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedApplicationList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Custom list method that checks Policy based access instead of guardian
     * @param group  (optional)
     * @param metaDescription  (optional)
     * @param metaLaunchUrl  (optional)
     * @param metaPublisher  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @param superuserFullList  (optional)
     * @return ApiResponse<PaginatedApplicationList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreApplicationsListWithHttpInfo(group: kotlin.String?, metaDescription: kotlin.String?, metaLaunchUrl: kotlin.String?, metaPublisher: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, slug: kotlin.String?, superuserFullList: kotlin.Boolean?) : ApiResponse<PaginatedApplicationList?> {
        val localVariableConfig = coreApplicationsListRequestConfig(group = group, metaDescription = metaDescription, metaLaunchUrl = metaLaunchUrl, metaPublisher = metaPublisher, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, slug = slug, superuserFullList = superuserFullList)

        return request<Unit, PaginatedApplicationList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreApplicationsList
     *
     * @param group  (optional)
     * @param metaDescription  (optional)
     * @param metaLaunchUrl  (optional)
     * @param metaPublisher  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @param superuserFullList  (optional)
     * @return RequestConfig
     */
    fun coreApplicationsListRequestConfig(group: kotlin.String?, metaDescription: kotlin.String?, metaLaunchUrl: kotlin.String?, metaPublisher: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, slug: kotlin.String?, superuserFullList: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (group != null) {
                    put("group", listOf(group.toString()))
                }
                if (metaDescription != null) {
                    put("meta_description", listOf(metaDescription.toString()))
                }
                if (metaLaunchUrl != null) {
                    put("meta_launch_url", listOf(metaLaunchUrl.toString()))
                }
                if (metaPublisher != null) {
                    put("meta_publisher", listOf(metaPublisher.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (slug != null) {
                    put("slug", listOf(slug.toString()))
                }
                if (superuserFullList != null) {
                    put("superuser_full_list", listOf(superuserFullList.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/applications/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Metrics for application logins
     * @param slug 
     * @return kotlin.collections.List<Coordinate>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreApplicationsMetricsList(slug: kotlin.String) : kotlin.collections.List<Coordinate> {
        val localVarResponse = coreApplicationsMetricsListWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Coordinate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Metrics for application logins
     * @param slug 
     * @return ApiResponse<kotlin.collections.List<Coordinate>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreApplicationsMetricsListWithHttpInfo(slug: kotlin.String) : ApiResponse<kotlin.collections.List<Coordinate>?> {
        val localVariableConfig = coreApplicationsMetricsListRequestConfig(slug = slug)

        return request<Unit, kotlin.collections.List<Coordinate>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreApplicationsMetricsList
     *
     * @param slug 
     * @return RequestConfig
     */
    fun coreApplicationsMetricsListRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/applications/{slug}/metrics/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Application Viewset
     * @param slug 
     * @param patchedApplicationRequest  (optional)
     * @return Application
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreApplicationsPartialUpdate(slug: kotlin.String, patchedApplicationRequest: PatchedApplicationRequest? = null) : Application {
        val localVarResponse = coreApplicationsPartialUpdateWithHttpInfo(slug = slug, patchedApplicationRequest = patchedApplicationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Application
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Application Viewset
     * @param slug 
     * @param patchedApplicationRequest  (optional)
     * @return ApiResponse<Application?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreApplicationsPartialUpdateWithHttpInfo(slug: kotlin.String, patchedApplicationRequest: PatchedApplicationRequest?) : ApiResponse<Application?> {
        val localVariableConfig = coreApplicationsPartialUpdateRequestConfig(slug = slug, patchedApplicationRequest = patchedApplicationRequest)

        return request<PatchedApplicationRequest, Application>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreApplicationsPartialUpdate
     *
     * @param slug 
     * @param patchedApplicationRequest  (optional)
     * @return RequestConfig
     */
    fun coreApplicationsPartialUpdateRequestConfig(slug: kotlin.String, patchedApplicationRequest: PatchedApplicationRequest?) : RequestConfig<PatchedApplicationRequest> {
        val localVariableBody = patchedApplicationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/core/applications/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Application Viewset
     * @param slug 
     * @return Application
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreApplicationsRetrieve(slug: kotlin.String) : Application {
        val localVarResponse = coreApplicationsRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Application
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Application Viewset
     * @param slug 
     * @return ApiResponse<Application?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreApplicationsRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<Application?> {
        val localVariableConfig = coreApplicationsRetrieveRequestConfig(slug = slug)

        return request<Unit, Application>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreApplicationsRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun coreApplicationsRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/applications/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set application icon
     * @param slug 
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreApplicationsSetIconCreate(slug: kotlin.String, file: java.io.File? = null, clear: kotlin.Boolean? = false) : Unit {
        val localVarResponse = coreApplicationsSetIconCreateWithHttpInfo(slug = slug, file = file, clear = clear)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set application icon
     * @param slug 
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreApplicationsSetIconCreateWithHttpInfo(slug: kotlin.String, file: java.io.File?, clear: kotlin.Boolean?) : ApiResponse<Unit?> {
        val localVariableConfig = coreApplicationsSetIconCreateRequestConfig(slug = slug, file = file, clear = clear)

        return request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreApplicationsSetIconCreate
     *
     * @param slug 
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return RequestConfig
     */
    fun coreApplicationsSetIconCreateRequestConfig(slug: kotlin.String, file: java.io.File?, clear: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "clear" to PartConfig(body = clear, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/applications/{slug}/set_icon/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set application icon (as URL)
     * @param slug 
     * @param filePathRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreApplicationsSetIconUrlCreate(slug: kotlin.String, filePathRequest: FilePathRequest) : Unit {
        val localVarResponse = coreApplicationsSetIconUrlCreateWithHttpInfo(slug = slug, filePathRequest = filePathRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set application icon (as URL)
     * @param slug 
     * @param filePathRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreApplicationsSetIconUrlCreateWithHttpInfo(slug: kotlin.String, filePathRequest: FilePathRequest) : ApiResponse<Unit?> {
        val localVariableConfig = coreApplicationsSetIconUrlCreateRequestConfig(slug = slug, filePathRequest = filePathRequest)

        return request<FilePathRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreApplicationsSetIconUrlCreate
     *
     * @param slug 
     * @param filePathRequest 
     * @return RequestConfig
     */
    fun coreApplicationsSetIconUrlCreateRequestConfig(slug: kotlin.String, filePathRequest: FilePathRequest) : RequestConfig<FilePathRequest> {
        val localVariableBody = filePathRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/applications/{slug}/set_icon_url/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Application Viewset
     * @param slug 
     * @param applicationRequest 
     * @return Application
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreApplicationsUpdate(slug: kotlin.String, applicationRequest: ApplicationRequest) : Application {
        val localVarResponse = coreApplicationsUpdateWithHttpInfo(slug = slug, applicationRequest = applicationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Application
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Application Viewset
     * @param slug 
     * @param applicationRequest 
     * @return ApiResponse<Application?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreApplicationsUpdateWithHttpInfo(slug: kotlin.String, applicationRequest: ApplicationRequest) : ApiResponse<Application?> {
        val localVariableConfig = coreApplicationsUpdateRequestConfig(slug = slug, applicationRequest = applicationRequest)

        return request<ApplicationRequest, Application>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreApplicationsUpdate
     *
     * @param slug 
     * @param applicationRequest 
     * @return RequestConfig
     */
    fun coreApplicationsUpdateRequestConfig(slug: kotlin.String, applicationRequest: ApplicationRequest) : RequestConfig<ApplicationRequest> {
        val localVariableBody = applicationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/core/applications/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreApplicationsUsedByList(slug: kotlin.String) : kotlin.collections.List<UsedBy> {
        val localVarResponse = coreApplicationsUsedByListWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreApplicationsUsedByListWithHttpInfo(slug: kotlin.String) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = coreApplicationsUsedByListRequestConfig(slug = slug)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreApplicationsUsedByList
     *
     * @param slug 
     * @return RequestConfig
     */
    fun coreApplicationsUsedByListRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/applications/{slug}/used_by/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatedSession Viewset
     * @param uuid A UUID string identifying this Authenticated Session.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreAuthenticatedSessionsDestroy(uuid: java.util.UUID) : Unit {
        val localVarResponse = coreAuthenticatedSessionsDestroyWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatedSession Viewset
     * @param uuid A UUID string identifying this Authenticated Session.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreAuthenticatedSessionsDestroyWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = coreAuthenticatedSessionsDestroyRequestConfig(uuid = uuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreAuthenticatedSessionsDestroy
     *
     * @param uuid A UUID string identifying this Authenticated Session.
     * @return RequestConfig
     */
    fun coreAuthenticatedSessionsDestroyRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/core/authenticated_sessions/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatedSession Viewset
     * @param lastIp  (optional)
     * @param lastUserAgent  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param userUsername  (optional)
     * @return PaginatedAuthenticatedSessionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreAuthenticatedSessionsList(lastIp: kotlin.String? = null, lastUserAgent: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, userUsername: kotlin.String? = null) : PaginatedAuthenticatedSessionList {
        val localVarResponse = coreAuthenticatedSessionsListWithHttpInfo(lastIp = lastIp, lastUserAgent = lastUserAgent, ordering = ordering, page = page, pageSize = pageSize, search = search, userUsername = userUsername)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAuthenticatedSessionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatedSession Viewset
     * @param lastIp  (optional)
     * @param lastUserAgent  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param userUsername  (optional)
     * @return ApiResponse<PaginatedAuthenticatedSessionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreAuthenticatedSessionsListWithHttpInfo(lastIp: kotlin.String?, lastUserAgent: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, userUsername: kotlin.String?) : ApiResponse<PaginatedAuthenticatedSessionList?> {
        val localVariableConfig = coreAuthenticatedSessionsListRequestConfig(lastIp = lastIp, lastUserAgent = lastUserAgent, ordering = ordering, page = page, pageSize = pageSize, search = search, userUsername = userUsername)

        return request<Unit, PaginatedAuthenticatedSessionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreAuthenticatedSessionsList
     *
     * @param lastIp  (optional)
     * @param lastUserAgent  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param userUsername  (optional)
     * @return RequestConfig
     */
    fun coreAuthenticatedSessionsListRequestConfig(lastIp: kotlin.String?, lastUserAgent: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, userUsername: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (lastIp != null) {
                    put("last_ip", listOf(lastIp.toString()))
                }
                if (lastUserAgent != null) {
                    put("last_user_agent", listOf(lastUserAgent.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (userUsername != null) {
                    put("user__username", listOf(userUsername.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/authenticated_sessions/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatedSession Viewset
     * @param uuid A UUID string identifying this Authenticated Session.
     * @return AuthenticatedSession
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreAuthenticatedSessionsRetrieve(uuid: java.util.UUID) : AuthenticatedSession {
        val localVarResponse = coreAuthenticatedSessionsRetrieveWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatedSession
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatedSession Viewset
     * @param uuid A UUID string identifying this Authenticated Session.
     * @return ApiResponse<AuthenticatedSession?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreAuthenticatedSessionsRetrieveWithHttpInfo(uuid: java.util.UUID) : ApiResponse<AuthenticatedSession?> {
        val localVariableConfig = coreAuthenticatedSessionsRetrieveRequestConfig(uuid = uuid)

        return request<Unit, AuthenticatedSession>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreAuthenticatedSessionsRetrieve
     *
     * @param uuid A UUID string identifying this Authenticated Session.
     * @return RequestConfig
     */
    fun coreAuthenticatedSessionsRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/authenticated_sessions/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Authenticated Session.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreAuthenticatedSessionsUsedByList(uuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = coreAuthenticatedSessionsUsedByListWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Authenticated Session.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreAuthenticatedSessionsUsedByListWithHttpInfo(uuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = coreAuthenticatedSessionsUsedByListRequestConfig(uuid = uuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreAuthenticatedSessionsUsedByList
     *
     * @param uuid A UUID string identifying this Authenticated Session.
     * @return RequestConfig
     */
    fun coreAuthenticatedSessionsUsedByListRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/authenticated_sessions/{uuid}/used_by/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Add user to group
     * @param groupUuid A UUID string identifying this Group.
     * @param userAccountRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreGroupsAddUserCreate(groupUuid: java.util.UUID, userAccountRequest: UserAccountRequest) : Unit {
        val localVarResponse = coreGroupsAddUserCreateWithHttpInfo(groupUuid = groupUuid, userAccountRequest = userAccountRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Add user to group
     * @param groupUuid A UUID string identifying this Group.
     * @param userAccountRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreGroupsAddUserCreateWithHttpInfo(groupUuid: java.util.UUID, userAccountRequest: UserAccountRequest) : ApiResponse<Unit?> {
        val localVariableConfig = coreGroupsAddUserCreateRequestConfig(groupUuid = groupUuid, userAccountRequest = userAccountRequest)

        return request<UserAccountRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreGroupsAddUserCreate
     *
     * @param groupUuid A UUID string identifying this Group.
     * @param userAccountRequest 
     * @return RequestConfig
     */
    fun coreGroupsAddUserCreateRequestConfig(groupUuid: java.util.UUID, userAccountRequest: UserAccountRequest) : RequestConfig<UserAccountRequest> {
        val localVariableBody = userAccountRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/groups/{group_uuid}/add_user/".replace("{"+"group_uuid"+"}", encodeURIComponent(groupUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Group Viewset
     * @param groupRequest 
     * @return Group
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreGroupsCreate(groupRequest: GroupRequest) : Group {
        val localVarResponse = coreGroupsCreateWithHttpInfo(groupRequest = groupRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Group
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Group Viewset
     * @param groupRequest 
     * @return ApiResponse<Group?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreGroupsCreateWithHttpInfo(groupRequest: GroupRequest) : ApiResponse<Group?> {
        val localVariableConfig = coreGroupsCreateRequestConfig(groupRequest = groupRequest)

        return request<GroupRequest, Group>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreGroupsCreate
     *
     * @param groupRequest 
     * @return RequestConfig
     */
    fun coreGroupsCreateRequestConfig(groupRequest: GroupRequest) : RequestConfig<GroupRequest> {
        val localVariableBody = groupRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/groups/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Group Viewset
     * @param groupUuid A UUID string identifying this Group.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreGroupsDestroy(groupUuid: java.util.UUID) : Unit {
        val localVarResponse = coreGroupsDestroyWithHttpInfo(groupUuid = groupUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Group Viewset
     * @param groupUuid A UUID string identifying this Group.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreGroupsDestroyWithHttpInfo(groupUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = coreGroupsDestroyRequestConfig(groupUuid = groupUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreGroupsDestroy
     *
     * @param groupUuid A UUID string identifying this Group.
     * @return RequestConfig
     */
    fun coreGroupsDestroyRequestConfig(groupUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/core/groups/{group_uuid}/".replace("{"+"group_uuid"+"}", encodeURIComponent(groupUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Group Viewset
     * @param attributes Attributes (optional)
     * @param isSuperuser  (optional)
     * @param membersByPk  (optional)
     * @param membersByUsername Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedGroupList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreGroupsList(attributes: kotlin.String? = null, isSuperuser: kotlin.Boolean? = null, membersByPk: kotlin.collections.List<kotlin.Int>? = null, membersByUsername: kotlin.collections.List<kotlin.String>? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedGroupList {
        val localVarResponse = coreGroupsListWithHttpInfo(attributes = attributes, isSuperuser = isSuperuser, membersByPk = membersByPk, membersByUsername = membersByUsername, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedGroupList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Group Viewset
     * @param attributes Attributes (optional)
     * @param isSuperuser  (optional)
     * @param membersByPk  (optional)
     * @param membersByUsername Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedGroupList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreGroupsListWithHttpInfo(attributes: kotlin.String?, isSuperuser: kotlin.Boolean?, membersByPk: kotlin.collections.List<kotlin.Int>?, membersByUsername: kotlin.collections.List<kotlin.String>?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedGroupList?> {
        val localVariableConfig = coreGroupsListRequestConfig(attributes = attributes, isSuperuser = isSuperuser, membersByPk = membersByPk, membersByUsername = membersByUsername, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedGroupList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreGroupsList
     *
     * @param attributes Attributes (optional)
     * @param isSuperuser  (optional)
     * @param membersByPk  (optional)
     * @param membersByUsername Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only. (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun coreGroupsListRequestConfig(attributes: kotlin.String?, isSuperuser: kotlin.Boolean?, membersByPk: kotlin.collections.List<kotlin.Int>?, membersByUsername: kotlin.collections.List<kotlin.String>?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (attributes != null) {
                    put("attributes", listOf(attributes.toString()))
                }
                if (isSuperuser != null) {
                    put("is_superuser", listOf(isSuperuser.toString()))
                }
                if (membersByPk != null) {
                    put("members_by_pk", toMultiValue(membersByPk.toList(), "multi"))
                }
                if (membersByUsername != null) {
                    put("members_by_username", toMultiValue(membersByUsername.toList(), "multi"))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/groups/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Group Viewset
     * @param groupUuid A UUID string identifying this Group.
     * @param patchedGroupRequest  (optional)
     * @return Group
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreGroupsPartialUpdate(groupUuid: java.util.UUID, patchedGroupRequest: PatchedGroupRequest? = null) : Group {
        val localVarResponse = coreGroupsPartialUpdateWithHttpInfo(groupUuid = groupUuid, patchedGroupRequest = patchedGroupRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Group
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Group Viewset
     * @param groupUuid A UUID string identifying this Group.
     * @param patchedGroupRequest  (optional)
     * @return ApiResponse<Group?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreGroupsPartialUpdateWithHttpInfo(groupUuid: java.util.UUID, patchedGroupRequest: PatchedGroupRequest?) : ApiResponse<Group?> {
        val localVariableConfig = coreGroupsPartialUpdateRequestConfig(groupUuid = groupUuid, patchedGroupRequest = patchedGroupRequest)

        return request<PatchedGroupRequest, Group>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreGroupsPartialUpdate
     *
     * @param groupUuid A UUID string identifying this Group.
     * @param patchedGroupRequest  (optional)
     * @return RequestConfig
     */
    fun coreGroupsPartialUpdateRequestConfig(groupUuid: java.util.UUID, patchedGroupRequest: PatchedGroupRequest?) : RequestConfig<PatchedGroupRequest> {
        val localVariableBody = patchedGroupRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/core/groups/{group_uuid}/".replace("{"+"group_uuid"+"}", encodeURIComponent(groupUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Add user to group
     * @param groupUuid A UUID string identifying this Group.
     * @param userAccountRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreGroupsRemoveUserCreate(groupUuid: java.util.UUID, userAccountRequest: UserAccountRequest) : Unit {
        val localVarResponse = coreGroupsRemoveUserCreateWithHttpInfo(groupUuid = groupUuid, userAccountRequest = userAccountRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Add user to group
     * @param groupUuid A UUID string identifying this Group.
     * @param userAccountRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreGroupsRemoveUserCreateWithHttpInfo(groupUuid: java.util.UUID, userAccountRequest: UserAccountRequest) : ApiResponse<Unit?> {
        val localVariableConfig = coreGroupsRemoveUserCreateRequestConfig(groupUuid = groupUuid, userAccountRequest = userAccountRequest)

        return request<UserAccountRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreGroupsRemoveUserCreate
     *
     * @param groupUuid A UUID string identifying this Group.
     * @param userAccountRequest 
     * @return RequestConfig
     */
    fun coreGroupsRemoveUserCreateRequestConfig(groupUuid: java.util.UUID, userAccountRequest: UserAccountRequest) : RequestConfig<UserAccountRequest> {
        val localVariableBody = userAccountRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/groups/{group_uuid}/remove_user/".replace("{"+"group_uuid"+"}", encodeURIComponent(groupUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Group Viewset
     * @param groupUuid A UUID string identifying this Group.
     * @return Group
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreGroupsRetrieve(groupUuid: java.util.UUID) : Group {
        val localVarResponse = coreGroupsRetrieveWithHttpInfo(groupUuid = groupUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Group
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Group Viewset
     * @param groupUuid A UUID string identifying this Group.
     * @return ApiResponse<Group?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreGroupsRetrieveWithHttpInfo(groupUuid: java.util.UUID) : ApiResponse<Group?> {
        val localVariableConfig = coreGroupsRetrieveRequestConfig(groupUuid = groupUuid)

        return request<Unit, Group>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreGroupsRetrieve
     *
     * @param groupUuid A UUID string identifying this Group.
     * @return RequestConfig
     */
    fun coreGroupsRetrieveRequestConfig(groupUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/groups/{group_uuid}/".replace("{"+"group_uuid"+"}", encodeURIComponent(groupUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Group Viewset
     * @param groupUuid A UUID string identifying this Group.
     * @param groupRequest 
     * @return Group
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreGroupsUpdate(groupUuid: java.util.UUID, groupRequest: GroupRequest) : Group {
        val localVarResponse = coreGroupsUpdateWithHttpInfo(groupUuid = groupUuid, groupRequest = groupRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Group
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Group Viewset
     * @param groupUuid A UUID string identifying this Group.
     * @param groupRequest 
     * @return ApiResponse<Group?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreGroupsUpdateWithHttpInfo(groupUuid: java.util.UUID, groupRequest: GroupRequest) : ApiResponse<Group?> {
        val localVariableConfig = coreGroupsUpdateRequestConfig(groupUuid = groupUuid, groupRequest = groupRequest)

        return request<GroupRequest, Group>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreGroupsUpdate
     *
     * @param groupUuid A UUID string identifying this Group.
     * @param groupRequest 
     * @return RequestConfig
     */
    fun coreGroupsUpdateRequestConfig(groupUuid: java.util.UUID, groupRequest: GroupRequest) : RequestConfig<GroupRequest> {
        val localVariableBody = groupRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/core/groups/{group_uuid}/".replace("{"+"group_uuid"+"}", encodeURIComponent(groupUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param groupUuid A UUID string identifying this Group.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreGroupsUsedByList(groupUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = coreGroupsUsedByListWithHttpInfo(groupUuid = groupUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param groupUuid A UUID string identifying this Group.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreGroupsUsedByListWithHttpInfo(groupUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = coreGroupsUsedByListRequestConfig(groupUuid = groupUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreGroupsUsedByList
     *
     * @param groupUuid A UUID string identifying this Group.
     * @return RequestConfig
     */
    fun coreGroupsUsedByListRequestConfig(groupUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/groups/{group_uuid}/used_by/".replace("{"+"group_uuid"+"}", encodeURIComponent(groupUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Tenant Viewset
     * @param tenantRequest 
     * @return Tenant
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTenantsCreate(tenantRequest: TenantRequest) : Tenant {
        val localVarResponse = coreTenantsCreateWithHttpInfo(tenantRequest = tenantRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tenant
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Tenant Viewset
     * @param tenantRequest 
     * @return ApiResponse<Tenant?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTenantsCreateWithHttpInfo(tenantRequest: TenantRequest) : ApiResponse<Tenant?> {
        val localVariableConfig = coreTenantsCreateRequestConfig(tenantRequest = tenantRequest)

        return request<TenantRequest, Tenant>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTenantsCreate
     *
     * @param tenantRequest 
     * @return RequestConfig
     */
    fun coreTenantsCreateRequestConfig(tenantRequest: TenantRequest) : RequestConfig<TenantRequest> {
        val localVariableBody = tenantRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/tenants/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get current tenant
     * @return CurrentTenant
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTenantsCurrentRetrieve() : CurrentTenant {
        val localVarResponse = coreTenantsCurrentRetrieveWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CurrentTenant
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get current tenant
     * @return ApiResponse<CurrentTenant?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTenantsCurrentRetrieveWithHttpInfo() : ApiResponse<CurrentTenant?> {
        val localVariableConfig = coreTenantsCurrentRetrieveRequestConfig()

        return request<Unit, CurrentTenant>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTenantsCurrentRetrieve
     *
     * @return RequestConfig
     */
    fun coreTenantsCurrentRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/tenants/current/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Tenant Viewset
     * @param tenantUuid A UUID string identifying this Tenant.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTenantsDestroy(tenantUuid: java.util.UUID) : Unit {
        val localVarResponse = coreTenantsDestroyWithHttpInfo(tenantUuid = tenantUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Tenant Viewset
     * @param tenantUuid A UUID string identifying this Tenant.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTenantsDestroyWithHttpInfo(tenantUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = coreTenantsDestroyRequestConfig(tenantUuid = tenantUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTenantsDestroy
     *
     * @param tenantUuid A UUID string identifying this Tenant.
     * @return RequestConfig
     */
    fun coreTenantsDestroyRequestConfig(tenantUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/core/tenants/{tenant_uuid}/".replace("{"+"tenant_uuid"+"}", encodeURIComponent(tenantUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Tenant Viewset
     * @param brandingFavicon  (optional)
     * @param brandingLogo  (optional)
     * @param brandingTitle  (optional)
     * @param default  (optional)
     * @param domain  (optional)
     * @param eventRetention  (optional)
     * @param flowAuthentication  (optional)
     * @param flowDeviceCode  (optional)
     * @param flowInvalidation  (optional)
     * @param flowRecovery  (optional)
     * @param flowUnenrollment  (optional)
     * @param flowUserSettings  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param tenantUuid  (optional)
     * @param webCertificate  (optional)
     * @return PaginatedTenantList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTenantsList(brandingFavicon: kotlin.String? = null, brandingLogo: kotlin.String? = null, brandingTitle: kotlin.String? = null, default: kotlin.Boolean? = null, domain: kotlin.String? = null, eventRetention: kotlin.String? = null, flowAuthentication: java.util.UUID? = null, flowDeviceCode: java.util.UUID? = null, flowInvalidation: java.util.UUID? = null, flowRecovery: java.util.UUID? = null, flowUnenrollment: java.util.UUID? = null, flowUserSettings: java.util.UUID? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, tenantUuid: java.util.UUID? = null, webCertificate: java.util.UUID? = null) : PaginatedTenantList {
        val localVarResponse = coreTenantsListWithHttpInfo(brandingFavicon = brandingFavicon, brandingLogo = brandingLogo, brandingTitle = brandingTitle, default = default, domain = domain, eventRetention = eventRetention, flowAuthentication = flowAuthentication, flowDeviceCode = flowDeviceCode, flowInvalidation = flowInvalidation, flowRecovery = flowRecovery, flowUnenrollment = flowUnenrollment, flowUserSettings = flowUserSettings, ordering = ordering, page = page, pageSize = pageSize, search = search, tenantUuid = tenantUuid, webCertificate = webCertificate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedTenantList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Tenant Viewset
     * @param brandingFavicon  (optional)
     * @param brandingLogo  (optional)
     * @param brandingTitle  (optional)
     * @param default  (optional)
     * @param domain  (optional)
     * @param eventRetention  (optional)
     * @param flowAuthentication  (optional)
     * @param flowDeviceCode  (optional)
     * @param flowInvalidation  (optional)
     * @param flowRecovery  (optional)
     * @param flowUnenrollment  (optional)
     * @param flowUserSettings  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param tenantUuid  (optional)
     * @param webCertificate  (optional)
     * @return ApiResponse<PaginatedTenantList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTenantsListWithHttpInfo(brandingFavicon: kotlin.String?, brandingLogo: kotlin.String?, brandingTitle: kotlin.String?, default: kotlin.Boolean?, domain: kotlin.String?, eventRetention: kotlin.String?, flowAuthentication: java.util.UUID?, flowDeviceCode: java.util.UUID?, flowInvalidation: java.util.UUID?, flowRecovery: java.util.UUID?, flowUnenrollment: java.util.UUID?, flowUserSettings: java.util.UUID?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, tenantUuid: java.util.UUID?, webCertificate: java.util.UUID?) : ApiResponse<PaginatedTenantList?> {
        val localVariableConfig = coreTenantsListRequestConfig(brandingFavicon = brandingFavicon, brandingLogo = brandingLogo, brandingTitle = brandingTitle, default = default, domain = domain, eventRetention = eventRetention, flowAuthentication = flowAuthentication, flowDeviceCode = flowDeviceCode, flowInvalidation = flowInvalidation, flowRecovery = flowRecovery, flowUnenrollment = flowUnenrollment, flowUserSettings = flowUserSettings, ordering = ordering, page = page, pageSize = pageSize, search = search, tenantUuid = tenantUuid, webCertificate = webCertificate)

        return request<Unit, PaginatedTenantList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTenantsList
     *
     * @param brandingFavicon  (optional)
     * @param brandingLogo  (optional)
     * @param brandingTitle  (optional)
     * @param default  (optional)
     * @param domain  (optional)
     * @param eventRetention  (optional)
     * @param flowAuthentication  (optional)
     * @param flowDeviceCode  (optional)
     * @param flowInvalidation  (optional)
     * @param flowRecovery  (optional)
     * @param flowUnenrollment  (optional)
     * @param flowUserSettings  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param tenantUuid  (optional)
     * @param webCertificate  (optional)
     * @return RequestConfig
     */
    fun coreTenantsListRequestConfig(brandingFavicon: kotlin.String?, brandingLogo: kotlin.String?, brandingTitle: kotlin.String?, default: kotlin.Boolean?, domain: kotlin.String?, eventRetention: kotlin.String?, flowAuthentication: java.util.UUID?, flowDeviceCode: java.util.UUID?, flowInvalidation: java.util.UUID?, flowRecovery: java.util.UUID?, flowUnenrollment: java.util.UUID?, flowUserSettings: java.util.UUID?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, tenantUuid: java.util.UUID?, webCertificate: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (brandingFavicon != null) {
                    put("branding_favicon", listOf(brandingFavicon.toString()))
                }
                if (brandingLogo != null) {
                    put("branding_logo", listOf(brandingLogo.toString()))
                }
                if (brandingTitle != null) {
                    put("branding_title", listOf(brandingTitle.toString()))
                }
                if (default != null) {
                    put("default", listOf(default.toString()))
                }
                if (domain != null) {
                    put("domain", listOf(domain.toString()))
                }
                if (eventRetention != null) {
                    put("event_retention", listOf(eventRetention.toString()))
                }
                if (flowAuthentication != null) {
                    put("flow_authentication", listOf(flowAuthentication.toString()))
                }
                if (flowDeviceCode != null) {
                    put("flow_device_code", listOf(flowDeviceCode.toString()))
                }
                if (flowInvalidation != null) {
                    put("flow_invalidation", listOf(flowInvalidation.toString()))
                }
                if (flowRecovery != null) {
                    put("flow_recovery", listOf(flowRecovery.toString()))
                }
                if (flowUnenrollment != null) {
                    put("flow_unenrollment", listOf(flowUnenrollment.toString()))
                }
                if (flowUserSettings != null) {
                    put("flow_user_settings", listOf(flowUserSettings.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (tenantUuid != null) {
                    put("tenant_uuid", listOf(tenantUuid.toString()))
                }
                if (webCertificate != null) {
                    put("web_certificate", listOf(webCertificate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/tenants/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Tenant Viewset
     * @param tenantUuid A UUID string identifying this Tenant.
     * @param patchedTenantRequest  (optional)
     * @return Tenant
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTenantsPartialUpdate(tenantUuid: java.util.UUID, patchedTenantRequest: PatchedTenantRequest? = null) : Tenant {
        val localVarResponse = coreTenantsPartialUpdateWithHttpInfo(tenantUuid = tenantUuid, patchedTenantRequest = patchedTenantRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tenant
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Tenant Viewset
     * @param tenantUuid A UUID string identifying this Tenant.
     * @param patchedTenantRequest  (optional)
     * @return ApiResponse<Tenant?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTenantsPartialUpdateWithHttpInfo(tenantUuid: java.util.UUID, patchedTenantRequest: PatchedTenantRequest?) : ApiResponse<Tenant?> {
        val localVariableConfig = coreTenantsPartialUpdateRequestConfig(tenantUuid = tenantUuid, patchedTenantRequest = patchedTenantRequest)

        return request<PatchedTenantRequest, Tenant>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTenantsPartialUpdate
     *
     * @param tenantUuid A UUID string identifying this Tenant.
     * @param patchedTenantRequest  (optional)
     * @return RequestConfig
     */
    fun coreTenantsPartialUpdateRequestConfig(tenantUuid: java.util.UUID, patchedTenantRequest: PatchedTenantRequest?) : RequestConfig<PatchedTenantRequest> {
        val localVariableBody = patchedTenantRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/core/tenants/{tenant_uuid}/".replace("{"+"tenant_uuid"+"}", encodeURIComponent(tenantUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Tenant Viewset
     * @param tenantUuid A UUID string identifying this Tenant.
     * @return Tenant
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTenantsRetrieve(tenantUuid: java.util.UUID) : Tenant {
        val localVarResponse = coreTenantsRetrieveWithHttpInfo(tenantUuid = tenantUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tenant
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Tenant Viewset
     * @param tenantUuid A UUID string identifying this Tenant.
     * @return ApiResponse<Tenant?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTenantsRetrieveWithHttpInfo(tenantUuid: java.util.UUID) : ApiResponse<Tenant?> {
        val localVariableConfig = coreTenantsRetrieveRequestConfig(tenantUuid = tenantUuid)

        return request<Unit, Tenant>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTenantsRetrieve
     *
     * @param tenantUuid A UUID string identifying this Tenant.
     * @return RequestConfig
     */
    fun coreTenantsRetrieveRequestConfig(tenantUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/tenants/{tenant_uuid}/".replace("{"+"tenant_uuid"+"}", encodeURIComponent(tenantUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Tenant Viewset
     * @param tenantUuid A UUID string identifying this Tenant.
     * @param tenantRequest 
     * @return Tenant
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTenantsUpdate(tenantUuid: java.util.UUID, tenantRequest: TenantRequest) : Tenant {
        val localVarResponse = coreTenantsUpdateWithHttpInfo(tenantUuid = tenantUuid, tenantRequest = tenantRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tenant
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Tenant Viewset
     * @param tenantUuid A UUID string identifying this Tenant.
     * @param tenantRequest 
     * @return ApiResponse<Tenant?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTenantsUpdateWithHttpInfo(tenantUuid: java.util.UUID, tenantRequest: TenantRequest) : ApiResponse<Tenant?> {
        val localVariableConfig = coreTenantsUpdateRequestConfig(tenantUuid = tenantUuid, tenantRequest = tenantRequest)

        return request<TenantRequest, Tenant>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTenantsUpdate
     *
     * @param tenantUuid A UUID string identifying this Tenant.
     * @param tenantRequest 
     * @return RequestConfig
     */
    fun coreTenantsUpdateRequestConfig(tenantUuid: java.util.UUID, tenantRequest: TenantRequest) : RequestConfig<TenantRequest> {
        val localVariableBody = tenantRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/core/tenants/{tenant_uuid}/".replace("{"+"tenant_uuid"+"}", encodeURIComponent(tenantUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param tenantUuid A UUID string identifying this Tenant.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTenantsUsedByList(tenantUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = coreTenantsUsedByListWithHttpInfo(tenantUuid = tenantUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param tenantUuid A UUID string identifying this Tenant.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTenantsUsedByListWithHttpInfo(tenantUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = coreTenantsUsedByListRequestConfig(tenantUuid = tenantUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTenantsUsedByList
     *
     * @param tenantUuid A UUID string identifying this Tenant.
     * @return RequestConfig
     */
    fun coreTenantsUsedByListRequestConfig(tenantUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/tenants/{tenant_uuid}/used_by/".replace("{"+"tenant_uuid"+"}", encodeURIComponent(tenantUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Token Viewset
     * @param tokenRequest 
     * @return Token
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTokensCreate(tokenRequest: TokenRequest) : Token {
        val localVarResponse = coreTokensCreateWithHttpInfo(tokenRequest = tokenRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Token
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Token Viewset
     * @param tokenRequest 
     * @return ApiResponse<Token?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTokensCreateWithHttpInfo(tokenRequest: TokenRequest) : ApiResponse<Token?> {
        val localVariableConfig = coreTokensCreateRequestConfig(tokenRequest = tokenRequest)

        return request<TokenRequest, Token>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTokensCreate
     *
     * @param tokenRequest 
     * @return RequestConfig
     */
    fun coreTokensCreateRequestConfig(tokenRequest: TokenRequest) : RequestConfig<TokenRequest> {
        val localVariableBody = tokenRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/tokens/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Token Viewset
     * @param identifier 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTokensDestroy(identifier: kotlin.String) : Unit {
        val localVarResponse = coreTokensDestroyWithHttpInfo(identifier = identifier)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Token Viewset
     * @param identifier 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTokensDestroyWithHttpInfo(identifier: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = coreTokensDestroyRequestConfig(identifier = identifier)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTokensDestroy
     *
     * @param identifier 
     * @return RequestConfig
     */
    fun coreTokensDestroyRequestConfig(identifier: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/core/tokens/{identifier}/".replace("{"+"identifier"+"}", encodeURIComponent(identifier.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter intent
     */
     enum class Intent_coreTokensList(val value: kotlin.String) {
         @Json(name = "api") api("api"),
         @Json(name = "app_password") appPassword("app_password"),
         @Json(name = "recovery") recovery("recovery"),
         @Json(name = "verification") verification("verification"),
     }

    /**
     * 
     * Token Viewset
     * @param description  (optional)
     * @param expires  (optional)
     * @param expiring  (optional)
     * @param identifier  (optional)
     * @param intent * &#x60;verification&#x60; - Intent Verification * &#x60;api&#x60; - Intent Api * &#x60;recovery&#x60; - Intent Recovery * &#x60;app_password&#x60; - Intent App Password (optional)
     * @param managed  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param userUsername  (optional)
     * @return PaginatedTokenList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTokensList(description: kotlin.String? = null, expires: java.time.OffsetDateTime? = null, expiring: kotlin.Boolean? = null, identifier: kotlin.String? = null, intent: Intent_coreTokensList? = null, managed: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, userUsername: kotlin.String? = null) : PaginatedTokenList {
        val localVarResponse = coreTokensListWithHttpInfo(description = description, expires = expires, expiring = expiring, identifier = identifier, intent = intent, managed = managed, ordering = ordering, page = page, pageSize = pageSize, search = search, userUsername = userUsername)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedTokenList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Token Viewset
     * @param description  (optional)
     * @param expires  (optional)
     * @param expiring  (optional)
     * @param identifier  (optional)
     * @param intent * &#x60;verification&#x60; - Intent Verification * &#x60;api&#x60; - Intent Api * &#x60;recovery&#x60; - Intent Recovery * &#x60;app_password&#x60; - Intent App Password (optional)
     * @param managed  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param userUsername  (optional)
     * @return ApiResponse<PaginatedTokenList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTokensListWithHttpInfo(description: kotlin.String?, expires: java.time.OffsetDateTime?, expiring: kotlin.Boolean?, identifier: kotlin.String?, intent: Intent_coreTokensList?, managed: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, userUsername: kotlin.String?) : ApiResponse<PaginatedTokenList?> {
        val localVariableConfig = coreTokensListRequestConfig(description = description, expires = expires, expiring = expiring, identifier = identifier, intent = intent, managed = managed, ordering = ordering, page = page, pageSize = pageSize, search = search, userUsername = userUsername)

        return request<Unit, PaginatedTokenList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTokensList
     *
     * @param description  (optional)
     * @param expires  (optional)
     * @param expiring  (optional)
     * @param identifier  (optional)
     * @param intent * &#x60;verification&#x60; - Intent Verification * &#x60;api&#x60; - Intent Api * &#x60;recovery&#x60; - Intent Recovery * &#x60;app_password&#x60; - Intent App Password (optional)
     * @param managed  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param userUsername  (optional)
     * @return RequestConfig
     */
    fun coreTokensListRequestConfig(description: kotlin.String?, expires: java.time.OffsetDateTime?, expiring: kotlin.Boolean?, identifier: kotlin.String?, intent: Intent_coreTokensList?, managed: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, userUsername: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (description != null) {
                    put("description", listOf(description.toString()))
                }
                if (expires != null) {
                    put("expires", listOf(parseDateToQueryString(expires)))
                }
                if (expiring != null) {
                    put("expiring", listOf(expiring.toString()))
                }
                if (identifier != null) {
                    put("identifier", listOf(identifier.toString()))
                }
                if (intent != null) {
                    put("intent", listOf(intent.toString()))
                }
                if (managed != null) {
                    put("managed", listOf(managed.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (userUsername != null) {
                    put("user__username", listOf(userUsername.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/tokens/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Token Viewset
     * @param identifier 
     * @param patchedTokenRequest  (optional)
     * @return Token
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTokensPartialUpdate(identifier: kotlin.String, patchedTokenRequest: PatchedTokenRequest? = null) : Token {
        val localVarResponse = coreTokensPartialUpdateWithHttpInfo(identifier = identifier, patchedTokenRequest = patchedTokenRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Token
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Token Viewset
     * @param identifier 
     * @param patchedTokenRequest  (optional)
     * @return ApiResponse<Token?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTokensPartialUpdateWithHttpInfo(identifier: kotlin.String, patchedTokenRequest: PatchedTokenRequest?) : ApiResponse<Token?> {
        val localVariableConfig = coreTokensPartialUpdateRequestConfig(identifier = identifier, patchedTokenRequest = patchedTokenRequest)

        return request<PatchedTokenRequest, Token>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTokensPartialUpdate
     *
     * @param identifier 
     * @param patchedTokenRequest  (optional)
     * @return RequestConfig
     */
    fun coreTokensPartialUpdateRequestConfig(identifier: kotlin.String, patchedTokenRequest: PatchedTokenRequest?) : RequestConfig<PatchedTokenRequest> {
        val localVariableBody = patchedTokenRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/core/tokens/{identifier}/".replace("{"+"identifier"+"}", encodeURIComponent(identifier.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Token Viewset
     * @param identifier 
     * @return Token
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTokensRetrieve(identifier: kotlin.String) : Token {
        val localVarResponse = coreTokensRetrieveWithHttpInfo(identifier = identifier)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Token
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Token Viewset
     * @param identifier 
     * @return ApiResponse<Token?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTokensRetrieveWithHttpInfo(identifier: kotlin.String) : ApiResponse<Token?> {
        val localVariableConfig = coreTokensRetrieveRequestConfig(identifier = identifier)

        return request<Unit, Token>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTokensRetrieve
     *
     * @param identifier 
     * @return RequestConfig
     */
    fun coreTokensRetrieveRequestConfig(identifier: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/tokens/{identifier}/".replace("{"+"identifier"+"}", encodeURIComponent(identifier.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set token key. Action is logged as event. &#x60;authentik_core.set_token_key&#x60; permission is required.
     * @param identifier 
     * @param tokenSetKeyRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTokensSetKeyCreate(identifier: kotlin.String, tokenSetKeyRequest: TokenSetKeyRequest) : Unit {
        val localVarResponse = coreTokensSetKeyCreateWithHttpInfo(identifier = identifier, tokenSetKeyRequest = tokenSetKeyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set token key. Action is logged as event. &#x60;authentik_core.set_token_key&#x60; permission is required.
     * @param identifier 
     * @param tokenSetKeyRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTokensSetKeyCreateWithHttpInfo(identifier: kotlin.String, tokenSetKeyRequest: TokenSetKeyRequest) : ApiResponse<Unit?> {
        val localVariableConfig = coreTokensSetKeyCreateRequestConfig(identifier = identifier, tokenSetKeyRequest = tokenSetKeyRequest)

        return request<TokenSetKeyRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTokensSetKeyCreate
     *
     * @param identifier 
     * @param tokenSetKeyRequest 
     * @return RequestConfig
     */
    fun coreTokensSetKeyCreateRequestConfig(identifier: kotlin.String, tokenSetKeyRequest: TokenSetKeyRequest) : RequestConfig<TokenSetKeyRequest> {
        val localVariableBody = tokenSetKeyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/tokens/{identifier}/set_key/".replace("{"+"identifier"+"}", encodeURIComponent(identifier.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Token Viewset
     * @param identifier 
     * @param tokenRequest 
     * @return Token
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTokensUpdate(identifier: kotlin.String, tokenRequest: TokenRequest) : Token {
        val localVarResponse = coreTokensUpdateWithHttpInfo(identifier = identifier, tokenRequest = tokenRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Token
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Token Viewset
     * @param identifier 
     * @param tokenRequest 
     * @return ApiResponse<Token?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTokensUpdateWithHttpInfo(identifier: kotlin.String, tokenRequest: TokenRequest) : ApiResponse<Token?> {
        val localVariableConfig = coreTokensUpdateRequestConfig(identifier = identifier, tokenRequest = tokenRequest)

        return request<TokenRequest, Token>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTokensUpdate
     *
     * @param identifier 
     * @param tokenRequest 
     * @return RequestConfig
     */
    fun coreTokensUpdateRequestConfig(identifier: kotlin.String, tokenRequest: TokenRequest) : RequestConfig<TokenRequest> {
        val localVariableBody = tokenRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/core/tokens/{identifier}/".replace("{"+"identifier"+"}", encodeURIComponent(identifier.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param identifier 
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTokensUsedByList(identifier: kotlin.String) : kotlin.collections.List<UsedBy> {
        val localVarResponse = coreTokensUsedByListWithHttpInfo(identifier = identifier)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param identifier 
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTokensUsedByListWithHttpInfo(identifier: kotlin.String) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = coreTokensUsedByListRequestConfig(identifier = identifier)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTokensUsedByList
     *
     * @param identifier 
     * @return RequestConfig
     */
    fun coreTokensUsedByListRequestConfig(identifier: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/tokens/{identifier}/used_by/".replace("{"+"identifier"+"}", encodeURIComponent(identifier.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Return token key and log access
     * @param identifier 
     * @return TokenView
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTokensViewKeyRetrieve(identifier: kotlin.String) : TokenView {
        val localVarResponse = coreTokensViewKeyRetrieveWithHttpInfo(identifier = identifier)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenView
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Return token key and log access
     * @param identifier 
     * @return ApiResponse<TokenView?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTokensViewKeyRetrieveWithHttpInfo(identifier: kotlin.String) : ApiResponse<TokenView?> {
        val localVariableConfig = coreTokensViewKeyRetrieveRequestConfig(identifier = identifier)

        return request<Unit, TokenView>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTokensViewKeyRetrieve
     *
     * @param identifier 
     * @return RequestConfig
     */
    fun coreTokensViewKeyRetrieveRequestConfig(identifier: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/tokens/{identifier}/view_key/".replace("{"+"identifier"+"}", encodeURIComponent(identifier.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Convert data into a blueprint, validate it and apply it
     * @param transactionApplicationRequest 
     * @return TransactionApplicationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreTransactionalApplicationsUpdate(transactionApplicationRequest: TransactionApplicationRequest) : TransactionApplicationResponse {
        val localVarResponse = coreTransactionalApplicationsUpdateWithHttpInfo(transactionApplicationRequest = transactionApplicationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TransactionApplicationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Convert data into a blueprint, validate it and apply it
     * @param transactionApplicationRequest 
     * @return ApiResponse<TransactionApplicationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreTransactionalApplicationsUpdateWithHttpInfo(transactionApplicationRequest: TransactionApplicationRequest) : ApiResponse<TransactionApplicationResponse?> {
        val localVariableConfig = coreTransactionalApplicationsUpdateRequestConfig(transactionApplicationRequest = transactionApplicationRequest)

        return request<TransactionApplicationRequest, TransactionApplicationResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreTransactionalApplicationsUpdate
     *
     * @param transactionApplicationRequest 
     * @return RequestConfig
     */
    fun coreTransactionalApplicationsUpdateRequestConfig(transactionApplicationRequest: TransactionApplicationRequest) : RequestConfig<TransactionApplicationRequest> {
        val localVariableBody = transactionApplicationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/core/transactional/applications/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserConsent Viewset
     * @param id A unique integer value identifying this User Consent.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUserConsentDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = coreUserConsentDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserConsent Viewset
     * @param id A unique integer value identifying this User Consent.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUserConsentDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = coreUserConsentDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUserConsentDestroy
     *
     * @param id A unique integer value identifying this User Consent.
     * @return RequestConfig
     */
    fun coreUserConsentDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/core/user_consent/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserConsent Viewset
     * @param application  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param user  (optional)
     * @return PaginatedUserConsentList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUserConsentList(application: java.util.UUID? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, user: kotlin.Int? = null) : PaginatedUserConsentList {
        val localVarResponse = coreUserConsentListWithHttpInfo(application = application, ordering = ordering, page = page, pageSize = pageSize, search = search, user = user)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedUserConsentList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserConsent Viewset
     * @param application  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param user  (optional)
     * @return ApiResponse<PaginatedUserConsentList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUserConsentListWithHttpInfo(application: java.util.UUID?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, user: kotlin.Int?) : ApiResponse<PaginatedUserConsentList?> {
        val localVariableConfig = coreUserConsentListRequestConfig(application = application, ordering = ordering, page = page, pageSize = pageSize, search = search, user = user)

        return request<Unit, PaginatedUserConsentList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUserConsentList
     *
     * @param application  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param user  (optional)
     * @return RequestConfig
     */
    fun coreUserConsentListRequestConfig(application: java.util.UUID?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, user: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (application != null) {
                    put("application", listOf(application.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/user_consent/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserConsent Viewset
     * @param id A unique integer value identifying this User Consent.
     * @return UserConsent
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUserConsentRetrieve(id: kotlin.Int) : UserConsent {
        val localVarResponse = coreUserConsentRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserConsent
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserConsent Viewset
     * @param id A unique integer value identifying this User Consent.
     * @return ApiResponse<UserConsent?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUserConsentRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<UserConsent?> {
        val localVariableConfig = coreUserConsentRetrieveRequestConfig(id = id)

        return request<Unit, UserConsent>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUserConsentRetrieve
     *
     * @param id A unique integer value identifying this User Consent.
     * @return RequestConfig
     */
    fun coreUserConsentRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/user_consent/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this User Consent.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUserConsentUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = coreUserConsentUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this User Consent.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUserConsentUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = coreUserConsentUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUserConsentUsedByList
     *
     * @param id A unique integer value identifying this User Consent.
     * @return RequestConfig
     */
    fun coreUserConsentUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/user_consent/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * User Viewset
     * @param userRequest 
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersCreate(userRequest: UserRequest) : User {
        val localVarResponse = coreUsersCreateWithHttpInfo(userRequest = userRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User Viewset
     * @param userRequest 
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersCreateWithHttpInfo(userRequest: UserRequest) : ApiResponse<User?> {
        val localVariableConfig = coreUsersCreateRequestConfig(userRequest = userRequest)

        return request<UserRequest, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersCreate
     *
     * @param userRequest 
     * @return RequestConfig
     */
    fun coreUsersCreateRequestConfig(userRequest: UserRequest) : RequestConfig<UserRequest> {
        val localVariableBody = userRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/users/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * User Viewset
     * @param id A unique integer value identifying this User.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = coreUsersDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User Viewset
     * @param id A unique integer value identifying this User.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = coreUsersDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersDestroy
     *
     * @param id A unique integer value identifying this User.
     * @return RequestConfig
     */
    fun coreUsersDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/core/users/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Impersonate a user
     * @param id A unique integer value identifying this User.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersImpersonateCreate(id: kotlin.Int) : Unit {
        val localVarResponse = coreUsersImpersonateCreateWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Impersonate a user
     * @param id A unique integer value identifying this User.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersImpersonateCreateWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = coreUsersImpersonateCreateRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersImpersonateCreate
     *
     * @param id A unique integer value identifying this User.
     * @return RequestConfig
     */
    fun coreUsersImpersonateCreateRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/users/{id}/impersonate/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * End Impersonation a user
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersImpersonateEndRetrieve() : Unit {
        val localVarResponse = coreUsersImpersonateEndRetrieveWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * End Impersonation a user
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersImpersonateEndRetrieveWithHttpInfo() : ApiResponse<Unit?> {
        val localVariableConfig = coreUsersImpersonateEndRetrieveRequestConfig()

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersImpersonateEndRetrieve
     *
     * @return RequestConfig
     */
    fun coreUsersImpersonateEndRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/users/impersonate_end/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter type
     */
     enum class Type_coreUsersList(val value: kotlin.String) {
         @Json(name = "external") `external`("external"),
         @Json(name = "internal") `internal`("internal"),
         @Json(name = "internal_service_account") internalServiceAccount("internal_service_account"),
         @Json(name = "service_account") serviceAccount("service_account"),
     }

    /**
     * 
     * User Viewset
     * @param attributes Attributes (optional)
     * @param email  (optional)
     * @param groupsByName  (optional)
     * @param groupsByPk  (optional)
     * @param isActive  (optional)
     * @param isSuperuser  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param path  (optional)
     * @param pathStartswith  (optional)
     * @param search A search term. (optional)
     * @param type * &#x60;internal&#x60; - Internal * &#x60;external&#x60; - External * &#x60;service_account&#x60; - Service Account * &#x60;internal_service_account&#x60; - Internal Service Account (optional)
     * @param username  (optional)
     * @param uuid  (optional)
     * @return PaginatedUserList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersList(attributes: kotlin.String? = null, email: kotlin.String? = null, groupsByName: kotlin.collections.List<kotlin.String>? = null, groupsByPk: kotlin.collections.List<java.util.UUID>? = null, isActive: kotlin.Boolean? = null, isSuperuser: kotlin.Boolean? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, path: kotlin.String? = null, pathStartswith: kotlin.String? = null, search: kotlin.String? = null, type: kotlin.collections.List<Type_coreUsersList>? = null, username: kotlin.String? = null, uuid: java.util.UUID? = null) : PaginatedUserList {
        val localVarResponse = coreUsersListWithHttpInfo(attributes = attributes, email = email, groupsByName = groupsByName, groupsByPk = groupsByPk, isActive = isActive, isSuperuser = isSuperuser, name = name, ordering = ordering, page = page, pageSize = pageSize, path = path, pathStartswith = pathStartswith, search = search, type = type, username = username, uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedUserList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User Viewset
     * @param attributes Attributes (optional)
     * @param email  (optional)
     * @param groupsByName  (optional)
     * @param groupsByPk  (optional)
     * @param isActive  (optional)
     * @param isSuperuser  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param path  (optional)
     * @param pathStartswith  (optional)
     * @param search A search term. (optional)
     * @param type * &#x60;internal&#x60; - Internal * &#x60;external&#x60; - External * &#x60;service_account&#x60; - Service Account * &#x60;internal_service_account&#x60; - Internal Service Account (optional)
     * @param username  (optional)
     * @param uuid  (optional)
     * @return ApiResponse<PaginatedUserList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersListWithHttpInfo(attributes: kotlin.String?, email: kotlin.String?, groupsByName: kotlin.collections.List<kotlin.String>?, groupsByPk: kotlin.collections.List<java.util.UUID>?, isActive: kotlin.Boolean?, isSuperuser: kotlin.Boolean?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, path: kotlin.String?, pathStartswith: kotlin.String?, search: kotlin.String?, type: kotlin.collections.List<Type_coreUsersList>?, username: kotlin.String?, uuid: java.util.UUID?) : ApiResponse<PaginatedUserList?> {
        val localVariableConfig = coreUsersListRequestConfig(attributes = attributes, email = email, groupsByName = groupsByName, groupsByPk = groupsByPk, isActive = isActive, isSuperuser = isSuperuser, name = name, ordering = ordering, page = page, pageSize = pageSize, path = path, pathStartswith = pathStartswith, search = search, type = type, username = username, uuid = uuid)

        return request<Unit, PaginatedUserList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersList
     *
     * @param attributes Attributes (optional)
     * @param email  (optional)
     * @param groupsByName  (optional)
     * @param groupsByPk  (optional)
     * @param isActive  (optional)
     * @param isSuperuser  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param path  (optional)
     * @param pathStartswith  (optional)
     * @param search A search term. (optional)
     * @param type * &#x60;internal&#x60; - Internal * &#x60;external&#x60; - External * &#x60;service_account&#x60; - Service Account * &#x60;internal_service_account&#x60; - Internal Service Account (optional)
     * @param username  (optional)
     * @param uuid  (optional)
     * @return RequestConfig
     */
    fun coreUsersListRequestConfig(attributes: kotlin.String?, email: kotlin.String?, groupsByName: kotlin.collections.List<kotlin.String>?, groupsByPk: kotlin.collections.List<java.util.UUID>?, isActive: kotlin.Boolean?, isSuperuser: kotlin.Boolean?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, path: kotlin.String?, pathStartswith: kotlin.String?, search: kotlin.String?, type: kotlin.collections.List<Type_coreUsersList>?, username: kotlin.String?, uuid: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (attributes != null) {
                    put("attributes", listOf(attributes.toString()))
                }
                if (email != null) {
                    put("email", listOf(email.toString()))
                }
                if (groupsByName != null) {
                    put("groups_by_name", toMultiValue(groupsByName.toList(), "multi"))
                }
                if (groupsByPk != null) {
                    put("groups_by_pk", toMultiValue(groupsByPk.toList(), "multi"))
                }
                if (isActive != null) {
                    put("is_active", listOf(isActive.toString()))
                }
                if (isSuperuser != null) {
                    put("is_superuser", listOf(isSuperuser.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (path != null) {
                    put("path", listOf(path.toString()))
                }
                if (pathStartswith != null) {
                    put("path_startswith", listOf(pathStartswith.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (type != null) {
                    put("type", toMultiValue(type.toList(), "multi"))
                }
                if (username != null) {
                    put("username", listOf(username.toString()))
                }
                if (uuid != null) {
                    put("uuid", listOf(uuid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/users/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get information about current user
     * @return SessionUser
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersMeRetrieve() : SessionUser {
        val localVarResponse = coreUsersMeRetrieveWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SessionUser
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get information about current user
     * @return ApiResponse<SessionUser?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersMeRetrieveWithHttpInfo() : ApiResponse<SessionUser?> {
        val localVariableConfig = coreUsersMeRetrieveRequestConfig()

        return request<Unit, SessionUser>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersMeRetrieve
     *
     * @return RequestConfig
     */
    fun coreUsersMeRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/users/me/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * User metrics per 1h
     * @param id A unique integer value identifying this User.
     * @return UserMetrics
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersMetricsRetrieve(id: kotlin.Int) : UserMetrics {
        val localVarResponse = coreUsersMetricsRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserMetrics
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User metrics per 1h
     * @param id A unique integer value identifying this User.
     * @return ApiResponse<UserMetrics?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersMetricsRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<UserMetrics?> {
        val localVariableConfig = coreUsersMetricsRetrieveRequestConfig(id = id)

        return request<Unit, UserMetrics>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersMetricsRetrieve
     *
     * @param id A unique integer value identifying this User.
     * @return RequestConfig
     */
    fun coreUsersMetricsRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/users/{id}/metrics/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * User Viewset
     * @param id A unique integer value identifying this User.
     * @param patchedUserRequest  (optional)
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersPartialUpdate(id: kotlin.Int, patchedUserRequest: PatchedUserRequest? = null) : User {
        val localVarResponse = coreUsersPartialUpdateWithHttpInfo(id = id, patchedUserRequest = patchedUserRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User Viewset
     * @param id A unique integer value identifying this User.
     * @param patchedUserRequest  (optional)
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersPartialUpdateWithHttpInfo(id: kotlin.Int, patchedUserRequest: PatchedUserRequest?) : ApiResponse<User?> {
        val localVariableConfig = coreUsersPartialUpdateRequestConfig(id = id, patchedUserRequest = patchedUserRequest)

        return request<PatchedUserRequest, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersPartialUpdate
     *
     * @param id A unique integer value identifying this User.
     * @param patchedUserRequest  (optional)
     * @return RequestConfig
     */
    fun coreUsersPartialUpdateRequestConfig(id: kotlin.Int, patchedUserRequest: PatchedUserRequest?) : RequestConfig<PatchedUserRequest> {
        val localVariableBody = patchedUserRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/core/users/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all user paths
     * @param search  (optional)
     * @return UserPath
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersPathsRetrieve(search: kotlin.String? = null) : UserPath {
        val localVarResponse = coreUsersPathsRetrieveWithHttpInfo(search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserPath
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all user paths
     * @param search  (optional)
     * @return ApiResponse<UserPath?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersPathsRetrieveWithHttpInfo(search: kotlin.String?) : ApiResponse<UserPath?> {
        val localVariableConfig = coreUsersPathsRetrieveRequestConfig(search = search)

        return request<Unit, UserPath>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersPathsRetrieve
     *
     * @param search  (optional)
     * @return RequestConfig
     */
    fun coreUsersPathsRetrieveRequestConfig(search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/users/paths/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Create a temporary link that a user can use to recover their accounts
     * @param id A unique integer value identifying this User.
     * @param emailStage 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersRecoveryEmailRetrieve(id: kotlin.Int, emailStage: kotlin.String) : Unit {
        val localVarResponse = coreUsersRecoveryEmailRetrieveWithHttpInfo(id = id, emailStage = emailStage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Create a temporary link that a user can use to recover their accounts
     * @param id A unique integer value identifying this User.
     * @param emailStage 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersRecoveryEmailRetrieveWithHttpInfo(id: kotlin.Int, emailStage: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = coreUsersRecoveryEmailRetrieveRequestConfig(id = id, emailStage = emailStage)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersRecoveryEmailRetrieve
     *
     * @param id A unique integer value identifying this User.
     * @param emailStage 
     * @return RequestConfig
     */
    fun coreUsersRecoveryEmailRetrieveRequestConfig(id: kotlin.Int, emailStage: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("email_stage", listOf(emailStage.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/users/{id}/recovery_email/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Create a temporary link that a user can use to recover their accounts
     * @param id A unique integer value identifying this User.
     * @return Link
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersRecoveryRetrieve(id: kotlin.Int) : Link {
        val localVarResponse = coreUsersRecoveryRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Link
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Create a temporary link that a user can use to recover their accounts
     * @param id A unique integer value identifying this User.
     * @return ApiResponse<Link?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersRecoveryRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<Link?> {
        val localVariableConfig = coreUsersRecoveryRetrieveRequestConfig(id = id)

        return request<Unit, Link>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersRecoveryRetrieve
     *
     * @param id A unique integer value identifying this User.
     * @return RequestConfig
     */
    fun coreUsersRecoveryRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/users/{id}/recovery/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * User Viewset
     * @param id A unique integer value identifying this User.
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersRetrieve(id: kotlin.Int) : User {
        val localVarResponse = coreUsersRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User Viewset
     * @param id A unique integer value identifying this User.
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<User?> {
        val localVariableConfig = coreUsersRetrieveRequestConfig(id = id)

        return request<Unit, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersRetrieve
     *
     * @param id A unique integer value identifying this User.
     * @return RequestConfig
     */
    fun coreUsersRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/users/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Create a new user account that is marked as a service account
     * @param userServiceAccountRequest 
     * @return UserServiceAccountResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersServiceAccountCreate(userServiceAccountRequest: UserServiceAccountRequest) : UserServiceAccountResponse {
        val localVarResponse = coreUsersServiceAccountCreateWithHttpInfo(userServiceAccountRequest = userServiceAccountRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserServiceAccountResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Create a new user account that is marked as a service account
     * @param userServiceAccountRequest 
     * @return ApiResponse<UserServiceAccountResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersServiceAccountCreateWithHttpInfo(userServiceAccountRequest: UserServiceAccountRequest) : ApiResponse<UserServiceAccountResponse?> {
        val localVariableConfig = coreUsersServiceAccountCreateRequestConfig(userServiceAccountRequest = userServiceAccountRequest)

        return request<UserServiceAccountRequest, UserServiceAccountResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersServiceAccountCreate
     *
     * @param userServiceAccountRequest 
     * @return RequestConfig
     */
    fun coreUsersServiceAccountCreateRequestConfig(userServiceAccountRequest: UserServiceAccountRequest) : RequestConfig<UserServiceAccountRequest> {
        val localVariableBody = userServiceAccountRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/users/service_account/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set password for user
     * @param id A unique integer value identifying this User.
     * @param userPasswordSetRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersSetPasswordCreate(id: kotlin.Int, userPasswordSetRequest: UserPasswordSetRequest) : Unit {
        val localVarResponse = coreUsersSetPasswordCreateWithHttpInfo(id = id, userPasswordSetRequest = userPasswordSetRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set password for user
     * @param id A unique integer value identifying this User.
     * @param userPasswordSetRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersSetPasswordCreateWithHttpInfo(id: kotlin.Int, userPasswordSetRequest: UserPasswordSetRequest) : ApiResponse<Unit?> {
        val localVariableConfig = coreUsersSetPasswordCreateRequestConfig(id = id, userPasswordSetRequest = userPasswordSetRequest)

        return request<UserPasswordSetRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersSetPasswordCreate
     *
     * @param id A unique integer value identifying this User.
     * @param userPasswordSetRequest 
     * @return RequestConfig
     */
    fun coreUsersSetPasswordCreateRequestConfig(id: kotlin.Int, userPasswordSetRequest: UserPasswordSetRequest) : RequestConfig<UserPasswordSetRequest> {
        val localVariableBody = userPasswordSetRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/core/users/{id}/set_password/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * User Viewset
     * @param id A unique integer value identifying this User.
     * @param userRequest 
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersUpdate(id: kotlin.Int, userRequest: UserRequest) : User {
        val localVarResponse = coreUsersUpdateWithHttpInfo(id = id, userRequest = userRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User Viewset
     * @param id A unique integer value identifying this User.
     * @param userRequest 
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersUpdateWithHttpInfo(id: kotlin.Int, userRequest: UserRequest) : ApiResponse<User?> {
        val localVariableConfig = coreUsersUpdateRequestConfig(id = id, userRequest = userRequest)

        return request<UserRequest, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersUpdate
     *
     * @param id A unique integer value identifying this User.
     * @param userRequest 
     * @return RequestConfig
     */
    fun coreUsersUpdateRequestConfig(id: kotlin.Int, userRequest: UserRequest) : RequestConfig<UserRequest> {
        val localVariableBody = userRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/core/users/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this User.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun coreUsersUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = coreUsersUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this User.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun coreUsersUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = coreUsersUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation coreUsersUsedByList
     *
     * @param id A unique integer value identifying this User.
     * @return RequestConfig
     */
    fun coreUsersUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/core/users/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
