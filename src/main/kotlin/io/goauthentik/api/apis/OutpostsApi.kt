/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.DockerServiceConnection
import io.goauthentik.api.models.DockerServiceConnectionRequest
import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.KubernetesServiceConnection
import io.goauthentik.api.models.KubernetesServiceConnectionRequest
import io.goauthentik.api.models.LDAPOutpostConfig
import io.goauthentik.api.models.Outpost
import io.goauthentik.api.models.OutpostDefaultConfig
import io.goauthentik.api.models.OutpostHealth
import io.goauthentik.api.models.OutpostRequest
import io.goauthentik.api.models.PaginatedDockerServiceConnectionList
import io.goauthentik.api.models.PaginatedKubernetesServiceConnectionList
import io.goauthentik.api.models.PaginatedLDAPOutpostConfigList
import io.goauthentik.api.models.PaginatedOutpostList
import io.goauthentik.api.models.PaginatedProxyOutpostConfigList
import io.goauthentik.api.models.PaginatedRadiusOutpostConfigList
import io.goauthentik.api.models.PaginatedServiceConnectionList
import io.goauthentik.api.models.PatchedDockerServiceConnectionRequest
import io.goauthentik.api.models.PatchedKubernetesServiceConnectionRequest
import io.goauthentik.api.models.PatchedOutpostRequest
import io.goauthentik.api.models.ProxyOutpostConfig
import io.goauthentik.api.models.RadiusOutpostConfig
import io.goauthentik.api.models.ServiceConnection
import io.goauthentik.api.models.ServiceConnectionState
import io.goauthentik.api.models.TypeCreate
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.ValidationError

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class OutpostsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * Outpost Viewset
     * @param outpostRequest 
     * @return Outpost
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsInstancesCreate(outpostRequest: OutpostRequest) : Outpost {
        val localVarResponse = outpostsInstancesCreateWithHttpInfo(outpostRequest = outpostRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Outpost
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Outpost Viewset
     * @param outpostRequest 
     * @return ApiResponse<Outpost?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsInstancesCreateWithHttpInfo(outpostRequest: OutpostRequest) : ApiResponse<Outpost?> {
        val localVariableConfig = outpostsInstancesCreateRequestConfig(outpostRequest = outpostRequest)

        return request<OutpostRequest, Outpost>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsInstancesCreate
     *
     * @param outpostRequest 
     * @return RequestConfig
     */
    fun outpostsInstancesCreateRequestConfig(outpostRequest: OutpostRequest) : RequestConfig<OutpostRequest> {
        val localVariableBody = outpostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/outposts/instances/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Global default outpost config
     * @return OutpostDefaultConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsInstancesDefaultSettingsRetrieve() : OutpostDefaultConfig {
        val localVarResponse = outpostsInstancesDefaultSettingsRetrieveWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OutpostDefaultConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Global default outpost config
     * @return ApiResponse<OutpostDefaultConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsInstancesDefaultSettingsRetrieveWithHttpInfo() : ApiResponse<OutpostDefaultConfig?> {
        val localVariableConfig = outpostsInstancesDefaultSettingsRetrieveRequestConfig()

        return request<Unit, OutpostDefaultConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsInstancesDefaultSettingsRetrieve
     *
     * @return RequestConfig
     */
    fun outpostsInstancesDefaultSettingsRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/instances/default_settings/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Outpost Viewset
     * @param uuid A UUID string identifying this Outpost.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsInstancesDestroy(uuid: java.util.UUID) : Unit {
        val localVarResponse = outpostsInstancesDestroyWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Outpost Viewset
     * @param uuid A UUID string identifying this Outpost.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsInstancesDestroyWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = outpostsInstancesDestroyRequestConfig(uuid = uuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsInstancesDestroy
     *
     * @param uuid A UUID string identifying this Outpost.
     * @return RequestConfig
     */
    fun outpostsInstancesDestroyRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/outposts/instances/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get outposts current health
     * @param uuid A UUID string identifying this Outpost.
     * @param managedIcontains  (optional)
     * @param managedIexact  (optional)
     * @param nameIcontains  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param providersIsnull  (optional)
     * @param providersByPk  (optional)
     * @param search A search term. (optional)
     * @param serviceConnectionNameIcontains  (optional)
     * @param serviceConnectionNameIexact  (optional)
     * @return kotlin.collections.List<OutpostHealth>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsInstancesHealthList(uuid: java.util.UUID, managedIcontains: kotlin.String? = null, managedIexact: kotlin.String? = null, nameIcontains: kotlin.String? = null, nameIexact: kotlin.String? = null, ordering: kotlin.String? = null, providersIsnull: kotlin.Boolean? = null, providersByPk: kotlin.collections.List<kotlin.Int>? = null, search: kotlin.String? = null, serviceConnectionNameIcontains: kotlin.String? = null, serviceConnectionNameIexact: kotlin.String? = null) : kotlin.collections.List<OutpostHealth> {
        val localVarResponse = outpostsInstancesHealthListWithHttpInfo(uuid = uuid, managedIcontains = managedIcontains, managedIexact = managedIexact, nameIcontains = nameIcontains, nameIexact = nameIexact, ordering = ordering, providersIsnull = providersIsnull, providersByPk = providersByPk, search = search, serviceConnectionNameIcontains = serviceConnectionNameIcontains, serviceConnectionNameIexact = serviceConnectionNameIexact)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OutpostHealth>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get outposts current health
     * @param uuid A UUID string identifying this Outpost.
     * @param managedIcontains  (optional)
     * @param managedIexact  (optional)
     * @param nameIcontains  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param providersIsnull  (optional)
     * @param providersByPk  (optional)
     * @param search A search term. (optional)
     * @param serviceConnectionNameIcontains  (optional)
     * @param serviceConnectionNameIexact  (optional)
     * @return ApiResponse<kotlin.collections.List<OutpostHealth>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsInstancesHealthListWithHttpInfo(uuid: java.util.UUID, managedIcontains: kotlin.String?, managedIexact: kotlin.String?, nameIcontains: kotlin.String?, nameIexact: kotlin.String?, ordering: kotlin.String?, providersIsnull: kotlin.Boolean?, providersByPk: kotlin.collections.List<kotlin.Int>?, search: kotlin.String?, serviceConnectionNameIcontains: kotlin.String?, serviceConnectionNameIexact: kotlin.String?) : ApiResponse<kotlin.collections.List<OutpostHealth>?> {
        val localVariableConfig = outpostsInstancesHealthListRequestConfig(uuid = uuid, managedIcontains = managedIcontains, managedIexact = managedIexact, nameIcontains = nameIcontains, nameIexact = nameIexact, ordering = ordering, providersIsnull = providersIsnull, providersByPk = providersByPk, search = search, serviceConnectionNameIcontains = serviceConnectionNameIcontains, serviceConnectionNameIexact = serviceConnectionNameIexact)

        return request<Unit, kotlin.collections.List<OutpostHealth>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsInstancesHealthList
     *
     * @param uuid A UUID string identifying this Outpost.
     * @param managedIcontains  (optional)
     * @param managedIexact  (optional)
     * @param nameIcontains  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param providersIsnull  (optional)
     * @param providersByPk  (optional)
     * @param search A search term. (optional)
     * @param serviceConnectionNameIcontains  (optional)
     * @param serviceConnectionNameIexact  (optional)
     * @return RequestConfig
     */
    fun outpostsInstancesHealthListRequestConfig(uuid: java.util.UUID, managedIcontains: kotlin.String?, managedIexact: kotlin.String?, nameIcontains: kotlin.String?, nameIexact: kotlin.String?, ordering: kotlin.String?, providersIsnull: kotlin.Boolean?, providersByPk: kotlin.collections.List<kotlin.Int>?, search: kotlin.String?, serviceConnectionNameIcontains: kotlin.String?, serviceConnectionNameIexact: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (managedIcontains != null) {
                    put("managed__icontains", listOf(managedIcontains.toString()))
                }
                if (managedIexact != null) {
                    put("managed__iexact", listOf(managedIexact.toString()))
                }
                if (nameIcontains != null) {
                    put("name__icontains", listOf(nameIcontains.toString()))
                }
                if (nameIexact != null) {
                    put("name__iexact", listOf(nameIexact.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (providersIsnull != null) {
                    put("providers__isnull", listOf(providersIsnull.toString()))
                }
                if (providersByPk != null) {
                    put("providers_by_pk", toMultiValue(providersByPk.toList(), "multi"))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (serviceConnectionNameIcontains != null) {
                    put("service_connection__name__icontains", listOf(serviceConnectionNameIcontains.toString()))
                }
                if (serviceConnectionNameIexact != null) {
                    put("service_connection__name__iexact", listOf(serviceConnectionNameIexact.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/instances/{uuid}/health/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Outpost Viewset
     * @param managedIcontains  (optional)
     * @param managedIexact  (optional)
     * @param nameIcontains  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param providersIsnull  (optional)
     * @param providersByPk  (optional)
     * @param search A search term. (optional)
     * @param serviceConnectionNameIcontains  (optional)
     * @param serviceConnectionNameIexact  (optional)
     * @return PaginatedOutpostList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsInstancesList(managedIcontains: kotlin.String? = null, managedIexact: kotlin.String? = null, nameIcontains: kotlin.String? = null, nameIexact: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, providersIsnull: kotlin.Boolean? = null, providersByPk: kotlin.collections.List<kotlin.Int>? = null, search: kotlin.String? = null, serviceConnectionNameIcontains: kotlin.String? = null, serviceConnectionNameIexact: kotlin.String? = null) : PaginatedOutpostList {
        val localVarResponse = outpostsInstancesListWithHttpInfo(managedIcontains = managedIcontains, managedIexact = managedIexact, nameIcontains = nameIcontains, nameIexact = nameIexact, ordering = ordering, page = page, pageSize = pageSize, providersIsnull = providersIsnull, providersByPk = providersByPk, search = search, serviceConnectionNameIcontains = serviceConnectionNameIcontains, serviceConnectionNameIexact = serviceConnectionNameIexact)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedOutpostList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Outpost Viewset
     * @param managedIcontains  (optional)
     * @param managedIexact  (optional)
     * @param nameIcontains  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param providersIsnull  (optional)
     * @param providersByPk  (optional)
     * @param search A search term. (optional)
     * @param serviceConnectionNameIcontains  (optional)
     * @param serviceConnectionNameIexact  (optional)
     * @return ApiResponse<PaginatedOutpostList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsInstancesListWithHttpInfo(managedIcontains: kotlin.String?, managedIexact: kotlin.String?, nameIcontains: kotlin.String?, nameIexact: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, providersIsnull: kotlin.Boolean?, providersByPk: kotlin.collections.List<kotlin.Int>?, search: kotlin.String?, serviceConnectionNameIcontains: kotlin.String?, serviceConnectionNameIexact: kotlin.String?) : ApiResponse<PaginatedOutpostList?> {
        val localVariableConfig = outpostsInstancesListRequestConfig(managedIcontains = managedIcontains, managedIexact = managedIexact, nameIcontains = nameIcontains, nameIexact = nameIexact, ordering = ordering, page = page, pageSize = pageSize, providersIsnull = providersIsnull, providersByPk = providersByPk, search = search, serviceConnectionNameIcontains = serviceConnectionNameIcontains, serviceConnectionNameIexact = serviceConnectionNameIexact)

        return request<Unit, PaginatedOutpostList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsInstancesList
     *
     * @param managedIcontains  (optional)
     * @param managedIexact  (optional)
     * @param nameIcontains  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param providersIsnull  (optional)
     * @param providersByPk  (optional)
     * @param search A search term. (optional)
     * @param serviceConnectionNameIcontains  (optional)
     * @param serviceConnectionNameIexact  (optional)
     * @return RequestConfig
     */
    fun outpostsInstancesListRequestConfig(managedIcontains: kotlin.String?, managedIexact: kotlin.String?, nameIcontains: kotlin.String?, nameIexact: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, providersIsnull: kotlin.Boolean?, providersByPk: kotlin.collections.List<kotlin.Int>?, search: kotlin.String?, serviceConnectionNameIcontains: kotlin.String?, serviceConnectionNameIexact: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (managedIcontains != null) {
                    put("managed__icontains", listOf(managedIcontains.toString()))
                }
                if (managedIexact != null) {
                    put("managed__iexact", listOf(managedIexact.toString()))
                }
                if (nameIcontains != null) {
                    put("name__icontains", listOf(nameIcontains.toString()))
                }
                if (nameIexact != null) {
                    put("name__iexact", listOf(nameIexact.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (providersIsnull != null) {
                    put("providers__isnull", listOf(providersIsnull.toString()))
                }
                if (providersByPk != null) {
                    put("providers_by_pk", toMultiValue(providersByPk.toList(), "multi"))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (serviceConnectionNameIcontains != null) {
                    put("service_connection__name__icontains", listOf(serviceConnectionNameIcontains.toString()))
                }
                if (serviceConnectionNameIexact != null) {
                    put("service_connection__name__iexact", listOf(serviceConnectionNameIexact.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/instances/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Outpost Viewset
     * @param uuid A UUID string identifying this Outpost.
     * @param patchedOutpostRequest  (optional)
     * @return Outpost
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsInstancesPartialUpdate(uuid: java.util.UUID, patchedOutpostRequest: PatchedOutpostRequest? = null) : Outpost {
        val localVarResponse = outpostsInstancesPartialUpdateWithHttpInfo(uuid = uuid, patchedOutpostRequest = patchedOutpostRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Outpost
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Outpost Viewset
     * @param uuid A UUID string identifying this Outpost.
     * @param patchedOutpostRequest  (optional)
     * @return ApiResponse<Outpost?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsInstancesPartialUpdateWithHttpInfo(uuid: java.util.UUID, patchedOutpostRequest: PatchedOutpostRequest?) : ApiResponse<Outpost?> {
        val localVariableConfig = outpostsInstancesPartialUpdateRequestConfig(uuid = uuid, patchedOutpostRequest = patchedOutpostRequest)

        return request<PatchedOutpostRequest, Outpost>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsInstancesPartialUpdate
     *
     * @param uuid A UUID string identifying this Outpost.
     * @param patchedOutpostRequest  (optional)
     * @return RequestConfig
     */
    fun outpostsInstancesPartialUpdateRequestConfig(uuid: java.util.UUID, patchedOutpostRequest: PatchedOutpostRequest?) : RequestConfig<PatchedOutpostRequest> {
        val localVariableBody = patchedOutpostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/outposts/instances/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Outpost Viewset
     * @param uuid A UUID string identifying this Outpost.
     * @return Outpost
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsInstancesRetrieve(uuid: java.util.UUID) : Outpost {
        val localVarResponse = outpostsInstancesRetrieveWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Outpost
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Outpost Viewset
     * @param uuid A UUID string identifying this Outpost.
     * @return ApiResponse<Outpost?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsInstancesRetrieveWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Outpost?> {
        val localVariableConfig = outpostsInstancesRetrieveRequestConfig(uuid = uuid)

        return request<Unit, Outpost>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsInstancesRetrieve
     *
     * @param uuid A UUID string identifying this Outpost.
     * @return RequestConfig
     */
    fun outpostsInstancesRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/instances/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Outpost Viewset
     * @param uuid A UUID string identifying this Outpost.
     * @param outpostRequest 
     * @return Outpost
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsInstancesUpdate(uuid: java.util.UUID, outpostRequest: OutpostRequest) : Outpost {
        val localVarResponse = outpostsInstancesUpdateWithHttpInfo(uuid = uuid, outpostRequest = outpostRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Outpost
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Outpost Viewset
     * @param uuid A UUID string identifying this Outpost.
     * @param outpostRequest 
     * @return ApiResponse<Outpost?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsInstancesUpdateWithHttpInfo(uuid: java.util.UUID, outpostRequest: OutpostRequest) : ApiResponse<Outpost?> {
        val localVariableConfig = outpostsInstancesUpdateRequestConfig(uuid = uuid, outpostRequest = outpostRequest)

        return request<OutpostRequest, Outpost>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsInstancesUpdate
     *
     * @param uuid A UUID string identifying this Outpost.
     * @param outpostRequest 
     * @return RequestConfig
     */
    fun outpostsInstancesUpdateRequestConfig(uuid: java.util.UUID, outpostRequest: OutpostRequest) : RequestConfig<OutpostRequest> {
        val localVariableBody = outpostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/outposts/instances/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Outpost.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsInstancesUsedByList(uuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = outpostsInstancesUsedByListWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Outpost.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsInstancesUsedByListWithHttpInfo(uuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = outpostsInstancesUsedByListRequestConfig(uuid = uuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsInstancesUsedByList
     *
     * @param uuid A UUID string identifying this Outpost.
     * @return RequestConfig
     */
    fun outpostsInstancesUsedByListRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/instances/{uuid}/used_by/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedLDAPOutpostConfigList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsLdapList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedLDAPOutpostConfigList {
        val localVarResponse = outpostsLdapListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedLDAPOutpostConfigList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedLDAPOutpostConfigList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsLdapListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedLDAPOutpostConfigList?> {
        val localVariableConfig = outpostsLdapListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedLDAPOutpostConfigList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsLdapList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun outpostsLdapListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/ldap/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param id A unique integer value identifying this LDAP Provider.
     * @return LDAPOutpostConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsLdapRetrieve(id: kotlin.Int) : LDAPOutpostConfig {
        val localVarResponse = outpostsLdapRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPOutpostConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param id A unique integer value identifying this LDAP Provider.
     * @return ApiResponse<LDAPOutpostConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsLdapRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<LDAPOutpostConfig?> {
        val localVariableConfig = outpostsLdapRetrieveRequestConfig(id = id)

        return request<Unit, LDAPOutpostConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsLdapRetrieve
     *
     * @param id A unique integer value identifying this LDAP Provider.
     * @return RequestConfig
     */
    fun outpostsLdapRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/ldap/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedProxyOutpostConfigList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsProxyList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedProxyOutpostConfigList {
        val localVarResponse = outpostsProxyListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedProxyOutpostConfigList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedProxyOutpostConfigList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsProxyListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedProxyOutpostConfigList?> {
        val localVariableConfig = outpostsProxyListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedProxyOutpostConfigList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsProxyList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun outpostsProxyListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/proxy/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param id A unique integer value identifying this Proxy Provider.
     * @return ProxyOutpostConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsProxyRetrieve(id: kotlin.Int) : ProxyOutpostConfig {
        val localVarResponse = outpostsProxyRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProxyOutpostConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param id A unique integer value identifying this Proxy Provider.
     * @return ApiResponse<ProxyOutpostConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsProxyRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<ProxyOutpostConfig?> {
        val localVariableConfig = outpostsProxyRetrieveRequestConfig(id = id)

        return request<Unit, ProxyOutpostConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsProxyRetrieve
     *
     * @param id A unique integer value identifying this Proxy Provider.
     * @return RequestConfig
     */
    fun outpostsProxyRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/proxy/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedRadiusOutpostConfigList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsRadiusList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedRadiusOutpostConfigList {
        val localVarResponse = outpostsRadiusListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedRadiusOutpostConfigList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedRadiusOutpostConfigList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsRadiusListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedRadiusOutpostConfigList?> {
        val localVariableConfig = outpostsRadiusListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedRadiusOutpostConfigList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsRadiusList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun outpostsRadiusListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/radius/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param id A unique integer value identifying this Radius Provider.
     * @return RadiusOutpostConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsRadiusRetrieve(id: kotlin.Int) : RadiusOutpostConfig {
        val localVarResponse = outpostsRadiusRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RadiusOutpostConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param id A unique integer value identifying this Radius Provider.
     * @return ApiResponse<RadiusOutpostConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsRadiusRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<RadiusOutpostConfig?> {
        val localVariableConfig = outpostsRadiusRetrieveRequestConfig(id = id)

        return request<Unit, RadiusOutpostConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsRadiusRetrieve
     *
     * @param id A unique integer value identifying this Radius Provider.
     * @return RequestConfig
     */
    fun outpostsRadiusRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/radius/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * ServiceConnection Viewset
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsAllDestroy(uuid: java.util.UUID) : Unit {
        val localVarResponse = outpostsServiceConnectionsAllDestroyWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ServiceConnection Viewset
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsAllDestroyWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = outpostsServiceConnectionsAllDestroyRequestConfig(uuid = uuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsAllDestroy
     *
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsAllDestroyRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/outposts/service_connections/all/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * ServiceConnection Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedServiceConnectionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsAllList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedServiceConnectionList {
        val localVarResponse = outpostsServiceConnectionsAllListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedServiceConnectionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ServiceConnection Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedServiceConnectionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsAllListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedServiceConnectionList?> {
        val localVariableConfig = outpostsServiceConnectionsAllListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedServiceConnectionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsAllList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsAllListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/service_connections/all/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * ServiceConnection Viewset
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return ServiceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsAllRetrieve(uuid: java.util.UUID) : ServiceConnection {
        val localVarResponse = outpostsServiceConnectionsAllRetrieveWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ServiceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ServiceConnection Viewset
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return ApiResponse<ServiceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsAllRetrieveWithHttpInfo(uuid: java.util.UUID) : ApiResponse<ServiceConnection?> {
        val localVariableConfig = outpostsServiceConnectionsAllRetrieveRequestConfig(uuid = uuid)

        return request<Unit, ServiceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsAllRetrieve
     *
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsAllRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/service_connections/all/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get the service connection&#39;s state
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return ServiceConnectionState
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsAllStateRetrieve(uuid: java.util.UUID) : ServiceConnectionState {
        val localVarResponse = outpostsServiceConnectionsAllStateRetrieveWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ServiceConnectionState
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get the service connection&#39;s state
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return ApiResponse<ServiceConnectionState?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsAllStateRetrieveWithHttpInfo(uuid: java.util.UUID) : ApiResponse<ServiceConnectionState?> {
        val localVariableConfig = outpostsServiceConnectionsAllStateRetrieveRequestConfig(uuid = uuid)

        return request<Unit, ServiceConnectionState>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsAllStateRetrieve
     *
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsAllStateRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/service_connections/all/{uuid}/state/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all creatable service connection types
     * @return kotlin.collections.List<TypeCreate>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsAllTypesList() : kotlin.collections.List<TypeCreate> {
        val localVarResponse = outpostsServiceConnectionsAllTypesListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TypeCreate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all creatable service connection types
     * @return ApiResponse<kotlin.collections.List<TypeCreate>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsAllTypesListWithHttpInfo() : ApiResponse<kotlin.collections.List<TypeCreate>?> {
        val localVariableConfig = outpostsServiceConnectionsAllTypesListRequestConfig()

        return request<Unit, kotlin.collections.List<TypeCreate>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsAllTypesList
     *
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsAllTypesListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/service_connections/all/types/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsAllUsedByList(uuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = outpostsServiceConnectionsAllUsedByListWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsAllUsedByListWithHttpInfo(uuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = outpostsServiceConnectionsAllUsedByListRequestConfig(uuid = uuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsAllUsedByList
     *
     * @param uuid A UUID string identifying this Outpost Service-Connection.
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsAllUsedByListRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/service_connections/all/{uuid}/used_by/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param dockerServiceConnectionRequest 
     * @return DockerServiceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsDockerCreate(dockerServiceConnectionRequest: DockerServiceConnectionRequest) : DockerServiceConnection {
        val localVarResponse = outpostsServiceConnectionsDockerCreateWithHttpInfo(dockerServiceConnectionRequest = dockerServiceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DockerServiceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param dockerServiceConnectionRequest 
     * @return ApiResponse<DockerServiceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsDockerCreateWithHttpInfo(dockerServiceConnectionRequest: DockerServiceConnectionRequest) : ApiResponse<DockerServiceConnection?> {
        val localVariableConfig = outpostsServiceConnectionsDockerCreateRequestConfig(dockerServiceConnectionRequest = dockerServiceConnectionRequest)

        return request<DockerServiceConnectionRequest, DockerServiceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsDockerCreate
     *
     * @param dockerServiceConnectionRequest 
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsDockerCreateRequestConfig(dockerServiceConnectionRequest: DockerServiceConnectionRequest) : RequestConfig<DockerServiceConnectionRequest> {
        val localVariableBody = dockerServiceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/outposts/service_connections/docker/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsDockerDestroy(uuid: java.util.UUID) : Unit {
        val localVarResponse = outpostsServiceConnectionsDockerDestroyWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsDockerDestroyWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = outpostsServiceConnectionsDockerDestroyRequestConfig(uuid = uuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsDockerDestroy
     *
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsDockerDestroyRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/outposts/service_connections/docker/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param local  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param tlsAuthentication  (optional)
     * @param tlsVerification  (optional)
     * @param url  (optional)
     * @return PaginatedDockerServiceConnectionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsDockerList(local: kotlin.Boolean? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, tlsAuthentication: java.util.UUID? = null, tlsVerification: java.util.UUID? = null, url: kotlin.String? = null) : PaginatedDockerServiceConnectionList {
        val localVarResponse = outpostsServiceConnectionsDockerListWithHttpInfo(local = local, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, tlsAuthentication = tlsAuthentication, tlsVerification = tlsVerification, url = url)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDockerServiceConnectionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param local  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param tlsAuthentication  (optional)
     * @param tlsVerification  (optional)
     * @param url  (optional)
     * @return ApiResponse<PaginatedDockerServiceConnectionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsDockerListWithHttpInfo(local: kotlin.Boolean?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, tlsAuthentication: java.util.UUID?, tlsVerification: java.util.UUID?, url: kotlin.String?) : ApiResponse<PaginatedDockerServiceConnectionList?> {
        val localVariableConfig = outpostsServiceConnectionsDockerListRequestConfig(local = local, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, tlsAuthentication = tlsAuthentication, tlsVerification = tlsVerification, url = url)

        return request<Unit, PaginatedDockerServiceConnectionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsDockerList
     *
     * @param local  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param tlsAuthentication  (optional)
     * @param tlsVerification  (optional)
     * @param url  (optional)
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsDockerListRequestConfig(local: kotlin.Boolean?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, tlsAuthentication: java.util.UUID?, tlsVerification: java.util.UUID?, url: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (local != null) {
                    put("local", listOf(local.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (tlsAuthentication != null) {
                    put("tls_authentication", listOf(tlsAuthentication.toString()))
                }
                if (tlsVerification != null) {
                    put("tls_verification", listOf(tlsVerification.toString()))
                }
                if (url != null) {
                    put("url", listOf(url.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/service_connections/docker/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @param patchedDockerServiceConnectionRequest  (optional)
     * @return DockerServiceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsDockerPartialUpdate(uuid: java.util.UUID, patchedDockerServiceConnectionRequest: PatchedDockerServiceConnectionRequest? = null) : DockerServiceConnection {
        val localVarResponse = outpostsServiceConnectionsDockerPartialUpdateWithHttpInfo(uuid = uuid, patchedDockerServiceConnectionRequest = patchedDockerServiceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DockerServiceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @param patchedDockerServiceConnectionRequest  (optional)
     * @return ApiResponse<DockerServiceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsDockerPartialUpdateWithHttpInfo(uuid: java.util.UUID, patchedDockerServiceConnectionRequest: PatchedDockerServiceConnectionRequest?) : ApiResponse<DockerServiceConnection?> {
        val localVariableConfig = outpostsServiceConnectionsDockerPartialUpdateRequestConfig(uuid = uuid, patchedDockerServiceConnectionRequest = patchedDockerServiceConnectionRequest)

        return request<PatchedDockerServiceConnectionRequest, DockerServiceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsDockerPartialUpdate
     *
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @param patchedDockerServiceConnectionRequest  (optional)
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsDockerPartialUpdateRequestConfig(uuid: java.util.UUID, patchedDockerServiceConnectionRequest: PatchedDockerServiceConnectionRequest?) : RequestConfig<PatchedDockerServiceConnectionRequest> {
        val localVariableBody = patchedDockerServiceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/outposts/service_connections/docker/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @return DockerServiceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsDockerRetrieve(uuid: java.util.UUID) : DockerServiceConnection {
        val localVarResponse = outpostsServiceConnectionsDockerRetrieveWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DockerServiceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @return ApiResponse<DockerServiceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsDockerRetrieveWithHttpInfo(uuid: java.util.UUID) : ApiResponse<DockerServiceConnection?> {
        val localVariableConfig = outpostsServiceConnectionsDockerRetrieveRequestConfig(uuid = uuid)

        return request<Unit, DockerServiceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsDockerRetrieve
     *
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsDockerRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/service_connections/docker/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @param dockerServiceConnectionRequest 
     * @return DockerServiceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsDockerUpdate(uuid: java.util.UUID, dockerServiceConnectionRequest: DockerServiceConnectionRequest) : DockerServiceConnection {
        val localVarResponse = outpostsServiceConnectionsDockerUpdateWithHttpInfo(uuid = uuid, dockerServiceConnectionRequest = dockerServiceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DockerServiceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DockerServiceConnection Viewset
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @param dockerServiceConnectionRequest 
     * @return ApiResponse<DockerServiceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsDockerUpdateWithHttpInfo(uuid: java.util.UUID, dockerServiceConnectionRequest: DockerServiceConnectionRequest) : ApiResponse<DockerServiceConnection?> {
        val localVariableConfig = outpostsServiceConnectionsDockerUpdateRequestConfig(uuid = uuid, dockerServiceConnectionRequest = dockerServiceConnectionRequest)

        return request<DockerServiceConnectionRequest, DockerServiceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsDockerUpdate
     *
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @param dockerServiceConnectionRequest 
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsDockerUpdateRequestConfig(uuid: java.util.UUID, dockerServiceConnectionRequest: DockerServiceConnectionRequest) : RequestConfig<DockerServiceConnectionRequest> {
        val localVariableBody = dockerServiceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/outposts/service_connections/docker/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsDockerUsedByList(uuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = outpostsServiceConnectionsDockerUsedByListWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsDockerUsedByListWithHttpInfo(uuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = outpostsServiceConnectionsDockerUsedByListRequestConfig(uuid = uuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsDockerUsedByList
     *
     * @param uuid A UUID string identifying this Docker Service-Connection.
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsDockerUsedByListRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/service_connections/docker/{uuid}/used_by/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param kubernetesServiceConnectionRequest 
     * @return KubernetesServiceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsKubernetesCreate(kubernetesServiceConnectionRequest: KubernetesServiceConnectionRequest) : KubernetesServiceConnection {
        val localVarResponse = outpostsServiceConnectionsKubernetesCreateWithHttpInfo(kubernetesServiceConnectionRequest = kubernetesServiceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as KubernetesServiceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param kubernetesServiceConnectionRequest 
     * @return ApiResponse<KubernetesServiceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsKubernetesCreateWithHttpInfo(kubernetesServiceConnectionRequest: KubernetesServiceConnectionRequest) : ApiResponse<KubernetesServiceConnection?> {
        val localVariableConfig = outpostsServiceConnectionsKubernetesCreateRequestConfig(kubernetesServiceConnectionRequest = kubernetesServiceConnectionRequest)

        return request<KubernetesServiceConnectionRequest, KubernetesServiceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsKubernetesCreate
     *
     * @param kubernetesServiceConnectionRequest 
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsKubernetesCreateRequestConfig(kubernetesServiceConnectionRequest: KubernetesServiceConnectionRequest) : RequestConfig<KubernetesServiceConnectionRequest> {
        val localVariableBody = kubernetesServiceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/outposts/service_connections/kubernetes/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsKubernetesDestroy(uuid: java.util.UUID) : Unit {
        val localVarResponse = outpostsServiceConnectionsKubernetesDestroyWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsKubernetesDestroyWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = outpostsServiceConnectionsKubernetesDestroyRequestConfig(uuid = uuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsKubernetesDestroy
     *
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsKubernetesDestroyRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/outposts/service_connections/kubernetes/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param local  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedKubernetesServiceConnectionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsKubernetesList(local: kotlin.Boolean? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedKubernetesServiceConnectionList {
        val localVarResponse = outpostsServiceConnectionsKubernetesListWithHttpInfo(local = local, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedKubernetesServiceConnectionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param local  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedKubernetesServiceConnectionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsKubernetesListWithHttpInfo(local: kotlin.Boolean?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedKubernetesServiceConnectionList?> {
        val localVariableConfig = outpostsServiceConnectionsKubernetesListRequestConfig(local = local, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedKubernetesServiceConnectionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsKubernetesList
     *
     * @param local  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsKubernetesListRequestConfig(local: kotlin.Boolean?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (local != null) {
                    put("local", listOf(local.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/service_connections/kubernetes/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @param patchedKubernetesServiceConnectionRequest  (optional)
     * @return KubernetesServiceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsKubernetesPartialUpdate(uuid: java.util.UUID, patchedKubernetesServiceConnectionRequest: PatchedKubernetesServiceConnectionRequest? = null) : KubernetesServiceConnection {
        val localVarResponse = outpostsServiceConnectionsKubernetesPartialUpdateWithHttpInfo(uuid = uuid, patchedKubernetesServiceConnectionRequest = patchedKubernetesServiceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as KubernetesServiceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @param patchedKubernetesServiceConnectionRequest  (optional)
     * @return ApiResponse<KubernetesServiceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsKubernetesPartialUpdateWithHttpInfo(uuid: java.util.UUID, patchedKubernetesServiceConnectionRequest: PatchedKubernetesServiceConnectionRequest?) : ApiResponse<KubernetesServiceConnection?> {
        val localVariableConfig = outpostsServiceConnectionsKubernetesPartialUpdateRequestConfig(uuid = uuid, patchedKubernetesServiceConnectionRequest = patchedKubernetesServiceConnectionRequest)

        return request<PatchedKubernetesServiceConnectionRequest, KubernetesServiceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsKubernetesPartialUpdate
     *
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @param patchedKubernetesServiceConnectionRequest  (optional)
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsKubernetesPartialUpdateRequestConfig(uuid: java.util.UUID, patchedKubernetesServiceConnectionRequest: PatchedKubernetesServiceConnectionRequest?) : RequestConfig<PatchedKubernetesServiceConnectionRequest> {
        val localVariableBody = patchedKubernetesServiceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/outposts/service_connections/kubernetes/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @return KubernetesServiceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsKubernetesRetrieve(uuid: java.util.UUID) : KubernetesServiceConnection {
        val localVarResponse = outpostsServiceConnectionsKubernetesRetrieveWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as KubernetesServiceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @return ApiResponse<KubernetesServiceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsKubernetesRetrieveWithHttpInfo(uuid: java.util.UUID) : ApiResponse<KubernetesServiceConnection?> {
        val localVariableConfig = outpostsServiceConnectionsKubernetesRetrieveRequestConfig(uuid = uuid)

        return request<Unit, KubernetesServiceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsKubernetesRetrieve
     *
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsKubernetesRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/service_connections/kubernetes/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @param kubernetesServiceConnectionRequest 
     * @return KubernetesServiceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsKubernetesUpdate(uuid: java.util.UUID, kubernetesServiceConnectionRequest: KubernetesServiceConnectionRequest) : KubernetesServiceConnection {
        val localVarResponse = outpostsServiceConnectionsKubernetesUpdateWithHttpInfo(uuid = uuid, kubernetesServiceConnectionRequest = kubernetesServiceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as KubernetesServiceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * KubernetesServiceConnection Viewset
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @param kubernetesServiceConnectionRequest 
     * @return ApiResponse<KubernetesServiceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsKubernetesUpdateWithHttpInfo(uuid: java.util.UUID, kubernetesServiceConnectionRequest: KubernetesServiceConnectionRequest) : ApiResponse<KubernetesServiceConnection?> {
        val localVariableConfig = outpostsServiceConnectionsKubernetesUpdateRequestConfig(uuid = uuid, kubernetesServiceConnectionRequest = kubernetesServiceConnectionRequest)

        return request<KubernetesServiceConnectionRequest, KubernetesServiceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsKubernetesUpdate
     *
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @param kubernetesServiceConnectionRequest 
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsKubernetesUpdateRequestConfig(uuid: java.util.UUID, kubernetesServiceConnectionRequest: KubernetesServiceConnectionRequest) : RequestConfig<KubernetesServiceConnectionRequest> {
        val localVariableBody = kubernetesServiceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/outposts/service_connections/kubernetes/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun outpostsServiceConnectionsKubernetesUsedByList(uuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = outpostsServiceConnectionsKubernetesUsedByListWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun outpostsServiceConnectionsKubernetesUsedByListWithHttpInfo(uuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = outpostsServiceConnectionsKubernetesUsedByListRequestConfig(uuid = uuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation outpostsServiceConnectionsKubernetesUsedByList
     *
     * @param uuid A UUID string identifying this Kubernetes Service-Connection.
     * @return RequestConfig
     */
    fun outpostsServiceConnectionsKubernetesUsedByListRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/outposts/service_connections/kubernetes/{uuid}/used_by/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
