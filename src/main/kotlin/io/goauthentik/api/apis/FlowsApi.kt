/**
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2023.10.1
 * Contact: hello@goauthentik.io
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.Cache
import io.goauthentik.api.models.ChallengeTypes
import io.goauthentik.api.models.FilePathRequest
import io.goauthentik.api.models.Flow
import io.goauthentik.api.models.FlowChallengeResponseRequest
import io.goauthentik.api.models.FlowDiagram
import io.goauthentik.api.models.FlowImportResult
import io.goauthentik.api.models.FlowInspection
import io.goauthentik.api.models.FlowRequest
import io.goauthentik.api.models.FlowStageBinding
import io.goauthentik.api.models.FlowStageBindingRequest
import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.Link
import io.goauthentik.api.models.PaginatedFlowList
import io.goauthentik.api.models.PaginatedFlowStageBindingList
import io.goauthentik.api.models.PatchedFlowRequest
import io.goauthentik.api.models.PatchedFlowStageBindingRequest
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.ValidationError

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class FlowsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * FlowStageBinding Viewset
     * @param flowStageBindingRequest 
     * @return FlowStageBinding
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsBindingsCreate(flowStageBindingRequest: FlowStageBindingRequest) : FlowStageBinding {
        val localVarResponse = flowsBindingsCreateWithHttpInfo(flowStageBindingRequest = flowStageBindingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FlowStageBinding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * FlowStageBinding Viewset
     * @param flowStageBindingRequest 
     * @return ApiResponse<FlowStageBinding?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsBindingsCreateWithHttpInfo(flowStageBindingRequest: FlowStageBindingRequest) : ApiResponse<FlowStageBinding?> {
        val localVariableConfig = flowsBindingsCreateRequestConfig(flowStageBindingRequest = flowStageBindingRequest)

        return request<FlowStageBindingRequest, FlowStageBinding>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsBindingsCreate
     *
     * @param flowStageBindingRequest 
     * @return RequestConfig
     */
    fun flowsBindingsCreateRequestConfig(flowStageBindingRequest: FlowStageBindingRequest) : RequestConfig<FlowStageBindingRequest> {
        val localVariableBody = flowStageBindingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/flows/bindings/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * FlowStageBinding Viewset
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsBindingsDestroy(fsbUuid: java.util.UUID) : Unit {
        val localVarResponse = flowsBindingsDestroyWithHttpInfo(fsbUuid = fsbUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * FlowStageBinding Viewset
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsBindingsDestroyWithHttpInfo(fsbUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = flowsBindingsDestroyRequestConfig(fsbUuid = fsbUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsBindingsDestroy
     *
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @return RequestConfig
     */
    fun flowsBindingsDestroyRequestConfig(fsbUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/flows/bindings/{fsb_uuid}/".replace("{"+"fsb_uuid"+"}", encodeURIComponent(fsbUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter invalidResponseAction
     */
     enum class InvalidResponseAction_flowsBindingsList(val value: kotlin.String) {
         @Json(name = "restart") restart("restart"),
         @Json(name = "restart_with_context") restartWithContext("restart_with_context"),
         @Json(name = "retry") retry("retry"),
     }

    /**
     * enum for parameter policyEngineMode
     */
     enum class PolicyEngineMode_flowsBindingsList(val value: kotlin.String) {
         @Json(name = "all") all("all"),
         @Json(name = "any") any("any"),
     }

    /**
     * 
     * FlowStageBinding Viewset
     * @param evaluateOnPlan  (optional)
     * @param fsbUuid  (optional)
     * @param invalidResponseAction Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.  * &#x60;retry&#x60; - Retry * &#x60;restart&#x60; - Restart * &#x60;restart_with_context&#x60; - Restart With Context (optional)
     * @param order  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pbmUuid  (optional)
     * @param policies  (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param reEvaluatePolicies  (optional)
     * @param search A search term. (optional)
     * @param stage  (optional)
     * @param target  (optional)
     * @return PaginatedFlowStageBindingList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsBindingsList(evaluateOnPlan: kotlin.Boolean? = null, fsbUuid: java.util.UUID? = null, invalidResponseAction: InvalidResponseAction_flowsBindingsList? = null, order: kotlin.Int? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, pbmUuid: java.util.UUID? = null, policies: kotlin.collections.List<java.util.UUID>? = null, policyEngineMode: PolicyEngineMode_flowsBindingsList? = null, reEvaluatePolicies: kotlin.Boolean? = null, search: kotlin.String? = null, stage: java.util.UUID? = null, target: java.util.UUID? = null) : PaginatedFlowStageBindingList {
        val localVarResponse = flowsBindingsListWithHttpInfo(evaluateOnPlan = evaluateOnPlan, fsbUuid = fsbUuid, invalidResponseAction = invalidResponseAction, order = order, ordering = ordering, page = page, pageSize = pageSize, pbmUuid = pbmUuid, policies = policies, policyEngineMode = policyEngineMode, reEvaluatePolicies = reEvaluatePolicies, search = search, stage = stage, target = target)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedFlowStageBindingList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * FlowStageBinding Viewset
     * @param evaluateOnPlan  (optional)
     * @param fsbUuid  (optional)
     * @param invalidResponseAction Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.  * &#x60;retry&#x60; - Retry * &#x60;restart&#x60; - Restart * &#x60;restart_with_context&#x60; - Restart With Context (optional)
     * @param order  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pbmUuid  (optional)
     * @param policies  (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param reEvaluatePolicies  (optional)
     * @param search A search term. (optional)
     * @param stage  (optional)
     * @param target  (optional)
     * @return ApiResponse<PaginatedFlowStageBindingList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsBindingsListWithHttpInfo(evaluateOnPlan: kotlin.Boolean?, fsbUuid: java.util.UUID?, invalidResponseAction: InvalidResponseAction_flowsBindingsList?, order: kotlin.Int?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, pbmUuid: java.util.UUID?, policies: kotlin.collections.List<java.util.UUID>?, policyEngineMode: PolicyEngineMode_flowsBindingsList?, reEvaluatePolicies: kotlin.Boolean?, search: kotlin.String?, stage: java.util.UUID?, target: java.util.UUID?) : ApiResponse<PaginatedFlowStageBindingList?> {
        val localVariableConfig = flowsBindingsListRequestConfig(evaluateOnPlan = evaluateOnPlan, fsbUuid = fsbUuid, invalidResponseAction = invalidResponseAction, order = order, ordering = ordering, page = page, pageSize = pageSize, pbmUuid = pbmUuid, policies = policies, policyEngineMode = policyEngineMode, reEvaluatePolicies = reEvaluatePolicies, search = search, stage = stage, target = target)

        return request<Unit, PaginatedFlowStageBindingList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsBindingsList
     *
     * @param evaluateOnPlan  (optional)
     * @param fsbUuid  (optional)
     * @param invalidResponseAction Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.  * &#x60;retry&#x60; - Retry * &#x60;restart&#x60; - Restart * &#x60;restart_with_context&#x60; - Restart With Context (optional)
     * @param order  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pbmUuid  (optional)
     * @param policies  (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param reEvaluatePolicies  (optional)
     * @param search A search term. (optional)
     * @param stage  (optional)
     * @param target  (optional)
     * @return RequestConfig
     */
    fun flowsBindingsListRequestConfig(evaluateOnPlan: kotlin.Boolean?, fsbUuid: java.util.UUID?, invalidResponseAction: InvalidResponseAction_flowsBindingsList?, order: kotlin.Int?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, pbmUuid: java.util.UUID?, policies: kotlin.collections.List<java.util.UUID>?, policyEngineMode: PolicyEngineMode_flowsBindingsList?, reEvaluatePolicies: kotlin.Boolean?, search: kotlin.String?, stage: java.util.UUID?, target: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (evaluateOnPlan != null) {
                    put("evaluate_on_plan", listOf(evaluateOnPlan.toString()))
                }
                if (fsbUuid != null) {
                    put("fsb_uuid", listOf(fsbUuid.toString()))
                }
                if (invalidResponseAction != null) {
                    put("invalid_response_action", listOf(invalidResponseAction.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (pbmUuid != null) {
                    put("pbm_uuid", listOf(pbmUuid.toString()))
                }
                if (policies != null) {
                    put("policies", toMultiValue(policies.toList(), "multi"))
                }
                if (policyEngineMode != null) {
                    put("policy_engine_mode", listOf(policyEngineMode.toString()))
                }
                if (reEvaluatePolicies != null) {
                    put("re_evaluate_policies", listOf(reEvaluatePolicies.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stage != null) {
                    put("stage", listOf(stage.toString()))
                }
                if (target != null) {
                    put("target", listOf(target.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/bindings/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * FlowStageBinding Viewset
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @param patchedFlowStageBindingRequest  (optional)
     * @return FlowStageBinding
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsBindingsPartialUpdate(fsbUuid: java.util.UUID, patchedFlowStageBindingRequest: PatchedFlowStageBindingRequest? = null) : FlowStageBinding {
        val localVarResponse = flowsBindingsPartialUpdateWithHttpInfo(fsbUuid = fsbUuid, patchedFlowStageBindingRequest = patchedFlowStageBindingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FlowStageBinding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * FlowStageBinding Viewset
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @param patchedFlowStageBindingRequest  (optional)
     * @return ApiResponse<FlowStageBinding?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsBindingsPartialUpdateWithHttpInfo(fsbUuid: java.util.UUID, patchedFlowStageBindingRequest: PatchedFlowStageBindingRequest?) : ApiResponse<FlowStageBinding?> {
        val localVariableConfig = flowsBindingsPartialUpdateRequestConfig(fsbUuid = fsbUuid, patchedFlowStageBindingRequest = patchedFlowStageBindingRequest)

        return request<PatchedFlowStageBindingRequest, FlowStageBinding>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsBindingsPartialUpdate
     *
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @param patchedFlowStageBindingRequest  (optional)
     * @return RequestConfig
     */
    fun flowsBindingsPartialUpdateRequestConfig(fsbUuid: java.util.UUID, patchedFlowStageBindingRequest: PatchedFlowStageBindingRequest?) : RequestConfig<PatchedFlowStageBindingRequest> {
        val localVariableBody = patchedFlowStageBindingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/flows/bindings/{fsb_uuid}/".replace("{"+"fsb_uuid"+"}", encodeURIComponent(fsbUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * FlowStageBinding Viewset
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @return FlowStageBinding
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsBindingsRetrieve(fsbUuid: java.util.UUID) : FlowStageBinding {
        val localVarResponse = flowsBindingsRetrieveWithHttpInfo(fsbUuid = fsbUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FlowStageBinding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * FlowStageBinding Viewset
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @return ApiResponse<FlowStageBinding?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsBindingsRetrieveWithHttpInfo(fsbUuid: java.util.UUID) : ApiResponse<FlowStageBinding?> {
        val localVariableConfig = flowsBindingsRetrieveRequestConfig(fsbUuid = fsbUuid)

        return request<Unit, FlowStageBinding>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsBindingsRetrieve
     *
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @return RequestConfig
     */
    fun flowsBindingsRetrieveRequestConfig(fsbUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/bindings/{fsb_uuid}/".replace("{"+"fsb_uuid"+"}", encodeURIComponent(fsbUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * FlowStageBinding Viewset
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @param flowStageBindingRequest 
     * @return FlowStageBinding
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsBindingsUpdate(fsbUuid: java.util.UUID, flowStageBindingRequest: FlowStageBindingRequest) : FlowStageBinding {
        val localVarResponse = flowsBindingsUpdateWithHttpInfo(fsbUuid = fsbUuid, flowStageBindingRequest = flowStageBindingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FlowStageBinding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * FlowStageBinding Viewset
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @param flowStageBindingRequest 
     * @return ApiResponse<FlowStageBinding?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsBindingsUpdateWithHttpInfo(fsbUuid: java.util.UUID, flowStageBindingRequest: FlowStageBindingRequest) : ApiResponse<FlowStageBinding?> {
        val localVariableConfig = flowsBindingsUpdateRequestConfig(fsbUuid = fsbUuid, flowStageBindingRequest = flowStageBindingRequest)

        return request<FlowStageBindingRequest, FlowStageBinding>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsBindingsUpdate
     *
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @param flowStageBindingRequest 
     * @return RequestConfig
     */
    fun flowsBindingsUpdateRequestConfig(fsbUuid: java.util.UUID, flowStageBindingRequest: FlowStageBindingRequest) : RequestConfig<FlowStageBindingRequest> {
        val localVariableBody = flowStageBindingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/flows/bindings/{fsb_uuid}/".replace("{"+"fsb_uuid"+"}", encodeURIComponent(fsbUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsBindingsUsedByList(fsbUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = flowsBindingsUsedByListWithHttpInfo(fsbUuid = fsbUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsBindingsUsedByListWithHttpInfo(fsbUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = flowsBindingsUsedByListRequestConfig(fsbUuid = fsbUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsBindingsUsedByList
     *
     * @param fsbUuid A UUID string identifying this Flow Stage Binding.
     * @return RequestConfig
     */
    fun flowsBindingsUsedByListRequestConfig(fsbUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/bindings/{fsb_uuid}/used_by/".replace("{"+"fsb_uuid"+"}", encodeURIComponent(fsbUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get the next pending challenge from the currently active flow.
     * @param flowSlug 
     * @param query Querystring as received
     * @return ChallengeTypes
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsExecutorGet(flowSlug: kotlin.String, query: kotlin.String) : ChallengeTypes {
        val localVarResponse = flowsExecutorGetWithHttpInfo(flowSlug = flowSlug, query = query)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ChallengeTypes
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get the next pending challenge from the currently active flow.
     * @param flowSlug 
     * @param query Querystring as received
     * @return ApiResponse<ChallengeTypes?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsExecutorGetWithHttpInfo(flowSlug: kotlin.String, query: kotlin.String) : ApiResponse<ChallengeTypes?> {
        val localVariableConfig = flowsExecutorGetRequestConfig(flowSlug = flowSlug, query = query)

        return request<Unit, ChallengeTypes>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsExecutorGet
     *
     * @param flowSlug 
     * @param query Querystring as received
     * @return RequestConfig
     */
    fun flowsExecutorGetRequestConfig(flowSlug: kotlin.String, query: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("query", listOf(query.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/executor/{flow_slug}/".replace("{"+"flow_slug"+"}", encodeURIComponent(flowSlug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Solve the previously retrieved challenge and advanced to the next stage.
     * @param flowSlug 
     * @param query Querystring as received
     * @param flowChallengeResponseRequest  (optional)
     * @return ChallengeTypes
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsExecutorSolve(flowSlug: kotlin.String, query: kotlin.String, flowChallengeResponseRequest: FlowChallengeResponseRequest? = null) : ChallengeTypes {
        val localVarResponse = flowsExecutorSolveWithHttpInfo(flowSlug = flowSlug, query = query, flowChallengeResponseRequest = flowChallengeResponseRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ChallengeTypes
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Solve the previously retrieved challenge and advanced to the next stage.
     * @param flowSlug 
     * @param query Querystring as received
     * @param flowChallengeResponseRequest  (optional)
     * @return ApiResponse<ChallengeTypes?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsExecutorSolveWithHttpInfo(flowSlug: kotlin.String, query: kotlin.String, flowChallengeResponseRequest: FlowChallengeResponseRequest?) : ApiResponse<ChallengeTypes?> {
        val localVariableConfig = flowsExecutorSolveRequestConfig(flowSlug = flowSlug, query = query, flowChallengeResponseRequest = flowChallengeResponseRequest)

        return request<FlowChallengeResponseRequest, ChallengeTypes>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsExecutorSolve
     *
     * @param flowSlug 
     * @param query Querystring as received
     * @param flowChallengeResponseRequest  (optional)
     * @return RequestConfig
     */
    fun flowsExecutorSolveRequestConfig(flowSlug: kotlin.String, query: kotlin.String, flowChallengeResponseRequest: FlowChallengeResponseRequest?) : RequestConfig<FlowChallengeResponseRequest> {
        val localVariableBody = flowChallengeResponseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("query", listOf(query.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/flows/executor/{flow_slug}/".replace("{"+"flow_slug"+"}", encodeURIComponent(flowSlug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get current flow state and record it
     * @param flowSlug 
     * @return FlowInspection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInspectorGet(flowSlug: kotlin.String) : FlowInspection {
        val localVarResponse = flowsInspectorGetWithHttpInfo(flowSlug = flowSlug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FlowInspection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get current flow state and record it
     * @param flowSlug 
     * @return ApiResponse<FlowInspection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInspectorGetWithHttpInfo(flowSlug: kotlin.String) : ApiResponse<FlowInspection?> {
        val localVariableConfig = flowsInspectorGetRequestConfig(flowSlug = flowSlug)

        return request<Unit, FlowInspection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInspectorGet
     *
     * @param flowSlug 
     * @return RequestConfig
     */
    fun flowsInspectorGetRequestConfig(flowSlug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/inspector/{flow_slug}/".replace("{"+"flow_slug"+"}", encodeURIComponent(flowSlug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Clear flow cache
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesCacheClearCreate() : Unit {
        val localVarResponse = flowsInstancesCacheClearCreateWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Clear flow cache
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesCacheClearCreateWithHttpInfo() : ApiResponse<Unit?> {
        val localVariableConfig = flowsInstancesCacheClearCreateRequestConfig()

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesCacheClearCreate
     *
     * @return RequestConfig
     */
    fun flowsInstancesCacheClearCreateRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/flows/instances/cache_clear/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Info about cached flows
     * @return Cache
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesCacheInfoRetrieve() : Cache {
        val localVarResponse = flowsInstancesCacheInfoRetrieveWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Cache
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Info about cached flows
     * @return ApiResponse<Cache?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesCacheInfoRetrieveWithHttpInfo() : ApiResponse<Cache?> {
        val localVariableConfig = flowsInstancesCacheInfoRetrieveRequestConfig()

        return request<Unit, Cache>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesCacheInfoRetrieve
     *
     * @return RequestConfig
     */
    fun flowsInstancesCacheInfoRetrieveRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/instances/cache_info/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Flow Viewset
     * @param flowRequest 
     * @return Flow
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesCreate(flowRequest: FlowRequest) : Flow {
        val localVarResponse = flowsInstancesCreateWithHttpInfo(flowRequest = flowRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Flow
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Flow Viewset
     * @param flowRequest 
     * @return ApiResponse<Flow?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesCreateWithHttpInfo(flowRequest: FlowRequest) : ApiResponse<Flow?> {
        val localVariableConfig = flowsInstancesCreateRequestConfig(flowRequest = flowRequest)

        return request<FlowRequest, Flow>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesCreate
     *
     * @param flowRequest 
     * @return RequestConfig
     */
    fun flowsInstancesCreateRequestConfig(flowRequest: FlowRequest) : RequestConfig<FlowRequest> {
        val localVariableBody = flowRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/flows/instances/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Flow Viewset
     * @param slug 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesDestroy(slug: kotlin.String) : Unit {
        val localVarResponse = flowsInstancesDestroyWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Flow Viewset
     * @param slug 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesDestroyWithHttpInfo(slug: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = flowsInstancesDestroyRequestConfig(slug = slug)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesDestroy
     *
     * @param slug 
     * @return RequestConfig
     */
    fun flowsInstancesDestroyRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/flows/instances/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Return diagram for flow with slug &#x60;slug&#x60;, in the format used by flowchart.js
     * @param slug 
     * @return FlowDiagram
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesDiagramRetrieve(slug: kotlin.String) : FlowDiagram {
        val localVarResponse = flowsInstancesDiagramRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FlowDiagram
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Return diagram for flow with slug &#x60;slug&#x60;, in the format used by flowchart.js
     * @param slug 
     * @return ApiResponse<FlowDiagram?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesDiagramRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<FlowDiagram?> {
        val localVariableConfig = flowsInstancesDiagramRetrieveRequestConfig(slug = slug)

        return request<Unit, FlowDiagram>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesDiagramRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun flowsInstancesDiagramRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/instances/{slug}/diagram/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Execute flow for current user
     * @param slug 
     * @return Link
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesExecuteRetrieve(slug: kotlin.String) : Link {
        val localVarResponse = flowsInstancesExecuteRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Link
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Execute flow for current user
     * @param slug 
     * @return ApiResponse<Link?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesExecuteRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<Link?> {
        val localVariableConfig = flowsInstancesExecuteRetrieveRequestConfig(slug = slug)

        return request<Unit, Link>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesExecuteRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun flowsInstancesExecuteRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/instances/{slug}/execute/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Export flow to .yaml file
     * @param slug 
     * @return java.io.File
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesExportRetrieve(slug: kotlin.String) : java.io.File {
        val localVarResponse = flowsInstancesExportRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Export flow to .yaml file
     * @param slug 
     * @return ApiResponse<java.io.File?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesExportRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<java.io.File?> {
        val localVariableConfig = flowsInstancesExportRetrieveRequestConfig(slug = slug)

        return request<Unit, java.io.File>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesExportRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun flowsInstancesExportRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/instances/{slug}/export/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Import flow from .yaml file
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return FlowImportResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesImportCreate(file: java.io.File? = null, clear: kotlin.Boolean? = false) : FlowImportResult {
        val localVarResponse = flowsInstancesImportCreateWithHttpInfo(file = file, clear = clear)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FlowImportResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Import flow from .yaml file
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return ApiResponse<FlowImportResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesImportCreateWithHttpInfo(file: java.io.File?, clear: kotlin.Boolean?) : ApiResponse<FlowImportResult?> {
        val localVariableConfig = flowsInstancesImportCreateRequestConfig(file = file, clear = clear)

        return request<Map<String, PartConfig<*>>, FlowImportResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesImportCreate
     *
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return RequestConfig
     */
    fun flowsInstancesImportCreateRequestConfig(file: java.io.File?, clear: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "clear" to PartConfig(body = clear, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/flows/instances/import/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter deniedAction
     */
     enum class DeniedAction_flowsInstancesList(val value: kotlin.String) {
         @Json(name = "continue") `continue`("continue"),
         @Json(name = "message") message("message"),
         @Json(name = "message_continue") messageContinue("message_continue"),
     }

    /**
     * enum for parameter designation
     */
     enum class Designation_flowsInstancesList(val value: kotlin.String) {
         @Json(name = "authentication") authentication("authentication"),
         @Json(name = "authorization") authorization("authorization"),
         @Json(name = "enrollment") enrollment("enrollment"),
         @Json(name = "invalidation") invalidation("invalidation"),
         @Json(name = "recovery") recovery("recovery"),
         @Json(name = "stage_configuration") stageConfiguration("stage_configuration"),
         @Json(name = "unenrollment") unenrollment("unenrollment"),
     }

    /**
     * 
     * Flow Viewset
     * @param deniedAction Configure what should happen when a flow denies access to a user.  * &#x60;message_continue&#x60; - Message Continue * &#x60;message&#x60; - Message * &#x60;continue&#x60; - Continue (optional)
     * @param designation Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.  * &#x60;authentication&#x60; - Authentication * &#x60;authorization&#x60; - Authorization * &#x60;invalidation&#x60; - Invalidation * &#x60;enrollment&#x60; - Enrollment * &#x60;unenrollment&#x60; - Unrenollment * &#x60;recovery&#x60; - Recovery * &#x60;stage_configuration&#x60; - Stage Configuration (optional)
     * @param flowUuid  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @return PaginatedFlowList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesList(deniedAction: DeniedAction_flowsInstancesList? = null, designation: Designation_flowsInstancesList? = null, flowUuid: java.util.UUID? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, slug: kotlin.String? = null) : PaginatedFlowList {
        val localVarResponse = flowsInstancesListWithHttpInfo(deniedAction = deniedAction, designation = designation, flowUuid = flowUuid, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedFlowList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Flow Viewset
     * @param deniedAction Configure what should happen when a flow denies access to a user.  * &#x60;message_continue&#x60; - Message Continue * &#x60;message&#x60; - Message * &#x60;continue&#x60; - Continue (optional)
     * @param designation Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.  * &#x60;authentication&#x60; - Authentication * &#x60;authorization&#x60; - Authorization * &#x60;invalidation&#x60; - Invalidation * &#x60;enrollment&#x60; - Enrollment * &#x60;unenrollment&#x60; - Unrenollment * &#x60;recovery&#x60; - Recovery * &#x60;stage_configuration&#x60; - Stage Configuration (optional)
     * @param flowUuid  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @return ApiResponse<PaginatedFlowList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesListWithHttpInfo(deniedAction: DeniedAction_flowsInstancesList?, designation: Designation_flowsInstancesList?, flowUuid: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, slug: kotlin.String?) : ApiResponse<PaginatedFlowList?> {
        val localVariableConfig = flowsInstancesListRequestConfig(deniedAction = deniedAction, designation = designation, flowUuid = flowUuid, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, slug = slug)

        return request<Unit, PaginatedFlowList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesList
     *
     * @param deniedAction Configure what should happen when a flow denies access to a user.  * &#x60;message_continue&#x60; - Message Continue * &#x60;message&#x60; - Message * &#x60;continue&#x60; - Continue (optional)
     * @param designation Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.  * &#x60;authentication&#x60; - Authentication * &#x60;authorization&#x60; - Authorization * &#x60;invalidation&#x60; - Invalidation * &#x60;enrollment&#x60; - Enrollment * &#x60;unenrollment&#x60; - Unrenollment * &#x60;recovery&#x60; - Recovery * &#x60;stage_configuration&#x60; - Stage Configuration (optional)
     * @param flowUuid  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @return RequestConfig
     */
    fun flowsInstancesListRequestConfig(deniedAction: DeniedAction_flowsInstancesList?, designation: Designation_flowsInstancesList?, flowUuid: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, slug: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (deniedAction != null) {
                    put("denied_action", listOf(deniedAction.toString()))
                }
                if (designation != null) {
                    put("designation", listOf(designation.toString()))
                }
                if (flowUuid != null) {
                    put("flow_uuid", listOf(flowUuid.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (slug != null) {
                    put("slug", listOf(slug.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/instances/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Flow Viewset
     * @param slug 
     * @param patchedFlowRequest  (optional)
     * @return Flow
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesPartialUpdate(slug: kotlin.String, patchedFlowRequest: PatchedFlowRequest? = null) : Flow {
        val localVarResponse = flowsInstancesPartialUpdateWithHttpInfo(slug = slug, patchedFlowRequest = patchedFlowRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Flow
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Flow Viewset
     * @param slug 
     * @param patchedFlowRequest  (optional)
     * @return ApiResponse<Flow?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesPartialUpdateWithHttpInfo(slug: kotlin.String, patchedFlowRequest: PatchedFlowRequest?) : ApiResponse<Flow?> {
        val localVariableConfig = flowsInstancesPartialUpdateRequestConfig(slug = slug, patchedFlowRequest = patchedFlowRequest)

        return request<PatchedFlowRequest, Flow>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesPartialUpdate
     *
     * @param slug 
     * @param patchedFlowRequest  (optional)
     * @return RequestConfig
     */
    fun flowsInstancesPartialUpdateRequestConfig(slug: kotlin.String, patchedFlowRequest: PatchedFlowRequest?) : RequestConfig<PatchedFlowRequest> {
        val localVariableBody = patchedFlowRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/flows/instances/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Flow Viewset
     * @param slug 
     * @return Flow
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesRetrieve(slug: kotlin.String) : Flow {
        val localVarResponse = flowsInstancesRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Flow
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Flow Viewset
     * @param slug 
     * @return ApiResponse<Flow?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<Flow?> {
        val localVariableConfig = flowsInstancesRetrieveRequestConfig(slug = slug)

        return request<Unit, Flow>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun flowsInstancesRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/instances/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set Flow background
     * @param slug 
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesSetBackgroundCreate(slug: kotlin.String, file: java.io.File? = null, clear: kotlin.Boolean? = false) : Unit {
        val localVarResponse = flowsInstancesSetBackgroundCreateWithHttpInfo(slug = slug, file = file, clear = clear)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set Flow background
     * @param slug 
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesSetBackgroundCreateWithHttpInfo(slug: kotlin.String, file: java.io.File?, clear: kotlin.Boolean?) : ApiResponse<Unit?> {
        val localVariableConfig = flowsInstancesSetBackgroundCreateRequestConfig(slug = slug, file = file, clear = clear)

        return request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesSetBackgroundCreate
     *
     * @param slug 
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return RequestConfig
     */
    fun flowsInstancesSetBackgroundCreateRequestConfig(slug: kotlin.String, file: java.io.File?, clear: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "clear" to PartConfig(body = clear, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/flows/instances/{slug}/set_background/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set Flow background (as URL)
     * @param slug 
     * @param filePathRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesSetBackgroundUrlCreate(slug: kotlin.String, filePathRequest: FilePathRequest) : Unit {
        val localVarResponse = flowsInstancesSetBackgroundUrlCreateWithHttpInfo(slug = slug, filePathRequest = filePathRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set Flow background (as URL)
     * @param slug 
     * @param filePathRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesSetBackgroundUrlCreateWithHttpInfo(slug: kotlin.String, filePathRequest: FilePathRequest) : ApiResponse<Unit?> {
        val localVariableConfig = flowsInstancesSetBackgroundUrlCreateRequestConfig(slug = slug, filePathRequest = filePathRequest)

        return request<FilePathRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesSetBackgroundUrlCreate
     *
     * @param slug 
     * @param filePathRequest 
     * @return RequestConfig
     */
    fun flowsInstancesSetBackgroundUrlCreateRequestConfig(slug: kotlin.String, filePathRequest: FilePathRequest) : RequestConfig<FilePathRequest> {
        val localVariableBody = filePathRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/flows/instances/{slug}/set_background_url/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Flow Viewset
     * @param slug 
     * @param flowRequest 
     * @return Flow
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesUpdate(slug: kotlin.String, flowRequest: FlowRequest) : Flow {
        val localVarResponse = flowsInstancesUpdateWithHttpInfo(slug = slug, flowRequest = flowRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Flow
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Flow Viewset
     * @param slug 
     * @param flowRequest 
     * @return ApiResponse<Flow?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesUpdateWithHttpInfo(slug: kotlin.String, flowRequest: FlowRequest) : ApiResponse<Flow?> {
        val localVariableConfig = flowsInstancesUpdateRequestConfig(slug = slug, flowRequest = flowRequest)

        return request<FlowRequest, Flow>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesUpdate
     *
     * @param slug 
     * @param flowRequest 
     * @return RequestConfig
     */
    fun flowsInstancesUpdateRequestConfig(slug: kotlin.String, flowRequest: FlowRequest) : RequestConfig<FlowRequest> {
        val localVariableBody = flowRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/flows/instances/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun flowsInstancesUsedByList(slug: kotlin.String) : kotlin.collections.List<UsedBy> {
        val localVarResponse = flowsInstancesUsedByListWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun flowsInstancesUsedByListWithHttpInfo(slug: kotlin.String) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = flowsInstancesUsedByListRequestConfig(slug = slug)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation flowsInstancesUsedByList
     *
     * @param slug 
     * @return RequestConfig
     */
    fun flowsInstancesUsedByListRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/flows/instances/{slug}/used_by/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
