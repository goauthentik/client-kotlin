/**
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2023.10.2
 * Contact: hello@goauthentik.io
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.LDAPPropertyMapping
import io.goauthentik.api.models.LDAPPropertyMappingRequest
import io.goauthentik.api.models.NotificationWebhookMapping
import io.goauthentik.api.models.NotificationWebhookMappingRequest
import io.goauthentik.api.models.PaginatedLDAPPropertyMappingList
import io.goauthentik.api.models.PaginatedNotificationWebhookMappingList
import io.goauthentik.api.models.PaginatedPropertyMappingList
import io.goauthentik.api.models.PaginatedSAMLPropertyMappingList
import io.goauthentik.api.models.PaginatedSCIMMappingList
import io.goauthentik.api.models.PaginatedScopeMappingList
import io.goauthentik.api.models.PatchedLDAPPropertyMappingRequest
import io.goauthentik.api.models.PatchedNotificationWebhookMappingRequest
import io.goauthentik.api.models.PatchedSAMLPropertyMappingRequest
import io.goauthentik.api.models.PatchedSCIMMappingRequest
import io.goauthentik.api.models.PatchedScopeMappingRequest
import io.goauthentik.api.models.PolicyTestRequest
import io.goauthentik.api.models.PropertyMapping
import io.goauthentik.api.models.PropertyMappingTestResult
import io.goauthentik.api.models.SAMLPropertyMapping
import io.goauthentik.api.models.SAMLPropertyMappingRequest
import io.goauthentik.api.models.SCIMMapping
import io.goauthentik.api.models.SCIMMappingRequest
import io.goauthentik.api.models.ScopeMapping
import io.goauthentik.api.models.ScopeMappingRequest
import io.goauthentik.api.models.TypeCreate
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.ValidationError

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class PropertymappingsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsAllDestroy(pmUuid: java.util.UUID) : Unit {
        val localVarResponse = propertymappingsAllDestroyWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsAllDestroyWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = propertymappingsAllDestroyRequestConfig(pmUuid = pmUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsAllDestroy
     *
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @return RequestConfig
     */
    fun propertymappingsAllDestroyRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/propertymappings/all/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PropertyMapping Viewset
     * @param managedIsnull  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedPropertyMappingList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsAllList(managedIsnull: kotlin.Boolean? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedPropertyMappingList {
        val localVarResponse = propertymappingsAllListWithHttpInfo(managedIsnull = managedIsnull, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPropertyMappingList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PropertyMapping Viewset
     * @param managedIsnull  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedPropertyMappingList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsAllListWithHttpInfo(managedIsnull: kotlin.Boolean?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedPropertyMappingList?> {
        val localVariableConfig = propertymappingsAllListRequestConfig(managedIsnull = managedIsnull, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedPropertyMappingList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsAllList
     *
     * @param managedIsnull  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun propertymappingsAllListRequestConfig(managedIsnull: kotlin.Boolean?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (managedIsnull != null) {
                    put("managed__isnull", listOf(managedIsnull.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/all/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @return PropertyMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsAllRetrieve(pmUuid: java.util.UUID) : PropertyMapping {
        val localVarResponse = propertymappingsAllRetrieveWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PropertyMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @return ApiResponse<PropertyMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsAllRetrieveWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<PropertyMapping?> {
        val localVariableConfig = propertymappingsAllRetrieveRequestConfig(pmUuid = pmUuid)

        return request<Unit, PropertyMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsAllRetrieve
     *
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @return RequestConfig
     */
    fun propertymappingsAllRetrieveRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/all/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Test Property Mapping
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @param policyTestRequest 
     * @param formatResult  (optional)
     * @return PropertyMappingTestResult
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsAllTestCreate(pmUuid: java.util.UUID, policyTestRequest: PolicyTestRequest, formatResult: kotlin.Boolean? = null) : PropertyMappingTestResult {
        val localVarResponse = propertymappingsAllTestCreateWithHttpInfo(pmUuid = pmUuid, policyTestRequest = policyTestRequest, formatResult = formatResult)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PropertyMappingTestResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Test Property Mapping
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @param policyTestRequest 
     * @param formatResult  (optional)
     * @return ApiResponse<PropertyMappingTestResult?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsAllTestCreateWithHttpInfo(pmUuid: java.util.UUID, policyTestRequest: PolicyTestRequest, formatResult: kotlin.Boolean?) : ApiResponse<PropertyMappingTestResult?> {
        val localVariableConfig = propertymappingsAllTestCreateRequestConfig(pmUuid = pmUuid, policyTestRequest = policyTestRequest, formatResult = formatResult)

        return request<PolicyTestRequest, PropertyMappingTestResult>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsAllTestCreate
     *
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @param policyTestRequest 
     * @param formatResult  (optional)
     * @return RequestConfig
     */
    fun propertymappingsAllTestCreateRequestConfig(pmUuid: java.util.UUID, policyTestRequest: PolicyTestRequest, formatResult: kotlin.Boolean?) : RequestConfig<PolicyTestRequest> {
        val localVariableBody = policyTestRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (formatResult != null) {
                    put("format_result", listOf(formatResult.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/propertymappings/all/{pm_uuid}/test/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all creatable property-mapping types
     * @return kotlin.collections.List<TypeCreate>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsAllTypesList() : kotlin.collections.List<TypeCreate> {
        val localVarResponse = propertymappingsAllTypesListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TypeCreate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all creatable property-mapping types
     * @return ApiResponse<kotlin.collections.List<TypeCreate>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsAllTypesListWithHttpInfo() : ApiResponse<kotlin.collections.List<TypeCreate>?> {
        val localVariableConfig = propertymappingsAllTypesListRequestConfig()

        return request<Unit, kotlin.collections.List<TypeCreate>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsAllTypesList
     *
     * @return RequestConfig
     */
    fun propertymappingsAllTypesListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/all/types/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsAllUsedByList(pmUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = propertymappingsAllUsedByListWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsAllUsedByListWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = propertymappingsAllUsedByListRequestConfig(pmUuid = pmUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsAllUsedByList
     *
     * @param pmUuid A UUID string identifying this Property Mapping.
     * @return RequestConfig
     */
    fun propertymappingsAllUsedByListRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/all/{pm_uuid}/used_by/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param ldAPPropertyMappingRequest 
     * @return LDAPPropertyMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsLdapCreate(ldAPPropertyMappingRequest: LDAPPropertyMappingRequest) : LDAPPropertyMapping {
        val localVarResponse = propertymappingsLdapCreateWithHttpInfo(ldAPPropertyMappingRequest = ldAPPropertyMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPPropertyMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param ldAPPropertyMappingRequest 
     * @return ApiResponse<LDAPPropertyMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsLdapCreateWithHttpInfo(ldAPPropertyMappingRequest: LDAPPropertyMappingRequest) : ApiResponse<LDAPPropertyMapping?> {
        val localVariableConfig = propertymappingsLdapCreateRequestConfig(ldAPPropertyMappingRequest = ldAPPropertyMappingRequest)

        return request<LDAPPropertyMappingRequest, LDAPPropertyMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsLdapCreate
     *
     * @param ldAPPropertyMappingRequest 
     * @return RequestConfig
     */
    fun propertymappingsLdapCreateRequestConfig(ldAPPropertyMappingRequest: LDAPPropertyMappingRequest) : RequestConfig<LDAPPropertyMappingRequest> {
        val localVariableBody = ldAPPropertyMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/propertymappings/ldap/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsLdapDestroy(pmUuid: java.util.UUID) : Unit {
        val localVarResponse = propertymappingsLdapDestroyWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsLdapDestroyWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = propertymappingsLdapDestroyRequestConfig(pmUuid = pmUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsLdapDestroy
     *
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @return RequestConfig
     */
    fun propertymappingsLdapDestroyRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/propertymappings/ldap/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param expression  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param objectField  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pmUuid  (optional)
     * @param search A search term. (optional)
     * @return PaginatedLDAPPropertyMappingList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsLdapList(expression: kotlin.String? = null, managed: kotlin.collections.List<kotlin.String>? = null, name: kotlin.String? = null, objectField: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, pmUuid: java.util.UUID? = null, search: kotlin.String? = null) : PaginatedLDAPPropertyMappingList {
        val localVarResponse = propertymappingsLdapListWithHttpInfo(expression = expression, managed = managed, name = name, objectField = objectField, ordering = ordering, page = page, pageSize = pageSize, pmUuid = pmUuid, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedLDAPPropertyMappingList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param expression  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param objectField  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pmUuid  (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedLDAPPropertyMappingList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsLdapListWithHttpInfo(expression: kotlin.String?, managed: kotlin.collections.List<kotlin.String>?, name: kotlin.String?, objectField: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, pmUuid: java.util.UUID?, search: kotlin.String?) : ApiResponse<PaginatedLDAPPropertyMappingList?> {
        val localVariableConfig = propertymappingsLdapListRequestConfig(expression = expression, managed = managed, name = name, objectField = objectField, ordering = ordering, page = page, pageSize = pageSize, pmUuid = pmUuid, search = search)

        return request<Unit, PaginatedLDAPPropertyMappingList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsLdapList
     *
     * @param expression  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param objectField  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pmUuid  (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun propertymappingsLdapListRequestConfig(expression: kotlin.String?, managed: kotlin.collections.List<kotlin.String>?, name: kotlin.String?, objectField: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, pmUuid: java.util.UUID?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expression != null) {
                    put("expression", listOf(expression.toString()))
                }
                if (managed != null) {
                    put("managed", toMultiValue(managed.toList(), "multi"))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (objectField != null) {
                    put("object_field", listOf(objectField.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (pmUuid != null) {
                    put("pm_uuid", listOf(pmUuid.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/ldap/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @param patchedLDAPPropertyMappingRequest  (optional)
     * @return LDAPPropertyMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsLdapPartialUpdate(pmUuid: java.util.UUID, patchedLDAPPropertyMappingRequest: PatchedLDAPPropertyMappingRequest? = null) : LDAPPropertyMapping {
        val localVarResponse = propertymappingsLdapPartialUpdateWithHttpInfo(pmUuid = pmUuid, patchedLDAPPropertyMappingRequest = patchedLDAPPropertyMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPPropertyMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @param patchedLDAPPropertyMappingRequest  (optional)
     * @return ApiResponse<LDAPPropertyMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsLdapPartialUpdateWithHttpInfo(pmUuid: java.util.UUID, patchedLDAPPropertyMappingRequest: PatchedLDAPPropertyMappingRequest?) : ApiResponse<LDAPPropertyMapping?> {
        val localVariableConfig = propertymappingsLdapPartialUpdateRequestConfig(pmUuid = pmUuid, patchedLDAPPropertyMappingRequest = patchedLDAPPropertyMappingRequest)

        return request<PatchedLDAPPropertyMappingRequest, LDAPPropertyMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsLdapPartialUpdate
     *
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @param patchedLDAPPropertyMappingRequest  (optional)
     * @return RequestConfig
     */
    fun propertymappingsLdapPartialUpdateRequestConfig(pmUuid: java.util.UUID, patchedLDAPPropertyMappingRequest: PatchedLDAPPropertyMappingRequest?) : RequestConfig<PatchedLDAPPropertyMappingRequest> {
        val localVariableBody = patchedLDAPPropertyMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/propertymappings/ldap/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @return LDAPPropertyMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsLdapRetrieve(pmUuid: java.util.UUID) : LDAPPropertyMapping {
        val localVarResponse = propertymappingsLdapRetrieveWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPPropertyMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @return ApiResponse<LDAPPropertyMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsLdapRetrieveWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<LDAPPropertyMapping?> {
        val localVariableConfig = propertymappingsLdapRetrieveRequestConfig(pmUuid = pmUuid)

        return request<Unit, LDAPPropertyMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsLdapRetrieve
     *
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @return RequestConfig
     */
    fun propertymappingsLdapRetrieveRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/ldap/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @param ldAPPropertyMappingRequest 
     * @return LDAPPropertyMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsLdapUpdate(pmUuid: java.util.UUID, ldAPPropertyMappingRequest: LDAPPropertyMappingRequest) : LDAPPropertyMapping {
        val localVarResponse = propertymappingsLdapUpdateWithHttpInfo(pmUuid = pmUuid, ldAPPropertyMappingRequest = ldAPPropertyMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPPropertyMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP PropertyMapping Viewset
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @param ldAPPropertyMappingRequest 
     * @return ApiResponse<LDAPPropertyMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsLdapUpdateWithHttpInfo(pmUuid: java.util.UUID, ldAPPropertyMappingRequest: LDAPPropertyMappingRequest) : ApiResponse<LDAPPropertyMapping?> {
        val localVariableConfig = propertymappingsLdapUpdateRequestConfig(pmUuid = pmUuid, ldAPPropertyMappingRequest = ldAPPropertyMappingRequest)

        return request<LDAPPropertyMappingRequest, LDAPPropertyMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsLdapUpdate
     *
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @param ldAPPropertyMappingRequest 
     * @return RequestConfig
     */
    fun propertymappingsLdapUpdateRequestConfig(pmUuid: java.util.UUID, ldAPPropertyMappingRequest: LDAPPropertyMappingRequest) : RequestConfig<LDAPPropertyMappingRequest> {
        val localVariableBody = ldAPPropertyMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/propertymappings/ldap/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsLdapUsedByList(pmUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = propertymappingsLdapUsedByListWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsLdapUsedByListWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = propertymappingsLdapUsedByListRequestConfig(pmUuid = pmUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsLdapUsedByList
     *
     * @param pmUuid A UUID string identifying this LDAP Property Mapping.
     * @return RequestConfig
     */
    fun propertymappingsLdapUsedByListRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/ldap/{pm_uuid}/used_by/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param notificationWebhookMappingRequest 
     * @return NotificationWebhookMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsNotificationCreate(notificationWebhookMappingRequest: NotificationWebhookMappingRequest) : NotificationWebhookMapping {
        val localVarResponse = propertymappingsNotificationCreateWithHttpInfo(notificationWebhookMappingRequest = notificationWebhookMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationWebhookMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param notificationWebhookMappingRequest 
     * @return ApiResponse<NotificationWebhookMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsNotificationCreateWithHttpInfo(notificationWebhookMappingRequest: NotificationWebhookMappingRequest) : ApiResponse<NotificationWebhookMapping?> {
        val localVariableConfig = propertymappingsNotificationCreateRequestConfig(notificationWebhookMappingRequest = notificationWebhookMappingRequest)

        return request<NotificationWebhookMappingRequest, NotificationWebhookMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsNotificationCreate
     *
     * @param notificationWebhookMappingRequest 
     * @return RequestConfig
     */
    fun propertymappingsNotificationCreateRequestConfig(notificationWebhookMappingRequest: NotificationWebhookMappingRequest) : RequestConfig<NotificationWebhookMappingRequest> {
        val localVariableBody = notificationWebhookMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/propertymappings/notification/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsNotificationDestroy(pmUuid: java.util.UUID) : Unit {
        val localVarResponse = propertymappingsNotificationDestroyWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsNotificationDestroyWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = propertymappingsNotificationDestroyRequestConfig(pmUuid = pmUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsNotificationDestroy
     *
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @return RequestConfig
     */
    fun propertymappingsNotificationDestroyRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/propertymappings/notification/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedNotificationWebhookMappingList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsNotificationList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedNotificationWebhookMappingList {
        val localVarResponse = propertymappingsNotificationListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedNotificationWebhookMappingList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedNotificationWebhookMappingList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsNotificationListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedNotificationWebhookMappingList?> {
        val localVariableConfig = propertymappingsNotificationListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedNotificationWebhookMappingList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsNotificationList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun propertymappingsNotificationListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/notification/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @param patchedNotificationWebhookMappingRequest  (optional)
     * @return NotificationWebhookMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsNotificationPartialUpdate(pmUuid: java.util.UUID, patchedNotificationWebhookMappingRequest: PatchedNotificationWebhookMappingRequest? = null) : NotificationWebhookMapping {
        val localVarResponse = propertymappingsNotificationPartialUpdateWithHttpInfo(pmUuid = pmUuid, patchedNotificationWebhookMappingRequest = patchedNotificationWebhookMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationWebhookMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @param patchedNotificationWebhookMappingRequest  (optional)
     * @return ApiResponse<NotificationWebhookMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsNotificationPartialUpdateWithHttpInfo(pmUuid: java.util.UUID, patchedNotificationWebhookMappingRequest: PatchedNotificationWebhookMappingRequest?) : ApiResponse<NotificationWebhookMapping?> {
        val localVariableConfig = propertymappingsNotificationPartialUpdateRequestConfig(pmUuid = pmUuid, patchedNotificationWebhookMappingRequest = patchedNotificationWebhookMappingRequest)

        return request<PatchedNotificationWebhookMappingRequest, NotificationWebhookMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsNotificationPartialUpdate
     *
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @param patchedNotificationWebhookMappingRequest  (optional)
     * @return RequestConfig
     */
    fun propertymappingsNotificationPartialUpdateRequestConfig(pmUuid: java.util.UUID, patchedNotificationWebhookMappingRequest: PatchedNotificationWebhookMappingRequest?) : RequestConfig<PatchedNotificationWebhookMappingRequest> {
        val localVariableBody = patchedNotificationWebhookMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/propertymappings/notification/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @return NotificationWebhookMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsNotificationRetrieve(pmUuid: java.util.UUID) : NotificationWebhookMapping {
        val localVarResponse = propertymappingsNotificationRetrieveWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationWebhookMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @return ApiResponse<NotificationWebhookMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsNotificationRetrieveWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<NotificationWebhookMapping?> {
        val localVariableConfig = propertymappingsNotificationRetrieveRequestConfig(pmUuid = pmUuid)

        return request<Unit, NotificationWebhookMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsNotificationRetrieve
     *
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @return RequestConfig
     */
    fun propertymappingsNotificationRetrieveRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/notification/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @param notificationWebhookMappingRequest 
     * @return NotificationWebhookMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsNotificationUpdate(pmUuid: java.util.UUID, notificationWebhookMappingRequest: NotificationWebhookMappingRequest) : NotificationWebhookMapping {
        val localVarResponse = propertymappingsNotificationUpdateWithHttpInfo(pmUuid = pmUuid, notificationWebhookMappingRequest = notificationWebhookMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationWebhookMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationWebhookMapping Viewset
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @param notificationWebhookMappingRequest 
     * @return ApiResponse<NotificationWebhookMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsNotificationUpdateWithHttpInfo(pmUuid: java.util.UUID, notificationWebhookMappingRequest: NotificationWebhookMappingRequest) : ApiResponse<NotificationWebhookMapping?> {
        val localVariableConfig = propertymappingsNotificationUpdateRequestConfig(pmUuid = pmUuid, notificationWebhookMappingRequest = notificationWebhookMappingRequest)

        return request<NotificationWebhookMappingRequest, NotificationWebhookMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsNotificationUpdate
     *
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @param notificationWebhookMappingRequest 
     * @return RequestConfig
     */
    fun propertymappingsNotificationUpdateRequestConfig(pmUuid: java.util.UUID, notificationWebhookMappingRequest: NotificationWebhookMappingRequest) : RequestConfig<NotificationWebhookMappingRequest> {
        val localVariableBody = notificationWebhookMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/propertymappings/notification/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsNotificationUsedByList(pmUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = propertymappingsNotificationUsedByListWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsNotificationUsedByListWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = propertymappingsNotificationUsedByListRequestConfig(pmUuid = pmUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsNotificationUsedByList
     *
     * @param pmUuid A UUID string identifying this Webhook Mapping.
     * @return RequestConfig
     */
    fun propertymappingsNotificationUsedByListRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/notification/{pm_uuid}/used_by/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param saMLPropertyMappingRequest 
     * @return SAMLPropertyMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsSamlCreate(saMLPropertyMappingRequest: SAMLPropertyMappingRequest) : SAMLPropertyMapping {
        val localVarResponse = propertymappingsSamlCreateWithHttpInfo(saMLPropertyMappingRequest = saMLPropertyMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLPropertyMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param saMLPropertyMappingRequest 
     * @return ApiResponse<SAMLPropertyMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsSamlCreateWithHttpInfo(saMLPropertyMappingRequest: SAMLPropertyMappingRequest) : ApiResponse<SAMLPropertyMapping?> {
        val localVariableConfig = propertymappingsSamlCreateRequestConfig(saMLPropertyMappingRequest = saMLPropertyMappingRequest)

        return request<SAMLPropertyMappingRequest, SAMLPropertyMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsSamlCreate
     *
     * @param saMLPropertyMappingRequest 
     * @return RequestConfig
     */
    fun propertymappingsSamlCreateRequestConfig(saMLPropertyMappingRequest: SAMLPropertyMappingRequest) : RequestConfig<SAMLPropertyMappingRequest> {
        val localVariableBody = saMLPropertyMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/propertymappings/saml/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsSamlDestroy(pmUuid: java.util.UUID) : Unit {
        val localVarResponse = propertymappingsSamlDestroyWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsSamlDestroyWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = propertymappingsSamlDestroyRequestConfig(pmUuid = pmUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsSamlDestroy
     *
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @return RequestConfig
     */
    fun propertymappingsSamlDestroyRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/propertymappings/saml/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param expression  (optional)
     * @param friendlyName  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pmUuid  (optional)
     * @param samlName  (optional)
     * @param search A search term. (optional)
     * @return PaginatedSAMLPropertyMappingList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsSamlList(expression: kotlin.String? = null, friendlyName: kotlin.String? = null, managed: kotlin.collections.List<kotlin.String>? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, pmUuid: java.util.UUID? = null, samlName: kotlin.String? = null, search: kotlin.String? = null) : PaginatedSAMLPropertyMappingList {
        val localVarResponse = propertymappingsSamlListWithHttpInfo(expression = expression, friendlyName = friendlyName, managed = managed, name = name, ordering = ordering, page = page, pageSize = pageSize, pmUuid = pmUuid, samlName = samlName, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedSAMLPropertyMappingList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param expression  (optional)
     * @param friendlyName  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pmUuid  (optional)
     * @param samlName  (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedSAMLPropertyMappingList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsSamlListWithHttpInfo(expression: kotlin.String?, friendlyName: kotlin.String?, managed: kotlin.collections.List<kotlin.String>?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, pmUuid: java.util.UUID?, samlName: kotlin.String?, search: kotlin.String?) : ApiResponse<PaginatedSAMLPropertyMappingList?> {
        val localVariableConfig = propertymappingsSamlListRequestConfig(expression = expression, friendlyName = friendlyName, managed = managed, name = name, ordering = ordering, page = page, pageSize = pageSize, pmUuid = pmUuid, samlName = samlName, search = search)

        return request<Unit, PaginatedSAMLPropertyMappingList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsSamlList
     *
     * @param expression  (optional)
     * @param friendlyName  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pmUuid  (optional)
     * @param samlName  (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun propertymappingsSamlListRequestConfig(expression: kotlin.String?, friendlyName: kotlin.String?, managed: kotlin.collections.List<kotlin.String>?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, pmUuid: java.util.UUID?, samlName: kotlin.String?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expression != null) {
                    put("expression", listOf(expression.toString()))
                }
                if (friendlyName != null) {
                    put("friendly_name", listOf(friendlyName.toString()))
                }
                if (managed != null) {
                    put("managed", toMultiValue(managed.toList(), "multi"))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (pmUuid != null) {
                    put("pm_uuid", listOf(pmUuid.toString()))
                }
                if (samlName != null) {
                    put("saml_name", listOf(samlName.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/saml/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @param patchedSAMLPropertyMappingRequest  (optional)
     * @return SAMLPropertyMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsSamlPartialUpdate(pmUuid: java.util.UUID, patchedSAMLPropertyMappingRequest: PatchedSAMLPropertyMappingRequest? = null) : SAMLPropertyMapping {
        val localVarResponse = propertymappingsSamlPartialUpdateWithHttpInfo(pmUuid = pmUuid, patchedSAMLPropertyMappingRequest = patchedSAMLPropertyMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLPropertyMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @param patchedSAMLPropertyMappingRequest  (optional)
     * @return ApiResponse<SAMLPropertyMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsSamlPartialUpdateWithHttpInfo(pmUuid: java.util.UUID, patchedSAMLPropertyMappingRequest: PatchedSAMLPropertyMappingRequest?) : ApiResponse<SAMLPropertyMapping?> {
        val localVariableConfig = propertymappingsSamlPartialUpdateRequestConfig(pmUuid = pmUuid, patchedSAMLPropertyMappingRequest = patchedSAMLPropertyMappingRequest)

        return request<PatchedSAMLPropertyMappingRequest, SAMLPropertyMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsSamlPartialUpdate
     *
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @param patchedSAMLPropertyMappingRequest  (optional)
     * @return RequestConfig
     */
    fun propertymappingsSamlPartialUpdateRequestConfig(pmUuid: java.util.UUID, patchedSAMLPropertyMappingRequest: PatchedSAMLPropertyMappingRequest?) : RequestConfig<PatchedSAMLPropertyMappingRequest> {
        val localVariableBody = patchedSAMLPropertyMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/propertymappings/saml/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @return SAMLPropertyMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsSamlRetrieve(pmUuid: java.util.UUID) : SAMLPropertyMapping {
        val localVarResponse = propertymappingsSamlRetrieveWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLPropertyMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @return ApiResponse<SAMLPropertyMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsSamlRetrieveWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<SAMLPropertyMapping?> {
        val localVariableConfig = propertymappingsSamlRetrieveRequestConfig(pmUuid = pmUuid)

        return request<Unit, SAMLPropertyMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsSamlRetrieve
     *
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @return RequestConfig
     */
    fun propertymappingsSamlRetrieveRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/saml/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @param saMLPropertyMappingRequest 
     * @return SAMLPropertyMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsSamlUpdate(pmUuid: java.util.UUID, saMLPropertyMappingRequest: SAMLPropertyMappingRequest) : SAMLPropertyMapping {
        val localVarResponse = propertymappingsSamlUpdateWithHttpInfo(pmUuid = pmUuid, saMLPropertyMappingRequest = saMLPropertyMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLPropertyMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLPropertyMapping Viewset
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @param saMLPropertyMappingRequest 
     * @return ApiResponse<SAMLPropertyMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsSamlUpdateWithHttpInfo(pmUuid: java.util.UUID, saMLPropertyMappingRequest: SAMLPropertyMappingRequest) : ApiResponse<SAMLPropertyMapping?> {
        val localVariableConfig = propertymappingsSamlUpdateRequestConfig(pmUuid = pmUuid, saMLPropertyMappingRequest = saMLPropertyMappingRequest)

        return request<SAMLPropertyMappingRequest, SAMLPropertyMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsSamlUpdate
     *
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @param saMLPropertyMappingRequest 
     * @return RequestConfig
     */
    fun propertymappingsSamlUpdateRequestConfig(pmUuid: java.util.UUID, saMLPropertyMappingRequest: SAMLPropertyMappingRequest) : RequestConfig<SAMLPropertyMappingRequest> {
        val localVariableBody = saMLPropertyMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/propertymappings/saml/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsSamlUsedByList(pmUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = propertymappingsSamlUsedByListWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsSamlUsedByListWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = propertymappingsSamlUsedByListRequestConfig(pmUuid = pmUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsSamlUsedByList
     *
     * @param pmUuid A UUID string identifying this SAML Property Mapping.
     * @return RequestConfig
     */
    fun propertymappingsSamlUsedByListRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/saml/{pm_uuid}/used_by/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param scIMMappingRequest 
     * @return SCIMMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScimCreate(scIMMappingRequest: SCIMMappingRequest) : SCIMMapping {
        val localVarResponse = propertymappingsScimCreateWithHttpInfo(scIMMappingRequest = scIMMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SCIMMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param scIMMappingRequest 
     * @return ApiResponse<SCIMMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScimCreateWithHttpInfo(scIMMappingRequest: SCIMMappingRequest) : ApiResponse<SCIMMapping?> {
        val localVariableConfig = propertymappingsScimCreateRequestConfig(scIMMappingRequest = scIMMappingRequest)

        return request<SCIMMappingRequest, SCIMMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScimCreate
     *
     * @param scIMMappingRequest 
     * @return RequestConfig
     */
    fun propertymappingsScimCreateRequestConfig(scIMMappingRequest: SCIMMappingRequest) : RequestConfig<SCIMMappingRequest> {
        val localVariableBody = scIMMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/propertymappings/scim/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScimDestroy(pmUuid: java.util.UUID) : Unit {
        val localVarResponse = propertymappingsScimDestroyWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScimDestroyWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = propertymappingsScimDestroyRequestConfig(pmUuid = pmUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScimDestroy
     *
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @return RequestConfig
     */
    fun propertymappingsScimDestroyRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/propertymappings/scim/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param expression  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pmUuid  (optional)
     * @param search A search term. (optional)
     * @return PaginatedSCIMMappingList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScimList(expression: kotlin.String? = null, managed: kotlin.collections.List<kotlin.String>? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, pmUuid: java.util.UUID? = null, search: kotlin.String? = null) : PaginatedSCIMMappingList {
        val localVarResponse = propertymappingsScimListWithHttpInfo(expression = expression, managed = managed, name = name, ordering = ordering, page = page, pageSize = pageSize, pmUuid = pmUuid, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedSCIMMappingList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param expression  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pmUuid  (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedSCIMMappingList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScimListWithHttpInfo(expression: kotlin.String?, managed: kotlin.collections.List<kotlin.String>?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, pmUuid: java.util.UUID?, search: kotlin.String?) : ApiResponse<PaginatedSCIMMappingList?> {
        val localVariableConfig = propertymappingsScimListRequestConfig(expression = expression, managed = managed, name = name, ordering = ordering, page = page, pageSize = pageSize, pmUuid = pmUuid, search = search)

        return request<Unit, PaginatedSCIMMappingList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScimList
     *
     * @param expression  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param pmUuid  (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun propertymappingsScimListRequestConfig(expression: kotlin.String?, managed: kotlin.collections.List<kotlin.String>?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, pmUuid: java.util.UUID?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expression != null) {
                    put("expression", listOf(expression.toString()))
                }
                if (managed != null) {
                    put("managed", toMultiValue(managed.toList(), "multi"))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (pmUuid != null) {
                    put("pm_uuid", listOf(pmUuid.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/scim/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @param patchedSCIMMappingRequest  (optional)
     * @return SCIMMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScimPartialUpdate(pmUuid: java.util.UUID, patchedSCIMMappingRequest: PatchedSCIMMappingRequest? = null) : SCIMMapping {
        val localVarResponse = propertymappingsScimPartialUpdateWithHttpInfo(pmUuid = pmUuid, patchedSCIMMappingRequest = patchedSCIMMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SCIMMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @param patchedSCIMMappingRequest  (optional)
     * @return ApiResponse<SCIMMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScimPartialUpdateWithHttpInfo(pmUuid: java.util.UUID, patchedSCIMMappingRequest: PatchedSCIMMappingRequest?) : ApiResponse<SCIMMapping?> {
        val localVariableConfig = propertymappingsScimPartialUpdateRequestConfig(pmUuid = pmUuid, patchedSCIMMappingRequest = patchedSCIMMappingRequest)

        return request<PatchedSCIMMappingRequest, SCIMMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScimPartialUpdate
     *
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @param patchedSCIMMappingRequest  (optional)
     * @return RequestConfig
     */
    fun propertymappingsScimPartialUpdateRequestConfig(pmUuid: java.util.UUID, patchedSCIMMappingRequest: PatchedSCIMMappingRequest?) : RequestConfig<PatchedSCIMMappingRequest> {
        val localVariableBody = patchedSCIMMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/propertymappings/scim/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @return SCIMMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScimRetrieve(pmUuid: java.util.UUID) : SCIMMapping {
        val localVarResponse = propertymappingsScimRetrieveWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SCIMMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @return ApiResponse<SCIMMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScimRetrieveWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<SCIMMapping?> {
        val localVariableConfig = propertymappingsScimRetrieveRequestConfig(pmUuid = pmUuid)

        return request<Unit, SCIMMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScimRetrieve
     *
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @return RequestConfig
     */
    fun propertymappingsScimRetrieveRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/scim/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @param scIMMappingRequest 
     * @return SCIMMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScimUpdate(pmUuid: java.util.UUID, scIMMappingRequest: SCIMMappingRequest) : SCIMMapping {
        val localVarResponse = propertymappingsScimUpdateWithHttpInfo(pmUuid = pmUuid, scIMMappingRequest = scIMMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SCIMMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMMapping Viewset
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @param scIMMappingRequest 
     * @return ApiResponse<SCIMMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScimUpdateWithHttpInfo(pmUuid: java.util.UUID, scIMMappingRequest: SCIMMappingRequest) : ApiResponse<SCIMMapping?> {
        val localVariableConfig = propertymappingsScimUpdateRequestConfig(pmUuid = pmUuid, scIMMappingRequest = scIMMappingRequest)

        return request<SCIMMappingRequest, SCIMMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScimUpdate
     *
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @param scIMMappingRequest 
     * @return RequestConfig
     */
    fun propertymappingsScimUpdateRequestConfig(pmUuid: java.util.UUID, scIMMappingRequest: SCIMMappingRequest) : RequestConfig<SCIMMappingRequest> {
        val localVariableBody = scIMMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/propertymappings/scim/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScimUsedByList(pmUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = propertymappingsScimUsedByListWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScimUsedByListWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = propertymappingsScimUsedByListRequestConfig(pmUuid = pmUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScimUsedByList
     *
     * @param pmUuid A UUID string identifying this SCIM Mapping.
     * @return RequestConfig
     */
    fun propertymappingsScimUsedByListRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/scim/{pm_uuid}/used_by/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param scopeMappingRequest 
     * @return ScopeMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScopeCreate(scopeMappingRequest: ScopeMappingRequest) : ScopeMapping {
        val localVarResponse = propertymappingsScopeCreateWithHttpInfo(scopeMappingRequest = scopeMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ScopeMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param scopeMappingRequest 
     * @return ApiResponse<ScopeMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScopeCreateWithHttpInfo(scopeMappingRequest: ScopeMappingRequest) : ApiResponse<ScopeMapping?> {
        val localVariableConfig = propertymappingsScopeCreateRequestConfig(scopeMappingRequest = scopeMappingRequest)

        return request<ScopeMappingRequest, ScopeMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScopeCreate
     *
     * @param scopeMappingRequest 
     * @return RequestConfig
     */
    fun propertymappingsScopeCreateRequestConfig(scopeMappingRequest: ScopeMappingRequest) : RequestConfig<ScopeMappingRequest> {
        val localVariableBody = scopeMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/propertymappings/scope/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScopeDestroy(pmUuid: java.util.UUID) : Unit {
        val localVarResponse = propertymappingsScopeDestroyWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScopeDestroyWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = propertymappingsScopeDestroyRequestConfig(pmUuid = pmUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScopeDestroy
     *
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @return RequestConfig
     */
    fun propertymappingsScopeDestroyRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/propertymappings/scope/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param scopeName  (optional)
     * @param search A search term. (optional)
     * @return PaginatedScopeMappingList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScopeList(managed: kotlin.collections.List<kotlin.String>? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, scopeName: kotlin.String? = null, search: kotlin.String? = null) : PaginatedScopeMappingList {
        val localVarResponse = propertymappingsScopeListWithHttpInfo(managed = managed, name = name, ordering = ordering, page = page, pageSize = pageSize, scopeName = scopeName, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedScopeMappingList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param scopeName  (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedScopeMappingList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScopeListWithHttpInfo(managed: kotlin.collections.List<kotlin.String>?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, scopeName: kotlin.String?, search: kotlin.String?) : ApiResponse<PaginatedScopeMappingList?> {
        val localVariableConfig = propertymappingsScopeListRequestConfig(managed = managed, name = name, ordering = ordering, page = page, pageSize = pageSize, scopeName = scopeName, search = search)

        return request<Unit, PaginatedScopeMappingList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScopeList
     *
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param scopeName  (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun propertymappingsScopeListRequestConfig(managed: kotlin.collections.List<kotlin.String>?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, scopeName: kotlin.String?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (managed != null) {
                    put("managed", toMultiValue(managed.toList(), "multi"))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (scopeName != null) {
                    put("scope_name", listOf(scopeName.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/scope/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @param patchedScopeMappingRequest  (optional)
     * @return ScopeMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScopePartialUpdate(pmUuid: java.util.UUID, patchedScopeMappingRequest: PatchedScopeMappingRequest? = null) : ScopeMapping {
        val localVarResponse = propertymappingsScopePartialUpdateWithHttpInfo(pmUuid = pmUuid, patchedScopeMappingRequest = patchedScopeMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ScopeMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @param patchedScopeMappingRequest  (optional)
     * @return ApiResponse<ScopeMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScopePartialUpdateWithHttpInfo(pmUuid: java.util.UUID, patchedScopeMappingRequest: PatchedScopeMappingRequest?) : ApiResponse<ScopeMapping?> {
        val localVariableConfig = propertymappingsScopePartialUpdateRequestConfig(pmUuid = pmUuid, patchedScopeMappingRequest = patchedScopeMappingRequest)

        return request<PatchedScopeMappingRequest, ScopeMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScopePartialUpdate
     *
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @param patchedScopeMappingRequest  (optional)
     * @return RequestConfig
     */
    fun propertymappingsScopePartialUpdateRequestConfig(pmUuid: java.util.UUID, patchedScopeMappingRequest: PatchedScopeMappingRequest?) : RequestConfig<PatchedScopeMappingRequest> {
        val localVariableBody = patchedScopeMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/propertymappings/scope/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @return ScopeMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScopeRetrieve(pmUuid: java.util.UUID) : ScopeMapping {
        val localVarResponse = propertymappingsScopeRetrieveWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ScopeMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @return ApiResponse<ScopeMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScopeRetrieveWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<ScopeMapping?> {
        val localVariableConfig = propertymappingsScopeRetrieveRequestConfig(pmUuid = pmUuid)

        return request<Unit, ScopeMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScopeRetrieve
     *
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @return RequestConfig
     */
    fun propertymappingsScopeRetrieveRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/scope/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @param scopeMappingRequest 
     * @return ScopeMapping
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScopeUpdate(pmUuid: java.util.UUID, scopeMappingRequest: ScopeMappingRequest) : ScopeMapping {
        val localVarResponse = propertymappingsScopeUpdateWithHttpInfo(pmUuid = pmUuid, scopeMappingRequest = scopeMappingRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ScopeMapping
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ScopeMapping Viewset
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @param scopeMappingRequest 
     * @return ApiResponse<ScopeMapping?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScopeUpdateWithHttpInfo(pmUuid: java.util.UUID, scopeMappingRequest: ScopeMappingRequest) : ApiResponse<ScopeMapping?> {
        val localVariableConfig = propertymappingsScopeUpdateRequestConfig(pmUuid = pmUuid, scopeMappingRequest = scopeMappingRequest)

        return request<ScopeMappingRequest, ScopeMapping>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScopeUpdate
     *
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @param scopeMappingRequest 
     * @return RequestConfig
     */
    fun propertymappingsScopeUpdateRequestConfig(pmUuid: java.util.UUID, scopeMappingRequest: ScopeMappingRequest) : RequestConfig<ScopeMappingRequest> {
        val localVariableBody = scopeMappingRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/propertymappings/scope/{pm_uuid}/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun propertymappingsScopeUsedByList(pmUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = propertymappingsScopeUsedByListWithHttpInfo(pmUuid = pmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun propertymappingsScopeUsedByListWithHttpInfo(pmUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = propertymappingsScopeUsedByListRequestConfig(pmUuid = pmUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation propertymappingsScopeUsedByList
     *
     * @param pmUuid A UUID string identifying this Scope Mapping.
     * @return RequestConfig
     */
    fun propertymappingsScopeUsedByListRequestConfig(pmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/propertymappings/scope/{pm_uuid}/used_by/".replace("{"+"pm_uuid"+"}", encodeURIComponent(pmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
