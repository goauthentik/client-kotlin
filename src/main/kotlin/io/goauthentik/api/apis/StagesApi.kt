/**
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2023.10.2
 * Contact: hello@goauthentik.io
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.AuthenticateWebAuthnStage
import io.goauthentik.api.models.AuthenticateWebAuthnStageRequest
import io.goauthentik.api.models.AuthenticatorDuoStage
import io.goauthentik.api.models.AuthenticatorDuoStageDeviceImportResponse
import io.goauthentik.api.models.AuthenticatorDuoStageManualDeviceImportRequest
import io.goauthentik.api.models.AuthenticatorDuoStageRequest
import io.goauthentik.api.models.AuthenticatorSMSStage
import io.goauthentik.api.models.AuthenticatorSMSStageRequest
import io.goauthentik.api.models.AuthenticatorStaticStage
import io.goauthentik.api.models.AuthenticatorStaticStageRequest
import io.goauthentik.api.models.AuthenticatorTOTPStage
import io.goauthentik.api.models.AuthenticatorTOTPStageRequest
import io.goauthentik.api.models.AuthenticatorValidateStage
import io.goauthentik.api.models.AuthenticatorValidateStageRequest
import io.goauthentik.api.models.CaptchaStage
import io.goauthentik.api.models.CaptchaStageRequest
import io.goauthentik.api.models.ConsentStage
import io.goauthentik.api.models.ConsentStageRequest
import io.goauthentik.api.models.DenyStage
import io.goauthentik.api.models.DenyStageRequest
import io.goauthentik.api.models.DummyStage
import io.goauthentik.api.models.DummyStageRequest
import io.goauthentik.api.models.DuoDeviceEnrollmentStatus
import io.goauthentik.api.models.EmailStage
import io.goauthentik.api.models.EmailStageRequest
import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.IdentificationStage
import io.goauthentik.api.models.IdentificationStageRequest
import io.goauthentik.api.models.Invitation
import io.goauthentik.api.models.InvitationRequest
import io.goauthentik.api.models.InvitationStage
import io.goauthentik.api.models.InvitationStageRequest
import io.goauthentik.api.models.PaginatedAuthenticateWebAuthnStageList
import io.goauthentik.api.models.PaginatedAuthenticatorDuoStageList
import io.goauthentik.api.models.PaginatedAuthenticatorSMSStageList
import io.goauthentik.api.models.PaginatedAuthenticatorStaticStageList
import io.goauthentik.api.models.PaginatedAuthenticatorTOTPStageList
import io.goauthentik.api.models.PaginatedAuthenticatorValidateStageList
import io.goauthentik.api.models.PaginatedCaptchaStageList
import io.goauthentik.api.models.PaginatedConsentStageList
import io.goauthentik.api.models.PaginatedDenyStageList
import io.goauthentik.api.models.PaginatedDummyStageList
import io.goauthentik.api.models.PaginatedEmailStageList
import io.goauthentik.api.models.PaginatedIdentificationStageList
import io.goauthentik.api.models.PaginatedInvitationList
import io.goauthentik.api.models.PaginatedInvitationStageList
import io.goauthentik.api.models.PaginatedPasswordStageList
import io.goauthentik.api.models.PaginatedPromptList
import io.goauthentik.api.models.PaginatedPromptStageList
import io.goauthentik.api.models.PaginatedStageList
import io.goauthentik.api.models.PaginatedUserDeleteStageList
import io.goauthentik.api.models.PaginatedUserLoginStageList
import io.goauthentik.api.models.PaginatedUserLogoutStageList
import io.goauthentik.api.models.PaginatedUserWriteStageList
import io.goauthentik.api.models.PasswordStage
import io.goauthentik.api.models.PasswordStageRequest
import io.goauthentik.api.models.PatchedAuthenticateWebAuthnStageRequest
import io.goauthentik.api.models.PatchedAuthenticatorDuoStageRequest
import io.goauthentik.api.models.PatchedAuthenticatorSMSStageRequest
import io.goauthentik.api.models.PatchedAuthenticatorStaticStageRequest
import io.goauthentik.api.models.PatchedAuthenticatorTOTPStageRequest
import io.goauthentik.api.models.PatchedAuthenticatorValidateStageRequest
import io.goauthentik.api.models.PatchedCaptchaStageRequest
import io.goauthentik.api.models.PatchedConsentStageRequest
import io.goauthentik.api.models.PatchedDenyStageRequest
import io.goauthentik.api.models.PatchedDummyStageRequest
import io.goauthentik.api.models.PatchedEmailStageRequest
import io.goauthentik.api.models.PatchedIdentificationStageRequest
import io.goauthentik.api.models.PatchedInvitationRequest
import io.goauthentik.api.models.PatchedInvitationStageRequest
import io.goauthentik.api.models.PatchedPasswordStageRequest
import io.goauthentik.api.models.PatchedPromptRequest
import io.goauthentik.api.models.PatchedPromptStageRequest
import io.goauthentik.api.models.PatchedUserDeleteStageRequest
import io.goauthentik.api.models.PatchedUserLoginStageRequest
import io.goauthentik.api.models.PatchedUserLogoutStageRequest
import io.goauthentik.api.models.PatchedUserWriteStageRequest
import io.goauthentik.api.models.Prompt
import io.goauthentik.api.models.PromptChallenge
import io.goauthentik.api.models.PromptRequest
import io.goauthentik.api.models.PromptStage
import io.goauthentik.api.models.PromptStageRequest
import io.goauthentik.api.models.Stage
import io.goauthentik.api.models.TypeCreate
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.UserDeleteStage
import io.goauthentik.api.models.UserDeleteStageRequest
import io.goauthentik.api.models.UserLoginStage
import io.goauthentik.api.models.UserLoginStageRequest
import io.goauthentik.api.models.UserLogoutStage
import io.goauthentik.api.models.UserLogoutStageRequest
import io.goauthentik.api.models.UserSetting
import io.goauthentik.api.models.UserWriteStage
import io.goauthentik.api.models.UserWriteStageRequest
import io.goauthentik.api.models.ValidationError

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class StagesApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * Stage Viewset
     * @param stageUuid A UUID string identifying this stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAllDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesAllDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Stage Viewset
     * @param stageUuid A UUID string identifying this stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAllDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesAllDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAllDestroy
     *
     * @param stageUuid A UUID string identifying this stage.
     * @return RequestConfig
     */
    fun stagesAllDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/all/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Stage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAllList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedStageList {
        val localVarResponse = stagesAllListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Stage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAllListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedStageList?> {
        val localVariableConfig = stagesAllListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAllList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun stagesAllListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/all/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Stage Viewset
     * @param stageUuid A UUID string identifying this stage.
     * @return Stage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAllRetrieve(stageUuid: java.util.UUID) : Stage {
        val localVarResponse = stagesAllRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Stage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Stage Viewset
     * @param stageUuid A UUID string identifying this stage.
     * @return ApiResponse<Stage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAllRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Stage?> {
        val localVariableConfig = stagesAllRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, Stage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAllRetrieve
     *
     * @param stageUuid A UUID string identifying this stage.
     * @return RequestConfig
     */
    fun stagesAllRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/all/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all creatable stage types
     * @return kotlin.collections.List<TypeCreate>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAllTypesList() : kotlin.collections.List<TypeCreate> {
        val localVarResponse = stagesAllTypesListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TypeCreate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all creatable stage types
     * @return ApiResponse<kotlin.collections.List<TypeCreate>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAllTypesListWithHttpInfo() : ApiResponse<kotlin.collections.List<TypeCreate>?> {
        val localVariableConfig = stagesAllTypesListRequestConfig()

        return request<Unit, kotlin.collections.List<TypeCreate>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAllTypesList
     *
     * @return RequestConfig
     */
    fun stagesAllTypesListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/all/types/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAllUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesAllUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAllUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesAllUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAllUsedByList
     *
     * @param stageUuid A UUID string identifying this stage.
     * @return RequestConfig
     */
    fun stagesAllUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/all/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all stages the user can configure
     * @return kotlin.collections.List<UserSetting>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAllUserSettingsList() : kotlin.collections.List<UserSetting> {
        val localVarResponse = stagesAllUserSettingsListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UserSetting>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all stages the user can configure
     * @return ApiResponse<kotlin.collections.List<UserSetting>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAllUserSettingsListWithHttpInfo() : ApiResponse<kotlin.collections.List<UserSetting>?> {
        val localVariableConfig = stagesAllUserSettingsListRequestConfig()

        return request<Unit, kotlin.collections.List<UserSetting>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAllUserSettingsList
     *
     * @return RequestConfig
     */
    fun stagesAllUserSettingsListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/all/user_settings/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param authenticatorDuoStageRequest 
     * @return AuthenticatorDuoStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorDuoCreate(authenticatorDuoStageRequest: AuthenticatorDuoStageRequest) : AuthenticatorDuoStage {
        val localVarResponse = stagesAuthenticatorDuoCreateWithHttpInfo(authenticatorDuoStageRequest = authenticatorDuoStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorDuoStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param authenticatorDuoStageRequest 
     * @return ApiResponse<AuthenticatorDuoStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorDuoCreateWithHttpInfo(authenticatorDuoStageRequest: AuthenticatorDuoStageRequest) : ApiResponse<AuthenticatorDuoStage?> {
        val localVariableConfig = stagesAuthenticatorDuoCreateRequestConfig(authenticatorDuoStageRequest = authenticatorDuoStageRequest)

        return request<AuthenticatorDuoStageRequest, AuthenticatorDuoStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorDuoCreate
     *
     * @param authenticatorDuoStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorDuoCreateRequestConfig(authenticatorDuoStageRequest: AuthenticatorDuoStageRequest) : RequestConfig<AuthenticatorDuoStageRequest> {
        val localVariableBody = authenticatorDuoStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/authenticator/duo/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorDuoDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesAuthenticatorDuoDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorDuoDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesAuthenticatorDuoDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorDuoDestroy
     *
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorDuoDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/authenticator/duo/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Check enrollment status of user details in current session
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return DuoDeviceEnrollmentStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorDuoEnrollmentStatusCreate(stageUuid: java.util.UUID) : DuoDeviceEnrollmentStatus {
        val localVarResponse = stagesAuthenticatorDuoEnrollmentStatusCreateWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DuoDeviceEnrollmentStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Check enrollment status of user details in current session
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return ApiResponse<DuoDeviceEnrollmentStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorDuoEnrollmentStatusCreateWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<DuoDeviceEnrollmentStatus?> {
        val localVariableConfig = stagesAuthenticatorDuoEnrollmentStatusCreateRequestConfig(stageUuid = stageUuid)

        return request<Unit, DuoDeviceEnrollmentStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorDuoEnrollmentStatusCreate
     *
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorDuoEnrollmentStatusCreateRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/authenticator/duo/{stage_uuid}/enrollment_status/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Import duo devices into authentik
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @param authenticatorDuoStageManualDeviceImportRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorDuoImportDeviceManualCreate(stageUuid: java.util.UUID, authenticatorDuoStageManualDeviceImportRequest: AuthenticatorDuoStageManualDeviceImportRequest) : Unit {
        val localVarResponse = stagesAuthenticatorDuoImportDeviceManualCreateWithHttpInfo(stageUuid = stageUuid, authenticatorDuoStageManualDeviceImportRequest = authenticatorDuoStageManualDeviceImportRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Import duo devices into authentik
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @param authenticatorDuoStageManualDeviceImportRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorDuoImportDeviceManualCreateWithHttpInfo(stageUuid: java.util.UUID, authenticatorDuoStageManualDeviceImportRequest: AuthenticatorDuoStageManualDeviceImportRequest) : ApiResponse<Unit?> {
        val localVariableConfig = stagesAuthenticatorDuoImportDeviceManualCreateRequestConfig(stageUuid = stageUuid, authenticatorDuoStageManualDeviceImportRequest = authenticatorDuoStageManualDeviceImportRequest)

        return request<AuthenticatorDuoStageManualDeviceImportRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorDuoImportDeviceManualCreate
     *
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @param authenticatorDuoStageManualDeviceImportRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorDuoImportDeviceManualCreateRequestConfig(stageUuid: java.util.UUID, authenticatorDuoStageManualDeviceImportRequest: AuthenticatorDuoStageManualDeviceImportRequest) : RequestConfig<AuthenticatorDuoStageManualDeviceImportRequest> {
        val localVariableBody = authenticatorDuoStageManualDeviceImportRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/authenticator/duo/{stage_uuid}/import_device_manual/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Import duo devices into authentik
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return AuthenticatorDuoStageDeviceImportResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorDuoImportDevicesAutomaticCreate(stageUuid: java.util.UUID) : AuthenticatorDuoStageDeviceImportResponse {
        val localVarResponse = stagesAuthenticatorDuoImportDevicesAutomaticCreateWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorDuoStageDeviceImportResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Import duo devices into authentik
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return ApiResponse<AuthenticatorDuoStageDeviceImportResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorDuoImportDevicesAutomaticCreateWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<AuthenticatorDuoStageDeviceImportResponse?> {
        val localVariableConfig = stagesAuthenticatorDuoImportDevicesAutomaticCreateRequestConfig(stageUuid = stageUuid)

        return request<Unit, AuthenticatorDuoStageDeviceImportResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorDuoImportDevicesAutomaticCreate
     *
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorDuoImportDevicesAutomaticCreateRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/authenticator/duo/{stage_uuid}/import_devices_automatic/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param apiHostname  (optional)
     * @param clientId  (optional)
     * @param configureFlow  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedAuthenticatorDuoStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorDuoList(apiHostname: kotlin.String? = null, clientId: kotlin.String? = null, configureFlow: java.util.UUID? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedAuthenticatorDuoStageList {
        val localVarResponse = stagesAuthenticatorDuoListWithHttpInfo(apiHostname = apiHostname, clientId = clientId, configureFlow = configureFlow, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAuthenticatorDuoStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param apiHostname  (optional)
     * @param clientId  (optional)
     * @param configureFlow  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedAuthenticatorDuoStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorDuoListWithHttpInfo(apiHostname: kotlin.String?, clientId: kotlin.String?, configureFlow: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedAuthenticatorDuoStageList?> {
        val localVariableConfig = stagesAuthenticatorDuoListRequestConfig(apiHostname = apiHostname, clientId = clientId, configureFlow = configureFlow, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedAuthenticatorDuoStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorDuoList
     *
     * @param apiHostname  (optional)
     * @param clientId  (optional)
     * @param configureFlow  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorDuoListRequestConfig(apiHostname: kotlin.String?, clientId: kotlin.String?, configureFlow: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (apiHostname != null) {
                    put("api_hostname", listOf(apiHostname.toString()))
                }
                if (clientId != null) {
                    put("client_id", listOf(clientId.toString()))
                }
                if (configureFlow != null) {
                    put("configure_flow", listOf(configureFlow.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/duo/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @param patchedAuthenticatorDuoStageRequest  (optional)
     * @return AuthenticatorDuoStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorDuoPartialUpdate(stageUuid: java.util.UUID, patchedAuthenticatorDuoStageRequest: PatchedAuthenticatorDuoStageRequest? = null) : AuthenticatorDuoStage {
        val localVarResponse = stagesAuthenticatorDuoPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedAuthenticatorDuoStageRequest = patchedAuthenticatorDuoStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorDuoStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @param patchedAuthenticatorDuoStageRequest  (optional)
     * @return ApiResponse<AuthenticatorDuoStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorDuoPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedAuthenticatorDuoStageRequest: PatchedAuthenticatorDuoStageRequest?) : ApiResponse<AuthenticatorDuoStage?> {
        val localVariableConfig = stagesAuthenticatorDuoPartialUpdateRequestConfig(stageUuid = stageUuid, patchedAuthenticatorDuoStageRequest = patchedAuthenticatorDuoStageRequest)

        return request<PatchedAuthenticatorDuoStageRequest, AuthenticatorDuoStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorDuoPartialUpdate
     *
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @param patchedAuthenticatorDuoStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorDuoPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedAuthenticatorDuoStageRequest: PatchedAuthenticatorDuoStageRequest?) : RequestConfig<PatchedAuthenticatorDuoStageRequest> {
        val localVariableBody = patchedAuthenticatorDuoStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/authenticator/duo/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return AuthenticatorDuoStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorDuoRetrieve(stageUuid: java.util.UUID) : AuthenticatorDuoStage {
        val localVarResponse = stagesAuthenticatorDuoRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorDuoStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return ApiResponse<AuthenticatorDuoStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorDuoRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<AuthenticatorDuoStage?> {
        val localVariableConfig = stagesAuthenticatorDuoRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, AuthenticatorDuoStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorDuoRetrieve
     *
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorDuoRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/duo/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @param authenticatorDuoStageRequest 
     * @return AuthenticatorDuoStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorDuoUpdate(stageUuid: java.util.UUID, authenticatorDuoStageRequest: AuthenticatorDuoStageRequest) : AuthenticatorDuoStage {
        val localVarResponse = stagesAuthenticatorDuoUpdateWithHttpInfo(stageUuid = stageUuid, authenticatorDuoStageRequest = authenticatorDuoStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorDuoStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorDuoStage Viewset
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @param authenticatorDuoStageRequest 
     * @return ApiResponse<AuthenticatorDuoStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorDuoUpdateWithHttpInfo(stageUuid: java.util.UUID, authenticatorDuoStageRequest: AuthenticatorDuoStageRequest) : ApiResponse<AuthenticatorDuoStage?> {
        val localVariableConfig = stagesAuthenticatorDuoUpdateRequestConfig(stageUuid = stageUuid, authenticatorDuoStageRequest = authenticatorDuoStageRequest)

        return request<AuthenticatorDuoStageRequest, AuthenticatorDuoStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorDuoUpdate
     *
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @param authenticatorDuoStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorDuoUpdateRequestConfig(stageUuid: java.util.UUID, authenticatorDuoStageRequest: AuthenticatorDuoStageRequest) : RequestConfig<AuthenticatorDuoStageRequest> {
        val localVariableBody = authenticatorDuoStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/authenticator/duo/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorDuoUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesAuthenticatorDuoUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorDuoUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesAuthenticatorDuoUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorDuoUsedByList
     *
     * @param stageUuid A UUID string identifying this Duo Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorDuoUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/duo/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param authenticatorSMSStageRequest 
     * @return AuthenticatorSMSStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorSmsCreate(authenticatorSMSStageRequest: AuthenticatorSMSStageRequest) : AuthenticatorSMSStage {
        val localVarResponse = stagesAuthenticatorSmsCreateWithHttpInfo(authenticatorSMSStageRequest = authenticatorSMSStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorSMSStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param authenticatorSMSStageRequest 
     * @return ApiResponse<AuthenticatorSMSStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorSmsCreateWithHttpInfo(authenticatorSMSStageRequest: AuthenticatorSMSStageRequest) : ApiResponse<AuthenticatorSMSStage?> {
        val localVariableConfig = stagesAuthenticatorSmsCreateRequestConfig(authenticatorSMSStageRequest = authenticatorSMSStageRequest)

        return request<AuthenticatorSMSStageRequest, AuthenticatorSMSStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorSmsCreate
     *
     * @param authenticatorSMSStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorSmsCreateRequestConfig(authenticatorSMSStageRequest: AuthenticatorSMSStageRequest) : RequestConfig<AuthenticatorSMSStageRequest> {
        val localVariableBody = authenticatorSMSStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/authenticator/sms/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorSmsDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesAuthenticatorSmsDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorSmsDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesAuthenticatorSmsDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorSmsDestroy
     *
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorSmsDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/authenticator/sms/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter authType
     */
     enum class AuthType_stagesAuthenticatorSmsList(val value: kotlin.String) {
         @Json(name = "basic") basic("basic"),
         @Json(name = "bearer") bearer("bearer"),
     }

    /**
     * enum for parameter provider
     */
     enum class Provider_stagesAuthenticatorSmsList(val value: kotlin.String) {
         @Json(name = "generic") generic("generic"),
         @Json(name = "twilio") twilio("twilio"),
     }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param accountSid  (optional)
     * @param auth  (optional)
     * @param authPassword  (optional)
     * @param authType * &#x60;basic&#x60; - Basic * &#x60;bearer&#x60; - Bearer (optional)
     * @param configureFlow  (optional)
     * @param friendlyName  (optional)
     * @param fromNumber  (optional)
     * @param mapping  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param provider * &#x60;twilio&#x60; - Twilio * &#x60;generic&#x60; - Generic (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param verifyOnly  (optional)
     * @return PaginatedAuthenticatorSMSStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorSmsList(accountSid: kotlin.String? = null, auth: kotlin.String? = null, authPassword: kotlin.String? = null, authType: AuthType_stagesAuthenticatorSmsList? = null, configureFlow: java.util.UUID? = null, friendlyName: kotlin.String? = null, fromNumber: kotlin.String? = null, mapping: java.util.UUID? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, provider: Provider_stagesAuthenticatorSmsList? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null, verifyOnly: kotlin.Boolean? = null) : PaginatedAuthenticatorSMSStageList {
        val localVarResponse = stagesAuthenticatorSmsListWithHttpInfo(accountSid = accountSid, auth = auth, authPassword = authPassword, authType = authType, configureFlow = configureFlow, friendlyName = friendlyName, fromNumber = fromNumber, mapping = mapping, name = name, ordering = ordering, page = page, pageSize = pageSize, provider = provider, search = search, stageUuid = stageUuid, verifyOnly = verifyOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAuthenticatorSMSStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param accountSid  (optional)
     * @param auth  (optional)
     * @param authPassword  (optional)
     * @param authType * &#x60;basic&#x60; - Basic * &#x60;bearer&#x60; - Bearer (optional)
     * @param configureFlow  (optional)
     * @param friendlyName  (optional)
     * @param fromNumber  (optional)
     * @param mapping  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param provider * &#x60;twilio&#x60; - Twilio * &#x60;generic&#x60; - Generic (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param verifyOnly  (optional)
     * @return ApiResponse<PaginatedAuthenticatorSMSStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorSmsListWithHttpInfo(accountSid: kotlin.String?, auth: kotlin.String?, authPassword: kotlin.String?, authType: AuthType_stagesAuthenticatorSmsList?, configureFlow: java.util.UUID?, friendlyName: kotlin.String?, fromNumber: kotlin.String?, mapping: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, provider: Provider_stagesAuthenticatorSmsList?, search: kotlin.String?, stageUuid: java.util.UUID?, verifyOnly: kotlin.Boolean?) : ApiResponse<PaginatedAuthenticatorSMSStageList?> {
        val localVariableConfig = stagesAuthenticatorSmsListRequestConfig(accountSid = accountSid, auth = auth, authPassword = authPassword, authType = authType, configureFlow = configureFlow, friendlyName = friendlyName, fromNumber = fromNumber, mapping = mapping, name = name, ordering = ordering, page = page, pageSize = pageSize, provider = provider, search = search, stageUuid = stageUuid, verifyOnly = verifyOnly)

        return request<Unit, PaginatedAuthenticatorSMSStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorSmsList
     *
     * @param accountSid  (optional)
     * @param auth  (optional)
     * @param authPassword  (optional)
     * @param authType * &#x60;basic&#x60; - Basic * &#x60;bearer&#x60; - Bearer (optional)
     * @param configureFlow  (optional)
     * @param friendlyName  (optional)
     * @param fromNumber  (optional)
     * @param mapping  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param provider * &#x60;twilio&#x60; - Twilio * &#x60;generic&#x60; - Generic (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param verifyOnly  (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorSmsListRequestConfig(accountSid: kotlin.String?, auth: kotlin.String?, authPassword: kotlin.String?, authType: AuthType_stagesAuthenticatorSmsList?, configureFlow: java.util.UUID?, friendlyName: kotlin.String?, fromNumber: kotlin.String?, mapping: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, provider: Provider_stagesAuthenticatorSmsList?, search: kotlin.String?, stageUuid: java.util.UUID?, verifyOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountSid != null) {
                    put("account_sid", listOf(accountSid.toString()))
                }
                if (auth != null) {
                    put("auth", listOf(auth.toString()))
                }
                if (authPassword != null) {
                    put("auth_password", listOf(authPassword.toString()))
                }
                if (authType != null) {
                    put("auth_type", listOf(authType.toString()))
                }
                if (configureFlow != null) {
                    put("configure_flow", listOf(configureFlow.toString()))
                }
                if (friendlyName != null) {
                    put("friendly_name", listOf(friendlyName.toString()))
                }
                if (fromNumber != null) {
                    put("from_number", listOf(fromNumber.toString()))
                }
                if (mapping != null) {
                    put("mapping", listOf(mapping.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (provider != null) {
                    put("provider", listOf(provider.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
                if (verifyOnly != null) {
                    put("verify_only", listOf(verifyOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/sms/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @param patchedAuthenticatorSMSStageRequest  (optional)
     * @return AuthenticatorSMSStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorSmsPartialUpdate(stageUuid: java.util.UUID, patchedAuthenticatorSMSStageRequest: PatchedAuthenticatorSMSStageRequest? = null) : AuthenticatorSMSStage {
        val localVarResponse = stagesAuthenticatorSmsPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedAuthenticatorSMSStageRequest = patchedAuthenticatorSMSStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorSMSStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @param patchedAuthenticatorSMSStageRequest  (optional)
     * @return ApiResponse<AuthenticatorSMSStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorSmsPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedAuthenticatorSMSStageRequest: PatchedAuthenticatorSMSStageRequest?) : ApiResponse<AuthenticatorSMSStage?> {
        val localVariableConfig = stagesAuthenticatorSmsPartialUpdateRequestConfig(stageUuid = stageUuid, patchedAuthenticatorSMSStageRequest = patchedAuthenticatorSMSStageRequest)

        return request<PatchedAuthenticatorSMSStageRequest, AuthenticatorSMSStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorSmsPartialUpdate
     *
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @param patchedAuthenticatorSMSStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorSmsPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedAuthenticatorSMSStageRequest: PatchedAuthenticatorSMSStageRequest?) : RequestConfig<PatchedAuthenticatorSMSStageRequest> {
        val localVariableBody = patchedAuthenticatorSMSStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/authenticator/sms/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @return AuthenticatorSMSStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorSmsRetrieve(stageUuid: java.util.UUID) : AuthenticatorSMSStage {
        val localVarResponse = stagesAuthenticatorSmsRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorSMSStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @return ApiResponse<AuthenticatorSMSStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorSmsRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<AuthenticatorSMSStage?> {
        val localVariableConfig = stagesAuthenticatorSmsRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, AuthenticatorSMSStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorSmsRetrieve
     *
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorSmsRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/sms/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @param authenticatorSMSStageRequest 
     * @return AuthenticatorSMSStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorSmsUpdate(stageUuid: java.util.UUID, authenticatorSMSStageRequest: AuthenticatorSMSStageRequest) : AuthenticatorSMSStage {
        val localVarResponse = stagesAuthenticatorSmsUpdateWithHttpInfo(stageUuid = stageUuid, authenticatorSMSStageRequest = authenticatorSMSStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorSMSStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorSMSStage Viewset
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @param authenticatorSMSStageRequest 
     * @return ApiResponse<AuthenticatorSMSStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorSmsUpdateWithHttpInfo(stageUuid: java.util.UUID, authenticatorSMSStageRequest: AuthenticatorSMSStageRequest) : ApiResponse<AuthenticatorSMSStage?> {
        val localVariableConfig = stagesAuthenticatorSmsUpdateRequestConfig(stageUuid = stageUuid, authenticatorSMSStageRequest = authenticatorSMSStageRequest)

        return request<AuthenticatorSMSStageRequest, AuthenticatorSMSStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorSmsUpdate
     *
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @param authenticatorSMSStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorSmsUpdateRequestConfig(stageUuid: java.util.UUID, authenticatorSMSStageRequest: AuthenticatorSMSStageRequest) : RequestConfig<AuthenticatorSMSStageRequest> {
        val localVariableBody = authenticatorSMSStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/authenticator/sms/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorSmsUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesAuthenticatorSmsUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorSmsUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesAuthenticatorSmsUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorSmsUsedByList
     *
     * @param stageUuid A UUID string identifying this SMS Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorSmsUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/sms/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param authenticatorStaticStageRequest 
     * @return AuthenticatorStaticStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorStaticCreate(authenticatorStaticStageRequest: AuthenticatorStaticStageRequest) : AuthenticatorStaticStage {
        val localVarResponse = stagesAuthenticatorStaticCreateWithHttpInfo(authenticatorStaticStageRequest = authenticatorStaticStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorStaticStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param authenticatorStaticStageRequest 
     * @return ApiResponse<AuthenticatorStaticStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorStaticCreateWithHttpInfo(authenticatorStaticStageRequest: AuthenticatorStaticStageRequest) : ApiResponse<AuthenticatorStaticStage?> {
        val localVariableConfig = stagesAuthenticatorStaticCreateRequestConfig(authenticatorStaticStageRequest = authenticatorStaticStageRequest)

        return request<AuthenticatorStaticStageRequest, AuthenticatorStaticStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorStaticCreate
     *
     * @param authenticatorStaticStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorStaticCreateRequestConfig(authenticatorStaticStageRequest: AuthenticatorStaticStageRequest) : RequestConfig<AuthenticatorStaticStageRequest> {
        val localVariableBody = authenticatorStaticStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/authenticator/static/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorStaticDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesAuthenticatorStaticDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorStaticDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesAuthenticatorStaticDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorStaticDestroy
     *
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorStaticDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/authenticator/static/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param configureFlow  (optional)
     * @param friendlyName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param tokenCount  (optional)
     * @param tokenLength  (optional)
     * @return PaginatedAuthenticatorStaticStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorStaticList(configureFlow: java.util.UUID? = null, friendlyName: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null, tokenCount: kotlin.Int? = null, tokenLength: kotlin.Int? = null) : PaginatedAuthenticatorStaticStageList {
        val localVarResponse = stagesAuthenticatorStaticListWithHttpInfo(configureFlow = configureFlow, friendlyName = friendlyName, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid, tokenCount = tokenCount, tokenLength = tokenLength)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAuthenticatorStaticStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param configureFlow  (optional)
     * @param friendlyName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param tokenCount  (optional)
     * @param tokenLength  (optional)
     * @return ApiResponse<PaginatedAuthenticatorStaticStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorStaticListWithHttpInfo(configureFlow: java.util.UUID?, friendlyName: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?, tokenCount: kotlin.Int?, tokenLength: kotlin.Int?) : ApiResponse<PaginatedAuthenticatorStaticStageList?> {
        val localVariableConfig = stagesAuthenticatorStaticListRequestConfig(configureFlow = configureFlow, friendlyName = friendlyName, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid, tokenCount = tokenCount, tokenLength = tokenLength)

        return request<Unit, PaginatedAuthenticatorStaticStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorStaticList
     *
     * @param configureFlow  (optional)
     * @param friendlyName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param tokenCount  (optional)
     * @param tokenLength  (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorStaticListRequestConfig(configureFlow: java.util.UUID?, friendlyName: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?, tokenCount: kotlin.Int?, tokenLength: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (configureFlow != null) {
                    put("configure_flow", listOf(configureFlow.toString()))
                }
                if (friendlyName != null) {
                    put("friendly_name", listOf(friendlyName.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
                if (tokenCount != null) {
                    put("token_count", listOf(tokenCount.toString()))
                }
                if (tokenLength != null) {
                    put("token_length", listOf(tokenLength.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/static/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @param patchedAuthenticatorStaticStageRequest  (optional)
     * @return AuthenticatorStaticStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorStaticPartialUpdate(stageUuid: java.util.UUID, patchedAuthenticatorStaticStageRequest: PatchedAuthenticatorStaticStageRequest? = null) : AuthenticatorStaticStage {
        val localVarResponse = stagesAuthenticatorStaticPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedAuthenticatorStaticStageRequest = patchedAuthenticatorStaticStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorStaticStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @param patchedAuthenticatorStaticStageRequest  (optional)
     * @return ApiResponse<AuthenticatorStaticStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorStaticPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedAuthenticatorStaticStageRequest: PatchedAuthenticatorStaticStageRequest?) : ApiResponse<AuthenticatorStaticStage?> {
        val localVariableConfig = stagesAuthenticatorStaticPartialUpdateRequestConfig(stageUuid = stageUuid, patchedAuthenticatorStaticStageRequest = patchedAuthenticatorStaticStageRequest)

        return request<PatchedAuthenticatorStaticStageRequest, AuthenticatorStaticStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorStaticPartialUpdate
     *
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @param patchedAuthenticatorStaticStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorStaticPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedAuthenticatorStaticStageRequest: PatchedAuthenticatorStaticStageRequest?) : RequestConfig<PatchedAuthenticatorStaticStageRequest> {
        val localVariableBody = patchedAuthenticatorStaticStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/authenticator/static/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @return AuthenticatorStaticStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorStaticRetrieve(stageUuid: java.util.UUID) : AuthenticatorStaticStage {
        val localVarResponse = stagesAuthenticatorStaticRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorStaticStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @return ApiResponse<AuthenticatorStaticStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorStaticRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<AuthenticatorStaticStage?> {
        val localVariableConfig = stagesAuthenticatorStaticRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, AuthenticatorStaticStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorStaticRetrieve
     *
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorStaticRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/static/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @param authenticatorStaticStageRequest 
     * @return AuthenticatorStaticStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorStaticUpdate(stageUuid: java.util.UUID, authenticatorStaticStageRequest: AuthenticatorStaticStageRequest) : AuthenticatorStaticStage {
        val localVarResponse = stagesAuthenticatorStaticUpdateWithHttpInfo(stageUuid = stageUuid, authenticatorStaticStageRequest = authenticatorStaticStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorStaticStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorStaticStage Viewset
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @param authenticatorStaticStageRequest 
     * @return ApiResponse<AuthenticatorStaticStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorStaticUpdateWithHttpInfo(stageUuid: java.util.UUID, authenticatorStaticStageRequest: AuthenticatorStaticStageRequest) : ApiResponse<AuthenticatorStaticStage?> {
        val localVariableConfig = stagesAuthenticatorStaticUpdateRequestConfig(stageUuid = stageUuid, authenticatorStaticStageRequest = authenticatorStaticStageRequest)

        return request<AuthenticatorStaticStageRequest, AuthenticatorStaticStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorStaticUpdate
     *
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @param authenticatorStaticStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorStaticUpdateRequestConfig(stageUuid: java.util.UUID, authenticatorStaticStageRequest: AuthenticatorStaticStageRequest) : RequestConfig<AuthenticatorStaticStageRequest> {
        val localVariableBody = authenticatorStaticStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/authenticator/static/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorStaticUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesAuthenticatorStaticUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorStaticUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesAuthenticatorStaticUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorStaticUsedByList
     *
     * @param stageUuid A UUID string identifying this Static Authenticator Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorStaticUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/static/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param authenticatorTOTPStageRequest 
     * @return AuthenticatorTOTPStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorTotpCreate(authenticatorTOTPStageRequest: AuthenticatorTOTPStageRequest) : AuthenticatorTOTPStage {
        val localVarResponse = stagesAuthenticatorTotpCreateWithHttpInfo(authenticatorTOTPStageRequest = authenticatorTOTPStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorTOTPStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param authenticatorTOTPStageRequest 
     * @return ApiResponse<AuthenticatorTOTPStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorTotpCreateWithHttpInfo(authenticatorTOTPStageRequest: AuthenticatorTOTPStageRequest) : ApiResponse<AuthenticatorTOTPStage?> {
        val localVariableConfig = stagesAuthenticatorTotpCreateRequestConfig(authenticatorTOTPStageRequest = authenticatorTOTPStageRequest)

        return request<AuthenticatorTOTPStageRequest, AuthenticatorTOTPStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorTotpCreate
     *
     * @param authenticatorTOTPStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorTotpCreateRequestConfig(authenticatorTOTPStageRequest: AuthenticatorTOTPStageRequest) : RequestConfig<AuthenticatorTOTPStageRequest> {
        val localVariableBody = authenticatorTOTPStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/authenticator/totp/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorTotpDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesAuthenticatorTotpDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorTotpDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesAuthenticatorTotpDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorTotpDestroy
     *
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorTotpDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/authenticator/totp/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter digits
     */
     enum class Digits_stagesAuthenticatorTotpList(val value: kotlin.Int) {
         @Json(name = "6") _6(6),
         @Json(name = "8") _8(8),
     }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param configureFlow  (optional)
     * @param digits * &#x60;6&#x60; - 6 digits, widely compatible * &#x60;8&#x60; - 8 digits, not compatible with apps like Google Authenticator (optional)
     * @param friendlyName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return PaginatedAuthenticatorTOTPStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorTotpList(configureFlow: java.util.UUID? = null, digits: Digits_stagesAuthenticatorTotpList? = null, friendlyName: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null) : PaginatedAuthenticatorTOTPStageList {
        val localVarResponse = stagesAuthenticatorTotpListWithHttpInfo(configureFlow = configureFlow, digits = digits, friendlyName = friendlyName, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAuthenticatorTOTPStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param configureFlow  (optional)
     * @param digits * &#x60;6&#x60; - 6 digits, widely compatible * &#x60;8&#x60; - 8 digits, not compatible with apps like Google Authenticator (optional)
     * @param friendlyName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return ApiResponse<PaginatedAuthenticatorTOTPStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorTotpListWithHttpInfo(configureFlow: java.util.UUID?, digits: Digits_stagesAuthenticatorTotpList?, friendlyName: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : ApiResponse<PaginatedAuthenticatorTOTPStageList?> {
        val localVariableConfig = stagesAuthenticatorTotpListRequestConfig(configureFlow = configureFlow, digits = digits, friendlyName = friendlyName, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return request<Unit, PaginatedAuthenticatorTOTPStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorTotpList
     *
     * @param configureFlow  (optional)
     * @param digits * &#x60;6&#x60; - 6 digits, widely compatible * &#x60;8&#x60; - 8 digits, not compatible with apps like Google Authenticator (optional)
     * @param friendlyName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorTotpListRequestConfig(configureFlow: java.util.UUID?, digits: Digits_stagesAuthenticatorTotpList?, friendlyName: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (configureFlow != null) {
                    put("configure_flow", listOf(configureFlow.toString()))
                }
                if (digits != null) {
                    put("digits", listOf(digits.toString()))
                }
                if (friendlyName != null) {
                    put("friendly_name", listOf(friendlyName.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/totp/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @param patchedAuthenticatorTOTPStageRequest  (optional)
     * @return AuthenticatorTOTPStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorTotpPartialUpdate(stageUuid: java.util.UUID, patchedAuthenticatorTOTPStageRequest: PatchedAuthenticatorTOTPStageRequest? = null) : AuthenticatorTOTPStage {
        val localVarResponse = stagesAuthenticatorTotpPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedAuthenticatorTOTPStageRequest = patchedAuthenticatorTOTPStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorTOTPStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @param patchedAuthenticatorTOTPStageRequest  (optional)
     * @return ApiResponse<AuthenticatorTOTPStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorTotpPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedAuthenticatorTOTPStageRequest: PatchedAuthenticatorTOTPStageRequest?) : ApiResponse<AuthenticatorTOTPStage?> {
        val localVariableConfig = stagesAuthenticatorTotpPartialUpdateRequestConfig(stageUuid = stageUuid, patchedAuthenticatorTOTPStageRequest = patchedAuthenticatorTOTPStageRequest)

        return request<PatchedAuthenticatorTOTPStageRequest, AuthenticatorTOTPStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorTotpPartialUpdate
     *
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @param patchedAuthenticatorTOTPStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorTotpPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedAuthenticatorTOTPStageRequest: PatchedAuthenticatorTOTPStageRequest?) : RequestConfig<PatchedAuthenticatorTOTPStageRequest> {
        val localVariableBody = patchedAuthenticatorTOTPStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/authenticator/totp/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @return AuthenticatorTOTPStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorTotpRetrieve(stageUuid: java.util.UUID) : AuthenticatorTOTPStage {
        val localVarResponse = stagesAuthenticatorTotpRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorTOTPStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @return ApiResponse<AuthenticatorTOTPStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorTotpRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<AuthenticatorTOTPStage?> {
        val localVariableConfig = stagesAuthenticatorTotpRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, AuthenticatorTOTPStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorTotpRetrieve
     *
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorTotpRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/totp/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @param authenticatorTOTPStageRequest 
     * @return AuthenticatorTOTPStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorTotpUpdate(stageUuid: java.util.UUID, authenticatorTOTPStageRequest: AuthenticatorTOTPStageRequest) : AuthenticatorTOTPStage {
        val localVarResponse = stagesAuthenticatorTotpUpdateWithHttpInfo(stageUuid = stageUuid, authenticatorTOTPStageRequest = authenticatorTOTPStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorTOTPStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorTOTPStage Viewset
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @param authenticatorTOTPStageRequest 
     * @return ApiResponse<AuthenticatorTOTPStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorTotpUpdateWithHttpInfo(stageUuid: java.util.UUID, authenticatorTOTPStageRequest: AuthenticatorTOTPStageRequest) : ApiResponse<AuthenticatorTOTPStage?> {
        val localVariableConfig = stagesAuthenticatorTotpUpdateRequestConfig(stageUuid = stageUuid, authenticatorTOTPStageRequest = authenticatorTOTPStageRequest)

        return request<AuthenticatorTOTPStageRequest, AuthenticatorTOTPStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorTotpUpdate
     *
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @param authenticatorTOTPStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorTotpUpdateRequestConfig(stageUuid: java.util.UUID, authenticatorTOTPStageRequest: AuthenticatorTOTPStageRequest) : RequestConfig<AuthenticatorTOTPStageRequest> {
        val localVariableBody = authenticatorTOTPStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/authenticator/totp/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorTotpUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesAuthenticatorTotpUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorTotpUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesAuthenticatorTotpUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorTotpUsedByList
     *
     * @param stageUuid A UUID string identifying this TOTP Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorTotpUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/totp/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param authenticatorValidateStageRequest 
     * @return AuthenticatorValidateStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorValidateCreate(authenticatorValidateStageRequest: AuthenticatorValidateStageRequest) : AuthenticatorValidateStage {
        val localVarResponse = stagesAuthenticatorValidateCreateWithHttpInfo(authenticatorValidateStageRequest = authenticatorValidateStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorValidateStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param authenticatorValidateStageRequest 
     * @return ApiResponse<AuthenticatorValidateStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorValidateCreateWithHttpInfo(authenticatorValidateStageRequest: AuthenticatorValidateStageRequest) : ApiResponse<AuthenticatorValidateStage?> {
        val localVariableConfig = stagesAuthenticatorValidateCreateRequestConfig(authenticatorValidateStageRequest = authenticatorValidateStageRequest)

        return request<AuthenticatorValidateStageRequest, AuthenticatorValidateStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorValidateCreate
     *
     * @param authenticatorValidateStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorValidateCreateRequestConfig(authenticatorValidateStageRequest: AuthenticatorValidateStageRequest) : RequestConfig<AuthenticatorValidateStageRequest> {
        val localVariableBody = authenticatorValidateStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/authenticator/validate/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorValidateDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesAuthenticatorValidateDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorValidateDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesAuthenticatorValidateDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorValidateDestroy
     *
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorValidateDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/authenticator/validate/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter notConfiguredAction
     */
     enum class NotConfiguredAction_stagesAuthenticatorValidateList(val value: kotlin.String) {
         @Json(name = "configure") configure("configure"),
         @Json(name = "deny") deny("deny"),
         @Json(name = "skip") skip("skip"),
     }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param configurationStages  (optional)
     * @param name  (optional)
     * @param notConfiguredAction * &#x60;skip&#x60; - Skip * &#x60;deny&#x60; - Deny * &#x60;configure&#x60; - Configure (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedAuthenticatorValidateStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorValidateList(configurationStages: kotlin.collections.List<java.util.UUID>? = null, name: kotlin.String? = null, notConfiguredAction: NotConfiguredAction_stagesAuthenticatorValidateList? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedAuthenticatorValidateStageList {
        val localVarResponse = stagesAuthenticatorValidateListWithHttpInfo(configurationStages = configurationStages, name = name, notConfiguredAction = notConfiguredAction, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAuthenticatorValidateStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param configurationStages  (optional)
     * @param name  (optional)
     * @param notConfiguredAction * &#x60;skip&#x60; - Skip * &#x60;deny&#x60; - Deny * &#x60;configure&#x60; - Configure (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedAuthenticatorValidateStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorValidateListWithHttpInfo(configurationStages: kotlin.collections.List<java.util.UUID>?, name: kotlin.String?, notConfiguredAction: NotConfiguredAction_stagesAuthenticatorValidateList?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedAuthenticatorValidateStageList?> {
        val localVariableConfig = stagesAuthenticatorValidateListRequestConfig(configurationStages = configurationStages, name = name, notConfiguredAction = notConfiguredAction, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedAuthenticatorValidateStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorValidateList
     *
     * @param configurationStages  (optional)
     * @param name  (optional)
     * @param notConfiguredAction * &#x60;skip&#x60; - Skip * &#x60;deny&#x60; - Deny * &#x60;configure&#x60; - Configure (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorValidateListRequestConfig(configurationStages: kotlin.collections.List<java.util.UUID>?, name: kotlin.String?, notConfiguredAction: NotConfiguredAction_stagesAuthenticatorValidateList?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (configurationStages != null) {
                    put("configuration_stages", toMultiValue(configurationStages.toList(), "multi"))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (notConfiguredAction != null) {
                    put("not_configured_action", listOf(notConfiguredAction.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/validate/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @param patchedAuthenticatorValidateStageRequest  (optional)
     * @return AuthenticatorValidateStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorValidatePartialUpdate(stageUuid: java.util.UUID, patchedAuthenticatorValidateStageRequest: PatchedAuthenticatorValidateStageRequest? = null) : AuthenticatorValidateStage {
        val localVarResponse = stagesAuthenticatorValidatePartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedAuthenticatorValidateStageRequest = patchedAuthenticatorValidateStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorValidateStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @param patchedAuthenticatorValidateStageRequest  (optional)
     * @return ApiResponse<AuthenticatorValidateStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorValidatePartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedAuthenticatorValidateStageRequest: PatchedAuthenticatorValidateStageRequest?) : ApiResponse<AuthenticatorValidateStage?> {
        val localVariableConfig = stagesAuthenticatorValidatePartialUpdateRequestConfig(stageUuid = stageUuid, patchedAuthenticatorValidateStageRequest = patchedAuthenticatorValidateStageRequest)

        return request<PatchedAuthenticatorValidateStageRequest, AuthenticatorValidateStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorValidatePartialUpdate
     *
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @param patchedAuthenticatorValidateStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorValidatePartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedAuthenticatorValidateStageRequest: PatchedAuthenticatorValidateStageRequest?) : RequestConfig<PatchedAuthenticatorValidateStageRequest> {
        val localVariableBody = patchedAuthenticatorValidateStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/authenticator/validate/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @return AuthenticatorValidateStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorValidateRetrieve(stageUuid: java.util.UUID) : AuthenticatorValidateStage {
        val localVarResponse = stagesAuthenticatorValidateRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorValidateStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @return ApiResponse<AuthenticatorValidateStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorValidateRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<AuthenticatorValidateStage?> {
        val localVariableConfig = stagesAuthenticatorValidateRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, AuthenticatorValidateStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorValidateRetrieve
     *
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorValidateRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/validate/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @param authenticatorValidateStageRequest 
     * @return AuthenticatorValidateStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorValidateUpdate(stageUuid: java.util.UUID, authenticatorValidateStageRequest: AuthenticatorValidateStageRequest) : AuthenticatorValidateStage {
        val localVarResponse = stagesAuthenticatorValidateUpdateWithHttpInfo(stageUuid = stageUuid, authenticatorValidateStageRequest = authenticatorValidateStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticatorValidateStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticatorValidateStage Viewset
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @param authenticatorValidateStageRequest 
     * @return ApiResponse<AuthenticatorValidateStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorValidateUpdateWithHttpInfo(stageUuid: java.util.UUID, authenticatorValidateStageRequest: AuthenticatorValidateStageRequest) : ApiResponse<AuthenticatorValidateStage?> {
        val localVariableConfig = stagesAuthenticatorValidateUpdateRequestConfig(stageUuid = stageUuid, authenticatorValidateStageRequest = authenticatorValidateStageRequest)

        return request<AuthenticatorValidateStageRequest, AuthenticatorValidateStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorValidateUpdate
     *
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @param authenticatorValidateStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorValidateUpdateRequestConfig(stageUuid: java.util.UUID, authenticatorValidateStageRequest: AuthenticatorValidateStageRequest) : RequestConfig<AuthenticatorValidateStageRequest> {
        val localVariableBody = authenticatorValidateStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/authenticator/validate/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorValidateUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesAuthenticatorValidateUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorValidateUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesAuthenticatorValidateUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorValidateUsedByList
     *
     * @param stageUuid A UUID string identifying this Authenticator Validation Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorValidateUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/validate/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param authenticateWebAuthnStageRequest 
     * @return AuthenticateWebAuthnStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorWebauthnCreate(authenticateWebAuthnStageRequest: AuthenticateWebAuthnStageRequest) : AuthenticateWebAuthnStage {
        val localVarResponse = stagesAuthenticatorWebauthnCreateWithHttpInfo(authenticateWebAuthnStageRequest = authenticateWebAuthnStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticateWebAuthnStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param authenticateWebAuthnStageRequest 
     * @return ApiResponse<AuthenticateWebAuthnStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorWebauthnCreateWithHttpInfo(authenticateWebAuthnStageRequest: AuthenticateWebAuthnStageRequest) : ApiResponse<AuthenticateWebAuthnStage?> {
        val localVariableConfig = stagesAuthenticatorWebauthnCreateRequestConfig(authenticateWebAuthnStageRequest = authenticateWebAuthnStageRequest)

        return request<AuthenticateWebAuthnStageRequest, AuthenticateWebAuthnStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorWebauthnCreate
     *
     * @param authenticateWebAuthnStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorWebauthnCreateRequestConfig(authenticateWebAuthnStageRequest: AuthenticateWebAuthnStageRequest) : RequestConfig<AuthenticateWebAuthnStageRequest> {
        val localVariableBody = authenticateWebAuthnStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/authenticator/webauthn/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorWebauthnDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesAuthenticatorWebauthnDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorWebauthnDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesAuthenticatorWebauthnDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorWebauthnDestroy
     *
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorWebauthnDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/authenticator/webauthn/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter authenticatorAttachment
     */
     enum class AuthenticatorAttachment_stagesAuthenticatorWebauthnList(val value: kotlin.String) {
         @Json(name = "cross-platform") crossMinusPlatform("cross-platform"),
         @Json(name = "platform") platform("platform"),
     }

    /**
     * enum for parameter residentKeyRequirement
     */
     enum class ResidentKeyRequirement_stagesAuthenticatorWebauthnList(val value: kotlin.String) {
         @Json(name = "discouraged") discouraged("discouraged"),
         @Json(name = "preferred") preferred("preferred"),
         @Json(name = "required") required("required"),
     }

    /**
     * enum for parameter userVerification
     */
     enum class UserVerification_stagesAuthenticatorWebauthnList(val value: kotlin.String) {
         @Json(name = "discouraged") discouraged("discouraged"),
         @Json(name = "preferred") preferred("preferred"),
         @Json(name = "required") required("required"),
     }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param authenticatorAttachment * &#x60;platform&#x60; - Platform * &#x60;cross-platform&#x60; - Cross Platform (optional)
     * @param configureFlow  (optional)
     * @param friendlyName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param residentKeyRequirement * &#x60;discouraged&#x60; - Discouraged * &#x60;preferred&#x60; - Preferred * &#x60;required&#x60; - Required (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param userVerification * &#x60;required&#x60; - Required * &#x60;preferred&#x60; - Preferred * &#x60;discouraged&#x60; - Discouraged (optional)
     * @return PaginatedAuthenticateWebAuthnStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorWebauthnList(authenticatorAttachment: AuthenticatorAttachment_stagesAuthenticatorWebauthnList? = null, configureFlow: java.util.UUID? = null, friendlyName: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, residentKeyRequirement: ResidentKeyRequirement_stagesAuthenticatorWebauthnList? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null, userVerification: UserVerification_stagesAuthenticatorWebauthnList? = null) : PaginatedAuthenticateWebAuthnStageList {
        val localVarResponse = stagesAuthenticatorWebauthnListWithHttpInfo(authenticatorAttachment = authenticatorAttachment, configureFlow = configureFlow, friendlyName = friendlyName, name = name, ordering = ordering, page = page, pageSize = pageSize, residentKeyRequirement = residentKeyRequirement, search = search, stageUuid = stageUuid, userVerification = userVerification)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAuthenticateWebAuthnStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param authenticatorAttachment * &#x60;platform&#x60; - Platform * &#x60;cross-platform&#x60; - Cross Platform (optional)
     * @param configureFlow  (optional)
     * @param friendlyName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param residentKeyRequirement * &#x60;discouraged&#x60; - Discouraged * &#x60;preferred&#x60; - Preferred * &#x60;required&#x60; - Required (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param userVerification * &#x60;required&#x60; - Required * &#x60;preferred&#x60; - Preferred * &#x60;discouraged&#x60; - Discouraged (optional)
     * @return ApiResponse<PaginatedAuthenticateWebAuthnStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorWebauthnListWithHttpInfo(authenticatorAttachment: AuthenticatorAttachment_stagesAuthenticatorWebauthnList?, configureFlow: java.util.UUID?, friendlyName: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, residentKeyRequirement: ResidentKeyRequirement_stagesAuthenticatorWebauthnList?, search: kotlin.String?, stageUuid: java.util.UUID?, userVerification: UserVerification_stagesAuthenticatorWebauthnList?) : ApiResponse<PaginatedAuthenticateWebAuthnStageList?> {
        val localVariableConfig = stagesAuthenticatorWebauthnListRequestConfig(authenticatorAttachment = authenticatorAttachment, configureFlow = configureFlow, friendlyName = friendlyName, name = name, ordering = ordering, page = page, pageSize = pageSize, residentKeyRequirement = residentKeyRequirement, search = search, stageUuid = stageUuid, userVerification = userVerification)

        return request<Unit, PaginatedAuthenticateWebAuthnStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorWebauthnList
     *
     * @param authenticatorAttachment * &#x60;platform&#x60; - Platform * &#x60;cross-platform&#x60; - Cross Platform (optional)
     * @param configureFlow  (optional)
     * @param friendlyName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param residentKeyRequirement * &#x60;discouraged&#x60; - Discouraged * &#x60;preferred&#x60; - Preferred * &#x60;required&#x60; - Required (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param userVerification * &#x60;required&#x60; - Required * &#x60;preferred&#x60; - Preferred * &#x60;discouraged&#x60; - Discouraged (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorWebauthnListRequestConfig(authenticatorAttachment: AuthenticatorAttachment_stagesAuthenticatorWebauthnList?, configureFlow: java.util.UUID?, friendlyName: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, residentKeyRequirement: ResidentKeyRequirement_stagesAuthenticatorWebauthnList?, search: kotlin.String?, stageUuid: java.util.UUID?, userVerification: UserVerification_stagesAuthenticatorWebauthnList?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (authenticatorAttachment != null) {
                    put("authenticator_attachment", listOf(authenticatorAttachment.toString()))
                }
                if (configureFlow != null) {
                    put("configure_flow", listOf(configureFlow.toString()))
                }
                if (friendlyName != null) {
                    put("friendly_name", listOf(friendlyName.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (residentKeyRequirement != null) {
                    put("resident_key_requirement", listOf(residentKeyRequirement.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
                if (userVerification != null) {
                    put("user_verification", listOf(userVerification.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/webauthn/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @param patchedAuthenticateWebAuthnStageRequest  (optional)
     * @return AuthenticateWebAuthnStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorWebauthnPartialUpdate(stageUuid: java.util.UUID, patchedAuthenticateWebAuthnStageRequest: PatchedAuthenticateWebAuthnStageRequest? = null) : AuthenticateWebAuthnStage {
        val localVarResponse = stagesAuthenticatorWebauthnPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedAuthenticateWebAuthnStageRequest = patchedAuthenticateWebAuthnStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticateWebAuthnStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @param patchedAuthenticateWebAuthnStageRequest  (optional)
     * @return ApiResponse<AuthenticateWebAuthnStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorWebauthnPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedAuthenticateWebAuthnStageRequest: PatchedAuthenticateWebAuthnStageRequest?) : ApiResponse<AuthenticateWebAuthnStage?> {
        val localVariableConfig = stagesAuthenticatorWebauthnPartialUpdateRequestConfig(stageUuid = stageUuid, patchedAuthenticateWebAuthnStageRequest = patchedAuthenticateWebAuthnStageRequest)

        return request<PatchedAuthenticateWebAuthnStageRequest, AuthenticateWebAuthnStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorWebauthnPartialUpdate
     *
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @param patchedAuthenticateWebAuthnStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesAuthenticatorWebauthnPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedAuthenticateWebAuthnStageRequest: PatchedAuthenticateWebAuthnStageRequest?) : RequestConfig<PatchedAuthenticateWebAuthnStageRequest> {
        val localVariableBody = patchedAuthenticateWebAuthnStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/authenticator/webauthn/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @return AuthenticateWebAuthnStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorWebauthnRetrieve(stageUuid: java.util.UUID) : AuthenticateWebAuthnStage {
        val localVarResponse = stagesAuthenticatorWebauthnRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticateWebAuthnStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @return ApiResponse<AuthenticateWebAuthnStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorWebauthnRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<AuthenticateWebAuthnStage?> {
        val localVariableConfig = stagesAuthenticatorWebauthnRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, AuthenticateWebAuthnStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorWebauthnRetrieve
     *
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorWebauthnRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/webauthn/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @param authenticateWebAuthnStageRequest 
     * @return AuthenticateWebAuthnStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorWebauthnUpdate(stageUuid: java.util.UUID, authenticateWebAuthnStageRequest: AuthenticateWebAuthnStageRequest) : AuthenticateWebAuthnStage {
        val localVarResponse = stagesAuthenticatorWebauthnUpdateWithHttpInfo(stageUuid = stageUuid, authenticateWebAuthnStageRequest = authenticateWebAuthnStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AuthenticateWebAuthnStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * AuthenticateWebAuthnStage Viewset
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @param authenticateWebAuthnStageRequest 
     * @return ApiResponse<AuthenticateWebAuthnStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorWebauthnUpdateWithHttpInfo(stageUuid: java.util.UUID, authenticateWebAuthnStageRequest: AuthenticateWebAuthnStageRequest) : ApiResponse<AuthenticateWebAuthnStage?> {
        val localVariableConfig = stagesAuthenticatorWebauthnUpdateRequestConfig(stageUuid = stageUuid, authenticateWebAuthnStageRequest = authenticateWebAuthnStageRequest)

        return request<AuthenticateWebAuthnStageRequest, AuthenticateWebAuthnStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorWebauthnUpdate
     *
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @param authenticateWebAuthnStageRequest 
     * @return RequestConfig
     */
    fun stagesAuthenticatorWebauthnUpdateRequestConfig(stageUuid: java.util.UUID, authenticateWebAuthnStageRequest: AuthenticateWebAuthnStageRequest) : RequestConfig<AuthenticateWebAuthnStageRequest> {
        val localVariableBody = authenticateWebAuthnStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/authenticator/webauthn/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesAuthenticatorWebauthnUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesAuthenticatorWebauthnUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesAuthenticatorWebauthnUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesAuthenticatorWebauthnUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesAuthenticatorWebauthnUsedByList
     *
     * @param stageUuid A UUID string identifying this WebAuthn Authenticator Setup Stage.
     * @return RequestConfig
     */
    fun stagesAuthenticatorWebauthnUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/authenticator/webauthn/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param captchaStageRequest 
     * @return CaptchaStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesCaptchaCreate(captchaStageRequest: CaptchaStageRequest) : CaptchaStage {
        val localVarResponse = stagesCaptchaCreateWithHttpInfo(captchaStageRequest = captchaStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CaptchaStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param captchaStageRequest 
     * @return ApiResponse<CaptchaStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesCaptchaCreateWithHttpInfo(captchaStageRequest: CaptchaStageRequest) : ApiResponse<CaptchaStage?> {
        val localVariableConfig = stagesCaptchaCreateRequestConfig(captchaStageRequest = captchaStageRequest)

        return request<CaptchaStageRequest, CaptchaStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesCaptchaCreate
     *
     * @param captchaStageRequest 
     * @return RequestConfig
     */
    fun stagesCaptchaCreateRequestConfig(captchaStageRequest: CaptchaStageRequest) : RequestConfig<CaptchaStageRequest> {
        val localVariableBody = captchaStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/captcha/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesCaptchaDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesCaptchaDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesCaptchaDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesCaptchaDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesCaptchaDestroy
     *
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @return RequestConfig
     */
    fun stagesCaptchaDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/captcha/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param publicKey  (optional)
     * @param search A search term. (optional)
     * @return PaginatedCaptchaStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesCaptchaList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, publicKey: kotlin.String? = null, search: kotlin.String? = null) : PaginatedCaptchaStageList {
        val localVarResponse = stagesCaptchaListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, publicKey = publicKey, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedCaptchaStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param publicKey  (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedCaptchaStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesCaptchaListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, publicKey: kotlin.String?, search: kotlin.String?) : ApiResponse<PaginatedCaptchaStageList?> {
        val localVariableConfig = stagesCaptchaListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, publicKey = publicKey, search = search)

        return request<Unit, PaginatedCaptchaStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesCaptchaList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param publicKey  (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun stagesCaptchaListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, publicKey: kotlin.String?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (publicKey != null) {
                    put("public_key", listOf(publicKey.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/captcha/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @param patchedCaptchaStageRequest  (optional)
     * @return CaptchaStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesCaptchaPartialUpdate(stageUuid: java.util.UUID, patchedCaptchaStageRequest: PatchedCaptchaStageRequest? = null) : CaptchaStage {
        val localVarResponse = stagesCaptchaPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedCaptchaStageRequest = patchedCaptchaStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CaptchaStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @param patchedCaptchaStageRequest  (optional)
     * @return ApiResponse<CaptchaStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesCaptchaPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedCaptchaStageRequest: PatchedCaptchaStageRequest?) : ApiResponse<CaptchaStage?> {
        val localVariableConfig = stagesCaptchaPartialUpdateRequestConfig(stageUuid = stageUuid, patchedCaptchaStageRequest = patchedCaptchaStageRequest)

        return request<PatchedCaptchaStageRequest, CaptchaStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesCaptchaPartialUpdate
     *
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @param patchedCaptchaStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesCaptchaPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedCaptchaStageRequest: PatchedCaptchaStageRequest?) : RequestConfig<PatchedCaptchaStageRequest> {
        val localVariableBody = patchedCaptchaStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/captcha/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @return CaptchaStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesCaptchaRetrieve(stageUuid: java.util.UUID) : CaptchaStage {
        val localVarResponse = stagesCaptchaRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CaptchaStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @return ApiResponse<CaptchaStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesCaptchaRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<CaptchaStage?> {
        val localVariableConfig = stagesCaptchaRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, CaptchaStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesCaptchaRetrieve
     *
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @return RequestConfig
     */
    fun stagesCaptchaRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/captcha/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @param captchaStageRequest 
     * @return CaptchaStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesCaptchaUpdate(stageUuid: java.util.UUID, captchaStageRequest: CaptchaStageRequest) : CaptchaStage {
        val localVarResponse = stagesCaptchaUpdateWithHttpInfo(stageUuid = stageUuid, captchaStageRequest = captchaStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CaptchaStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * CaptchaStage Viewset
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @param captchaStageRequest 
     * @return ApiResponse<CaptchaStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesCaptchaUpdateWithHttpInfo(stageUuid: java.util.UUID, captchaStageRequest: CaptchaStageRequest) : ApiResponse<CaptchaStage?> {
        val localVariableConfig = stagesCaptchaUpdateRequestConfig(stageUuid = stageUuid, captchaStageRequest = captchaStageRequest)

        return request<CaptchaStageRequest, CaptchaStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesCaptchaUpdate
     *
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @param captchaStageRequest 
     * @return RequestConfig
     */
    fun stagesCaptchaUpdateRequestConfig(stageUuid: java.util.UUID, captchaStageRequest: CaptchaStageRequest) : RequestConfig<CaptchaStageRequest> {
        val localVariableBody = captchaStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/captcha/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesCaptchaUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesCaptchaUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesCaptchaUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesCaptchaUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesCaptchaUsedByList
     *
     * @param stageUuid A UUID string identifying this Captcha Stage.
     * @return RequestConfig
     */
    fun stagesCaptchaUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/captcha/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * ConsentStage Viewset
     * @param consentStageRequest 
     * @return ConsentStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesConsentCreate(consentStageRequest: ConsentStageRequest) : ConsentStage {
        val localVarResponse = stagesConsentCreateWithHttpInfo(consentStageRequest = consentStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConsentStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ConsentStage Viewset
     * @param consentStageRequest 
     * @return ApiResponse<ConsentStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesConsentCreateWithHttpInfo(consentStageRequest: ConsentStageRequest) : ApiResponse<ConsentStage?> {
        val localVariableConfig = stagesConsentCreateRequestConfig(consentStageRequest = consentStageRequest)

        return request<ConsentStageRequest, ConsentStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesConsentCreate
     *
     * @param consentStageRequest 
     * @return RequestConfig
     */
    fun stagesConsentCreateRequestConfig(consentStageRequest: ConsentStageRequest) : RequestConfig<ConsentStageRequest> {
        val localVariableBody = consentStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/consent/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * ConsentStage Viewset
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesConsentDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesConsentDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ConsentStage Viewset
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesConsentDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesConsentDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesConsentDestroy
     *
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @return RequestConfig
     */
    fun stagesConsentDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/consent/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter mode
     */
     enum class Mode_stagesConsentList(val value: kotlin.String) {
         @Json(name = "always_require") alwaysRequire("always_require"),
         @Json(name = "expiring") expiring("expiring"),
         @Json(name = "permanent") permanent("permanent"),
     }

    /**
     * 
     * ConsentStage Viewset
     * @param consentExpireIn  (optional)
     * @param mode * &#x60;always_require&#x60; - Always Require * &#x60;permanent&#x60; - Permanent * &#x60;expiring&#x60; - Expiring (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return PaginatedConsentStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesConsentList(consentExpireIn: kotlin.String? = null, mode: Mode_stagesConsentList? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null) : PaginatedConsentStageList {
        val localVarResponse = stagesConsentListWithHttpInfo(consentExpireIn = consentExpireIn, mode = mode, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedConsentStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ConsentStage Viewset
     * @param consentExpireIn  (optional)
     * @param mode * &#x60;always_require&#x60; - Always Require * &#x60;permanent&#x60; - Permanent * &#x60;expiring&#x60; - Expiring (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return ApiResponse<PaginatedConsentStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesConsentListWithHttpInfo(consentExpireIn: kotlin.String?, mode: Mode_stagesConsentList?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : ApiResponse<PaginatedConsentStageList?> {
        val localVariableConfig = stagesConsentListRequestConfig(consentExpireIn = consentExpireIn, mode = mode, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return request<Unit, PaginatedConsentStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesConsentList
     *
     * @param consentExpireIn  (optional)
     * @param mode * &#x60;always_require&#x60; - Always Require * &#x60;permanent&#x60; - Permanent * &#x60;expiring&#x60; - Expiring (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return RequestConfig
     */
    fun stagesConsentListRequestConfig(consentExpireIn: kotlin.String?, mode: Mode_stagesConsentList?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (consentExpireIn != null) {
                    put("consent_expire_in", listOf(consentExpireIn.toString()))
                }
                if (mode != null) {
                    put("mode", listOf(mode.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/consent/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * ConsentStage Viewset
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @param patchedConsentStageRequest  (optional)
     * @return ConsentStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesConsentPartialUpdate(stageUuid: java.util.UUID, patchedConsentStageRequest: PatchedConsentStageRequest? = null) : ConsentStage {
        val localVarResponse = stagesConsentPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedConsentStageRequest = patchedConsentStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConsentStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ConsentStage Viewset
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @param patchedConsentStageRequest  (optional)
     * @return ApiResponse<ConsentStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesConsentPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedConsentStageRequest: PatchedConsentStageRequest?) : ApiResponse<ConsentStage?> {
        val localVariableConfig = stagesConsentPartialUpdateRequestConfig(stageUuid = stageUuid, patchedConsentStageRequest = patchedConsentStageRequest)

        return request<PatchedConsentStageRequest, ConsentStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesConsentPartialUpdate
     *
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @param patchedConsentStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesConsentPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedConsentStageRequest: PatchedConsentStageRequest?) : RequestConfig<PatchedConsentStageRequest> {
        val localVariableBody = patchedConsentStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/consent/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * ConsentStage Viewset
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @return ConsentStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesConsentRetrieve(stageUuid: java.util.UUID) : ConsentStage {
        val localVarResponse = stagesConsentRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConsentStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ConsentStage Viewset
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @return ApiResponse<ConsentStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesConsentRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<ConsentStage?> {
        val localVariableConfig = stagesConsentRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, ConsentStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesConsentRetrieve
     *
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @return RequestConfig
     */
    fun stagesConsentRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/consent/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * ConsentStage Viewset
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @param consentStageRequest 
     * @return ConsentStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesConsentUpdate(stageUuid: java.util.UUID, consentStageRequest: ConsentStageRequest) : ConsentStage {
        val localVarResponse = stagesConsentUpdateWithHttpInfo(stageUuid = stageUuid, consentStageRequest = consentStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConsentStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ConsentStage Viewset
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @param consentStageRequest 
     * @return ApiResponse<ConsentStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesConsentUpdateWithHttpInfo(stageUuid: java.util.UUID, consentStageRequest: ConsentStageRequest) : ApiResponse<ConsentStage?> {
        val localVariableConfig = stagesConsentUpdateRequestConfig(stageUuid = stageUuid, consentStageRequest = consentStageRequest)

        return request<ConsentStageRequest, ConsentStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesConsentUpdate
     *
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @param consentStageRequest 
     * @return RequestConfig
     */
    fun stagesConsentUpdateRequestConfig(stageUuid: java.util.UUID, consentStageRequest: ConsentStageRequest) : RequestConfig<ConsentStageRequest> {
        val localVariableBody = consentStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/consent/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesConsentUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesConsentUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesConsentUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesConsentUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesConsentUsedByList
     *
     * @param stageUuid A UUID string identifying this Consent Stage.
     * @return RequestConfig
     */
    fun stagesConsentUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/consent/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DenyStage Viewset
     * @param denyStageRequest 
     * @return DenyStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDenyCreate(denyStageRequest: DenyStageRequest) : DenyStage {
        val localVarResponse = stagesDenyCreateWithHttpInfo(denyStageRequest = denyStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DenyStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DenyStage Viewset
     * @param denyStageRequest 
     * @return ApiResponse<DenyStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDenyCreateWithHttpInfo(denyStageRequest: DenyStageRequest) : ApiResponse<DenyStage?> {
        val localVariableConfig = stagesDenyCreateRequestConfig(denyStageRequest = denyStageRequest)

        return request<DenyStageRequest, DenyStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDenyCreate
     *
     * @param denyStageRequest 
     * @return RequestConfig
     */
    fun stagesDenyCreateRequestConfig(denyStageRequest: DenyStageRequest) : RequestConfig<DenyStageRequest> {
        val localVariableBody = denyStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/deny/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DenyStage Viewset
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDenyDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesDenyDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DenyStage Viewset
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDenyDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesDenyDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDenyDestroy
     *
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @return RequestConfig
     */
    fun stagesDenyDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/deny/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DenyStage Viewset
     * @param denyMessage  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return PaginatedDenyStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDenyList(denyMessage: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null) : PaginatedDenyStageList {
        val localVarResponse = stagesDenyListWithHttpInfo(denyMessage = denyMessage, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDenyStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DenyStage Viewset
     * @param denyMessage  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return ApiResponse<PaginatedDenyStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDenyListWithHttpInfo(denyMessage: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : ApiResponse<PaginatedDenyStageList?> {
        val localVariableConfig = stagesDenyListRequestConfig(denyMessage = denyMessage, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return request<Unit, PaginatedDenyStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDenyList
     *
     * @param denyMessage  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return RequestConfig
     */
    fun stagesDenyListRequestConfig(denyMessage: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (denyMessage != null) {
                    put("deny_message", listOf(denyMessage.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/deny/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DenyStage Viewset
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @param patchedDenyStageRequest  (optional)
     * @return DenyStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDenyPartialUpdate(stageUuid: java.util.UUID, patchedDenyStageRequest: PatchedDenyStageRequest? = null) : DenyStage {
        val localVarResponse = stagesDenyPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedDenyStageRequest = patchedDenyStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DenyStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DenyStage Viewset
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @param patchedDenyStageRequest  (optional)
     * @return ApiResponse<DenyStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDenyPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedDenyStageRequest: PatchedDenyStageRequest?) : ApiResponse<DenyStage?> {
        val localVariableConfig = stagesDenyPartialUpdateRequestConfig(stageUuid = stageUuid, patchedDenyStageRequest = patchedDenyStageRequest)

        return request<PatchedDenyStageRequest, DenyStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDenyPartialUpdate
     *
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @param patchedDenyStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesDenyPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedDenyStageRequest: PatchedDenyStageRequest?) : RequestConfig<PatchedDenyStageRequest> {
        val localVariableBody = patchedDenyStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/deny/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DenyStage Viewset
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @return DenyStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDenyRetrieve(stageUuid: java.util.UUID) : DenyStage {
        val localVarResponse = stagesDenyRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DenyStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DenyStage Viewset
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @return ApiResponse<DenyStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDenyRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<DenyStage?> {
        val localVariableConfig = stagesDenyRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, DenyStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDenyRetrieve
     *
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @return RequestConfig
     */
    fun stagesDenyRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/deny/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DenyStage Viewset
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @param denyStageRequest 
     * @return DenyStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDenyUpdate(stageUuid: java.util.UUID, denyStageRequest: DenyStageRequest) : DenyStage {
        val localVarResponse = stagesDenyUpdateWithHttpInfo(stageUuid = stageUuid, denyStageRequest = denyStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DenyStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DenyStage Viewset
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @param denyStageRequest 
     * @return ApiResponse<DenyStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDenyUpdateWithHttpInfo(stageUuid: java.util.UUID, denyStageRequest: DenyStageRequest) : ApiResponse<DenyStage?> {
        val localVariableConfig = stagesDenyUpdateRequestConfig(stageUuid = stageUuid, denyStageRequest = denyStageRequest)

        return request<DenyStageRequest, DenyStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDenyUpdate
     *
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @param denyStageRequest 
     * @return RequestConfig
     */
    fun stagesDenyUpdateRequestConfig(stageUuid: java.util.UUID, denyStageRequest: DenyStageRequest) : RequestConfig<DenyStageRequest> {
        val localVariableBody = denyStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/deny/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDenyUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesDenyUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDenyUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesDenyUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDenyUsedByList
     *
     * @param stageUuid A UUID string identifying this Deny Stage.
     * @return RequestConfig
     */
    fun stagesDenyUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/deny/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DummyStage Viewset
     * @param dummyStageRequest 
     * @return DummyStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDummyCreate(dummyStageRequest: DummyStageRequest) : DummyStage {
        val localVarResponse = stagesDummyCreateWithHttpInfo(dummyStageRequest = dummyStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DummyStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DummyStage Viewset
     * @param dummyStageRequest 
     * @return ApiResponse<DummyStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDummyCreateWithHttpInfo(dummyStageRequest: DummyStageRequest) : ApiResponse<DummyStage?> {
        val localVariableConfig = stagesDummyCreateRequestConfig(dummyStageRequest = dummyStageRequest)

        return request<DummyStageRequest, DummyStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDummyCreate
     *
     * @param dummyStageRequest 
     * @return RequestConfig
     */
    fun stagesDummyCreateRequestConfig(dummyStageRequest: DummyStageRequest) : RequestConfig<DummyStageRequest> {
        val localVariableBody = dummyStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/dummy/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DummyStage Viewset
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDummyDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesDummyDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DummyStage Viewset
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDummyDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesDummyDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDummyDestroy
     *
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @return RequestConfig
     */
    fun stagesDummyDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/dummy/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DummyStage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param throwError  (optional)
     * @return PaginatedDummyStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDummyList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null, throwError: kotlin.Boolean? = null) : PaginatedDummyStageList {
        val localVarResponse = stagesDummyListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid, throwError = throwError)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDummyStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DummyStage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param throwError  (optional)
     * @return ApiResponse<PaginatedDummyStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDummyListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?, throwError: kotlin.Boolean?) : ApiResponse<PaginatedDummyStageList?> {
        val localVariableConfig = stagesDummyListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid, throwError = throwError)

        return request<Unit, PaginatedDummyStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDummyList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param throwError  (optional)
     * @return RequestConfig
     */
    fun stagesDummyListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?, throwError: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
                if (throwError != null) {
                    put("throw_error", listOf(throwError.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/dummy/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DummyStage Viewset
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @param patchedDummyStageRequest  (optional)
     * @return DummyStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDummyPartialUpdate(stageUuid: java.util.UUID, patchedDummyStageRequest: PatchedDummyStageRequest? = null) : DummyStage {
        val localVarResponse = stagesDummyPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedDummyStageRequest = patchedDummyStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DummyStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DummyStage Viewset
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @param patchedDummyStageRequest  (optional)
     * @return ApiResponse<DummyStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDummyPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedDummyStageRequest: PatchedDummyStageRequest?) : ApiResponse<DummyStage?> {
        val localVariableConfig = stagesDummyPartialUpdateRequestConfig(stageUuid = stageUuid, patchedDummyStageRequest = patchedDummyStageRequest)

        return request<PatchedDummyStageRequest, DummyStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDummyPartialUpdate
     *
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @param patchedDummyStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesDummyPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedDummyStageRequest: PatchedDummyStageRequest?) : RequestConfig<PatchedDummyStageRequest> {
        val localVariableBody = patchedDummyStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/dummy/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DummyStage Viewset
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @return DummyStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDummyRetrieve(stageUuid: java.util.UUID) : DummyStage {
        val localVarResponse = stagesDummyRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DummyStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DummyStage Viewset
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @return ApiResponse<DummyStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDummyRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<DummyStage?> {
        val localVariableConfig = stagesDummyRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, DummyStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDummyRetrieve
     *
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @return RequestConfig
     */
    fun stagesDummyRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/dummy/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * DummyStage Viewset
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @param dummyStageRequest 
     * @return DummyStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDummyUpdate(stageUuid: java.util.UUID, dummyStageRequest: DummyStageRequest) : DummyStage {
        val localVarResponse = stagesDummyUpdateWithHttpInfo(stageUuid = stageUuid, dummyStageRequest = dummyStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DummyStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * DummyStage Viewset
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @param dummyStageRequest 
     * @return ApiResponse<DummyStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDummyUpdateWithHttpInfo(stageUuid: java.util.UUID, dummyStageRequest: DummyStageRequest) : ApiResponse<DummyStage?> {
        val localVariableConfig = stagesDummyUpdateRequestConfig(stageUuid = stageUuid, dummyStageRequest = dummyStageRequest)

        return request<DummyStageRequest, DummyStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDummyUpdate
     *
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @param dummyStageRequest 
     * @return RequestConfig
     */
    fun stagesDummyUpdateRequestConfig(stageUuid: java.util.UUID, dummyStageRequest: DummyStageRequest) : RequestConfig<DummyStageRequest> {
        val localVariableBody = dummyStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/dummy/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesDummyUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesDummyUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesDummyUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesDummyUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesDummyUsedByList
     *
     * @param stageUuid A UUID string identifying this Dummy Stage.
     * @return RequestConfig
     */
    fun stagesDummyUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/dummy/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * EmailStage Viewset
     * @param emailStageRequest 
     * @return EmailStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesEmailCreate(emailStageRequest: EmailStageRequest) : EmailStage {
        val localVarResponse = stagesEmailCreateWithHttpInfo(emailStageRequest = emailStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmailStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * EmailStage Viewset
     * @param emailStageRequest 
     * @return ApiResponse<EmailStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesEmailCreateWithHttpInfo(emailStageRequest: EmailStageRequest) : ApiResponse<EmailStage?> {
        val localVariableConfig = stagesEmailCreateRequestConfig(emailStageRequest = emailStageRequest)

        return request<EmailStageRequest, EmailStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesEmailCreate
     *
     * @param emailStageRequest 
     * @return RequestConfig
     */
    fun stagesEmailCreateRequestConfig(emailStageRequest: EmailStageRequest) : RequestConfig<EmailStageRequest> {
        val localVariableBody = emailStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/email/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * EmailStage Viewset
     * @param stageUuid A UUID string identifying this Email Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesEmailDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesEmailDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * EmailStage Viewset
     * @param stageUuid A UUID string identifying this Email Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesEmailDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesEmailDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesEmailDestroy
     *
     * @param stageUuid A UUID string identifying this Email Stage.
     * @return RequestConfig
     */
    fun stagesEmailDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/email/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * EmailStage Viewset
     * @param activateUserOnSuccess  (optional)
     * @param fromAddress  (optional)
     * @param host  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param port  (optional)
     * @param search A search term. (optional)
     * @param subject  (optional)
     * @param template  (optional)
     * @param timeout  (optional)
     * @param tokenExpiry  (optional)
     * @param useGlobalSettings  (optional)
     * @param useSsl  (optional)
     * @param useTls  (optional)
     * @param username  (optional)
     * @return PaginatedEmailStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesEmailList(activateUserOnSuccess: kotlin.Boolean? = null, fromAddress: kotlin.String? = null, host: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, port: kotlin.Int? = null, search: kotlin.String? = null, subject: kotlin.String? = null, template: kotlin.String? = null, timeout: kotlin.Int? = null, tokenExpiry: kotlin.Int? = null, useGlobalSettings: kotlin.Boolean? = null, useSsl: kotlin.Boolean? = null, useTls: kotlin.Boolean? = null, username: kotlin.String? = null) : PaginatedEmailStageList {
        val localVarResponse = stagesEmailListWithHttpInfo(activateUserOnSuccess = activateUserOnSuccess, fromAddress = fromAddress, host = host, name = name, ordering = ordering, page = page, pageSize = pageSize, port = port, search = search, subject = subject, template = template, timeout = timeout, tokenExpiry = tokenExpiry, useGlobalSettings = useGlobalSettings, useSsl = useSsl, useTls = useTls, username = username)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedEmailStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * EmailStage Viewset
     * @param activateUserOnSuccess  (optional)
     * @param fromAddress  (optional)
     * @param host  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param port  (optional)
     * @param search A search term. (optional)
     * @param subject  (optional)
     * @param template  (optional)
     * @param timeout  (optional)
     * @param tokenExpiry  (optional)
     * @param useGlobalSettings  (optional)
     * @param useSsl  (optional)
     * @param useTls  (optional)
     * @param username  (optional)
     * @return ApiResponse<PaginatedEmailStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesEmailListWithHttpInfo(activateUserOnSuccess: kotlin.Boolean?, fromAddress: kotlin.String?, host: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, port: kotlin.Int?, search: kotlin.String?, subject: kotlin.String?, template: kotlin.String?, timeout: kotlin.Int?, tokenExpiry: kotlin.Int?, useGlobalSettings: kotlin.Boolean?, useSsl: kotlin.Boolean?, useTls: kotlin.Boolean?, username: kotlin.String?) : ApiResponse<PaginatedEmailStageList?> {
        val localVariableConfig = stagesEmailListRequestConfig(activateUserOnSuccess = activateUserOnSuccess, fromAddress = fromAddress, host = host, name = name, ordering = ordering, page = page, pageSize = pageSize, port = port, search = search, subject = subject, template = template, timeout = timeout, tokenExpiry = tokenExpiry, useGlobalSettings = useGlobalSettings, useSsl = useSsl, useTls = useTls, username = username)

        return request<Unit, PaginatedEmailStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesEmailList
     *
     * @param activateUserOnSuccess  (optional)
     * @param fromAddress  (optional)
     * @param host  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param port  (optional)
     * @param search A search term. (optional)
     * @param subject  (optional)
     * @param template  (optional)
     * @param timeout  (optional)
     * @param tokenExpiry  (optional)
     * @param useGlobalSettings  (optional)
     * @param useSsl  (optional)
     * @param useTls  (optional)
     * @param username  (optional)
     * @return RequestConfig
     */
    fun stagesEmailListRequestConfig(activateUserOnSuccess: kotlin.Boolean?, fromAddress: kotlin.String?, host: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, port: kotlin.Int?, search: kotlin.String?, subject: kotlin.String?, template: kotlin.String?, timeout: kotlin.Int?, tokenExpiry: kotlin.Int?, useGlobalSettings: kotlin.Boolean?, useSsl: kotlin.Boolean?, useTls: kotlin.Boolean?, username: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (activateUserOnSuccess != null) {
                    put("activate_user_on_success", listOf(activateUserOnSuccess.toString()))
                }
                if (fromAddress != null) {
                    put("from_address", listOf(fromAddress.toString()))
                }
                if (host != null) {
                    put("host", listOf(host.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (port != null) {
                    put("port", listOf(port.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (subject != null) {
                    put("subject", listOf(subject.toString()))
                }
                if (template != null) {
                    put("template", listOf(template.toString()))
                }
                if (timeout != null) {
                    put("timeout", listOf(timeout.toString()))
                }
                if (tokenExpiry != null) {
                    put("token_expiry", listOf(tokenExpiry.toString()))
                }
                if (useGlobalSettings != null) {
                    put("use_global_settings", listOf(useGlobalSettings.toString()))
                }
                if (useSsl != null) {
                    put("use_ssl", listOf(useSsl.toString()))
                }
                if (useTls != null) {
                    put("use_tls", listOf(useTls.toString()))
                }
                if (username != null) {
                    put("username", listOf(username.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/email/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * EmailStage Viewset
     * @param stageUuid A UUID string identifying this Email Stage.
     * @param patchedEmailStageRequest  (optional)
     * @return EmailStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesEmailPartialUpdate(stageUuid: java.util.UUID, patchedEmailStageRequest: PatchedEmailStageRequest? = null) : EmailStage {
        val localVarResponse = stagesEmailPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedEmailStageRequest = patchedEmailStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmailStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * EmailStage Viewset
     * @param stageUuid A UUID string identifying this Email Stage.
     * @param patchedEmailStageRequest  (optional)
     * @return ApiResponse<EmailStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesEmailPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedEmailStageRequest: PatchedEmailStageRequest?) : ApiResponse<EmailStage?> {
        val localVariableConfig = stagesEmailPartialUpdateRequestConfig(stageUuid = stageUuid, patchedEmailStageRequest = patchedEmailStageRequest)

        return request<PatchedEmailStageRequest, EmailStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesEmailPartialUpdate
     *
     * @param stageUuid A UUID string identifying this Email Stage.
     * @param patchedEmailStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesEmailPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedEmailStageRequest: PatchedEmailStageRequest?) : RequestConfig<PatchedEmailStageRequest> {
        val localVariableBody = patchedEmailStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/email/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * EmailStage Viewset
     * @param stageUuid A UUID string identifying this Email Stage.
     * @return EmailStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesEmailRetrieve(stageUuid: java.util.UUID) : EmailStage {
        val localVarResponse = stagesEmailRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmailStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * EmailStage Viewset
     * @param stageUuid A UUID string identifying this Email Stage.
     * @return ApiResponse<EmailStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesEmailRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<EmailStage?> {
        val localVariableConfig = stagesEmailRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, EmailStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesEmailRetrieve
     *
     * @param stageUuid A UUID string identifying this Email Stage.
     * @return RequestConfig
     */
    fun stagesEmailRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/email/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all available templates, including custom templates
     * @return kotlin.collections.List<TypeCreate>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesEmailTemplatesList() : kotlin.collections.List<TypeCreate> {
        val localVarResponse = stagesEmailTemplatesListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TypeCreate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all available templates, including custom templates
     * @return ApiResponse<kotlin.collections.List<TypeCreate>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesEmailTemplatesListWithHttpInfo() : ApiResponse<kotlin.collections.List<TypeCreate>?> {
        val localVariableConfig = stagesEmailTemplatesListRequestConfig()

        return request<Unit, kotlin.collections.List<TypeCreate>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesEmailTemplatesList
     *
     * @return RequestConfig
     */
    fun stagesEmailTemplatesListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/email/templates/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * EmailStage Viewset
     * @param stageUuid A UUID string identifying this Email Stage.
     * @param emailStageRequest 
     * @return EmailStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesEmailUpdate(stageUuid: java.util.UUID, emailStageRequest: EmailStageRequest) : EmailStage {
        val localVarResponse = stagesEmailUpdateWithHttpInfo(stageUuid = stageUuid, emailStageRequest = emailStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EmailStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * EmailStage Viewset
     * @param stageUuid A UUID string identifying this Email Stage.
     * @param emailStageRequest 
     * @return ApiResponse<EmailStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesEmailUpdateWithHttpInfo(stageUuid: java.util.UUID, emailStageRequest: EmailStageRequest) : ApiResponse<EmailStage?> {
        val localVariableConfig = stagesEmailUpdateRequestConfig(stageUuid = stageUuid, emailStageRequest = emailStageRequest)

        return request<EmailStageRequest, EmailStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesEmailUpdate
     *
     * @param stageUuid A UUID string identifying this Email Stage.
     * @param emailStageRequest 
     * @return RequestConfig
     */
    fun stagesEmailUpdateRequestConfig(stageUuid: java.util.UUID, emailStageRequest: EmailStageRequest) : RequestConfig<EmailStageRequest> {
        val localVariableBody = emailStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/email/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Email Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesEmailUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesEmailUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Email Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesEmailUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesEmailUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesEmailUsedByList
     *
     * @param stageUuid A UUID string identifying this Email Stage.
     * @return RequestConfig
     */
    fun stagesEmailUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/email/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param identificationStageRequest 
     * @return IdentificationStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesIdentificationCreate(identificationStageRequest: IdentificationStageRequest) : IdentificationStage {
        val localVarResponse = stagesIdentificationCreateWithHttpInfo(identificationStageRequest = identificationStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IdentificationStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param identificationStageRequest 
     * @return ApiResponse<IdentificationStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesIdentificationCreateWithHttpInfo(identificationStageRequest: IdentificationStageRequest) : ApiResponse<IdentificationStage?> {
        val localVariableConfig = stagesIdentificationCreateRequestConfig(identificationStageRequest = identificationStageRequest)

        return request<IdentificationStageRequest, IdentificationStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesIdentificationCreate
     *
     * @param identificationStageRequest 
     * @return RequestConfig
     */
    fun stagesIdentificationCreateRequestConfig(identificationStageRequest: IdentificationStageRequest) : RequestConfig<IdentificationStageRequest> {
        val localVariableBody = identificationStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/identification/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesIdentificationDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesIdentificationDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesIdentificationDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesIdentificationDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesIdentificationDestroy
     *
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @return RequestConfig
     */
    fun stagesIdentificationDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/identification/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param caseInsensitiveMatching  (optional)
     * @param enrollmentFlow  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param passwordStage  (optional)
     * @param passwordlessFlow  (optional)
     * @param recoveryFlow  (optional)
     * @param search A search term. (optional)
     * @param showMatchedUser  (optional)
     * @param showSourceLabels  (optional)
     * @return PaginatedIdentificationStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesIdentificationList(caseInsensitiveMatching: kotlin.Boolean? = null, enrollmentFlow: java.util.UUID? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, passwordStage: java.util.UUID? = null, passwordlessFlow: java.util.UUID? = null, recoveryFlow: java.util.UUID? = null, search: kotlin.String? = null, showMatchedUser: kotlin.Boolean? = null, showSourceLabels: kotlin.Boolean? = null) : PaginatedIdentificationStageList {
        val localVarResponse = stagesIdentificationListWithHttpInfo(caseInsensitiveMatching = caseInsensitiveMatching, enrollmentFlow = enrollmentFlow, name = name, ordering = ordering, page = page, pageSize = pageSize, passwordStage = passwordStage, passwordlessFlow = passwordlessFlow, recoveryFlow = recoveryFlow, search = search, showMatchedUser = showMatchedUser, showSourceLabels = showSourceLabels)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedIdentificationStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param caseInsensitiveMatching  (optional)
     * @param enrollmentFlow  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param passwordStage  (optional)
     * @param passwordlessFlow  (optional)
     * @param recoveryFlow  (optional)
     * @param search A search term. (optional)
     * @param showMatchedUser  (optional)
     * @param showSourceLabels  (optional)
     * @return ApiResponse<PaginatedIdentificationStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesIdentificationListWithHttpInfo(caseInsensitiveMatching: kotlin.Boolean?, enrollmentFlow: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, passwordStage: java.util.UUID?, passwordlessFlow: java.util.UUID?, recoveryFlow: java.util.UUID?, search: kotlin.String?, showMatchedUser: kotlin.Boolean?, showSourceLabels: kotlin.Boolean?) : ApiResponse<PaginatedIdentificationStageList?> {
        val localVariableConfig = stagesIdentificationListRequestConfig(caseInsensitiveMatching = caseInsensitiveMatching, enrollmentFlow = enrollmentFlow, name = name, ordering = ordering, page = page, pageSize = pageSize, passwordStage = passwordStage, passwordlessFlow = passwordlessFlow, recoveryFlow = recoveryFlow, search = search, showMatchedUser = showMatchedUser, showSourceLabels = showSourceLabels)

        return request<Unit, PaginatedIdentificationStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesIdentificationList
     *
     * @param caseInsensitiveMatching  (optional)
     * @param enrollmentFlow  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param passwordStage  (optional)
     * @param passwordlessFlow  (optional)
     * @param recoveryFlow  (optional)
     * @param search A search term. (optional)
     * @param showMatchedUser  (optional)
     * @param showSourceLabels  (optional)
     * @return RequestConfig
     */
    fun stagesIdentificationListRequestConfig(caseInsensitiveMatching: kotlin.Boolean?, enrollmentFlow: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, passwordStage: java.util.UUID?, passwordlessFlow: java.util.UUID?, recoveryFlow: java.util.UUID?, search: kotlin.String?, showMatchedUser: kotlin.Boolean?, showSourceLabels: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (caseInsensitiveMatching != null) {
                    put("case_insensitive_matching", listOf(caseInsensitiveMatching.toString()))
                }
                if (enrollmentFlow != null) {
                    put("enrollment_flow", listOf(enrollmentFlow.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (passwordStage != null) {
                    put("password_stage", listOf(passwordStage.toString()))
                }
                if (passwordlessFlow != null) {
                    put("passwordless_flow", listOf(passwordlessFlow.toString()))
                }
                if (recoveryFlow != null) {
                    put("recovery_flow", listOf(recoveryFlow.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (showMatchedUser != null) {
                    put("show_matched_user", listOf(showMatchedUser.toString()))
                }
                if (showSourceLabels != null) {
                    put("show_source_labels", listOf(showSourceLabels.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/identification/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @param patchedIdentificationStageRequest  (optional)
     * @return IdentificationStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesIdentificationPartialUpdate(stageUuid: java.util.UUID, patchedIdentificationStageRequest: PatchedIdentificationStageRequest? = null) : IdentificationStage {
        val localVarResponse = stagesIdentificationPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedIdentificationStageRequest = patchedIdentificationStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IdentificationStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @param patchedIdentificationStageRequest  (optional)
     * @return ApiResponse<IdentificationStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesIdentificationPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedIdentificationStageRequest: PatchedIdentificationStageRequest?) : ApiResponse<IdentificationStage?> {
        val localVariableConfig = stagesIdentificationPartialUpdateRequestConfig(stageUuid = stageUuid, patchedIdentificationStageRequest = patchedIdentificationStageRequest)

        return request<PatchedIdentificationStageRequest, IdentificationStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesIdentificationPartialUpdate
     *
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @param patchedIdentificationStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesIdentificationPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedIdentificationStageRequest: PatchedIdentificationStageRequest?) : RequestConfig<PatchedIdentificationStageRequest> {
        val localVariableBody = patchedIdentificationStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/identification/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @return IdentificationStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesIdentificationRetrieve(stageUuid: java.util.UUID) : IdentificationStage {
        val localVarResponse = stagesIdentificationRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IdentificationStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @return ApiResponse<IdentificationStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesIdentificationRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<IdentificationStage?> {
        val localVariableConfig = stagesIdentificationRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, IdentificationStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesIdentificationRetrieve
     *
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @return RequestConfig
     */
    fun stagesIdentificationRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/identification/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @param identificationStageRequest 
     * @return IdentificationStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesIdentificationUpdate(stageUuid: java.util.UUID, identificationStageRequest: IdentificationStageRequest) : IdentificationStage {
        val localVarResponse = stagesIdentificationUpdateWithHttpInfo(stageUuid = stageUuid, identificationStageRequest = identificationStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IdentificationStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * IdentificationStage Viewset
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @param identificationStageRequest 
     * @return ApiResponse<IdentificationStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesIdentificationUpdateWithHttpInfo(stageUuid: java.util.UUID, identificationStageRequest: IdentificationStageRequest) : ApiResponse<IdentificationStage?> {
        val localVariableConfig = stagesIdentificationUpdateRequestConfig(stageUuid = stageUuid, identificationStageRequest = identificationStageRequest)

        return request<IdentificationStageRequest, IdentificationStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesIdentificationUpdate
     *
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @param identificationStageRequest 
     * @return RequestConfig
     */
    fun stagesIdentificationUpdateRequestConfig(stageUuid: java.util.UUID, identificationStageRequest: IdentificationStageRequest) : RequestConfig<IdentificationStageRequest> {
        val localVariableBody = identificationStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/identification/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesIdentificationUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesIdentificationUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesIdentificationUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesIdentificationUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesIdentificationUsedByList
     *
     * @param stageUuid A UUID string identifying this Identification Stage.
     * @return RequestConfig
     */
    fun stagesIdentificationUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/identification/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Invitation Viewset
     * @param invitationRequest 
     * @return Invitation
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationInvitationsCreate(invitationRequest: InvitationRequest) : Invitation {
        val localVarResponse = stagesInvitationInvitationsCreateWithHttpInfo(invitationRequest = invitationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Invitation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Invitation Viewset
     * @param invitationRequest 
     * @return ApiResponse<Invitation?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationInvitationsCreateWithHttpInfo(invitationRequest: InvitationRequest) : ApiResponse<Invitation?> {
        val localVariableConfig = stagesInvitationInvitationsCreateRequestConfig(invitationRequest = invitationRequest)

        return request<InvitationRequest, Invitation>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationInvitationsCreate
     *
     * @param invitationRequest 
     * @return RequestConfig
     */
    fun stagesInvitationInvitationsCreateRequestConfig(invitationRequest: InvitationRequest) : RequestConfig<InvitationRequest> {
        val localVariableBody = invitationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/invitation/invitations/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Invitation Viewset
     * @param inviteUuid A UUID string identifying this Invitation.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationInvitationsDestroy(inviteUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesInvitationInvitationsDestroyWithHttpInfo(inviteUuid = inviteUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Invitation Viewset
     * @param inviteUuid A UUID string identifying this Invitation.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationInvitationsDestroyWithHttpInfo(inviteUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesInvitationInvitationsDestroyRequestConfig(inviteUuid = inviteUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationInvitationsDestroy
     *
     * @param inviteUuid A UUID string identifying this Invitation.
     * @return RequestConfig
     */
    fun stagesInvitationInvitationsDestroyRequestConfig(inviteUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/invitation/invitations/{invite_uuid}/".replace("{"+"invite_uuid"+"}", encodeURIComponent(inviteUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Invitation Viewset
     * @param createdByUsername  (optional)
     * @param expires  (optional)
     * @param flowSlug  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedInvitationList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationInvitationsList(createdByUsername: kotlin.String? = null, expires: java.time.OffsetDateTime? = null, flowSlug: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedInvitationList {
        val localVarResponse = stagesInvitationInvitationsListWithHttpInfo(createdByUsername = createdByUsername, expires = expires, flowSlug = flowSlug, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedInvitationList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Invitation Viewset
     * @param createdByUsername  (optional)
     * @param expires  (optional)
     * @param flowSlug  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedInvitationList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationInvitationsListWithHttpInfo(createdByUsername: kotlin.String?, expires: java.time.OffsetDateTime?, flowSlug: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedInvitationList?> {
        val localVariableConfig = stagesInvitationInvitationsListRequestConfig(createdByUsername = createdByUsername, expires = expires, flowSlug = flowSlug, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedInvitationList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationInvitationsList
     *
     * @param createdByUsername  (optional)
     * @param expires  (optional)
     * @param flowSlug  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun stagesInvitationInvitationsListRequestConfig(createdByUsername: kotlin.String?, expires: java.time.OffsetDateTime?, flowSlug: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (createdByUsername != null) {
                    put("created_by__username", listOf(createdByUsername.toString()))
                }
                if (expires != null) {
                    put("expires", listOf(parseDateToQueryString(expires)))
                }
                if (flowSlug != null) {
                    put("flow__slug", listOf(flowSlug.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/invitation/invitations/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Invitation Viewset
     * @param inviteUuid A UUID string identifying this Invitation.
     * @param patchedInvitationRequest  (optional)
     * @return Invitation
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationInvitationsPartialUpdate(inviteUuid: java.util.UUID, patchedInvitationRequest: PatchedInvitationRequest? = null) : Invitation {
        val localVarResponse = stagesInvitationInvitationsPartialUpdateWithHttpInfo(inviteUuid = inviteUuid, patchedInvitationRequest = patchedInvitationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Invitation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Invitation Viewset
     * @param inviteUuid A UUID string identifying this Invitation.
     * @param patchedInvitationRequest  (optional)
     * @return ApiResponse<Invitation?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationInvitationsPartialUpdateWithHttpInfo(inviteUuid: java.util.UUID, patchedInvitationRequest: PatchedInvitationRequest?) : ApiResponse<Invitation?> {
        val localVariableConfig = stagesInvitationInvitationsPartialUpdateRequestConfig(inviteUuid = inviteUuid, patchedInvitationRequest = patchedInvitationRequest)

        return request<PatchedInvitationRequest, Invitation>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationInvitationsPartialUpdate
     *
     * @param inviteUuid A UUID string identifying this Invitation.
     * @param patchedInvitationRequest  (optional)
     * @return RequestConfig
     */
    fun stagesInvitationInvitationsPartialUpdateRequestConfig(inviteUuid: java.util.UUID, patchedInvitationRequest: PatchedInvitationRequest?) : RequestConfig<PatchedInvitationRequest> {
        val localVariableBody = patchedInvitationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/invitation/invitations/{invite_uuid}/".replace("{"+"invite_uuid"+"}", encodeURIComponent(inviteUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Invitation Viewset
     * @param inviteUuid A UUID string identifying this Invitation.
     * @return Invitation
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationInvitationsRetrieve(inviteUuid: java.util.UUID) : Invitation {
        val localVarResponse = stagesInvitationInvitationsRetrieveWithHttpInfo(inviteUuid = inviteUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Invitation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Invitation Viewset
     * @param inviteUuid A UUID string identifying this Invitation.
     * @return ApiResponse<Invitation?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationInvitationsRetrieveWithHttpInfo(inviteUuid: java.util.UUID) : ApiResponse<Invitation?> {
        val localVariableConfig = stagesInvitationInvitationsRetrieveRequestConfig(inviteUuid = inviteUuid)

        return request<Unit, Invitation>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationInvitationsRetrieve
     *
     * @param inviteUuid A UUID string identifying this Invitation.
     * @return RequestConfig
     */
    fun stagesInvitationInvitationsRetrieveRequestConfig(inviteUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/invitation/invitations/{invite_uuid}/".replace("{"+"invite_uuid"+"}", encodeURIComponent(inviteUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Invitation Viewset
     * @param inviteUuid A UUID string identifying this Invitation.
     * @param invitationRequest 
     * @return Invitation
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationInvitationsUpdate(inviteUuid: java.util.UUID, invitationRequest: InvitationRequest) : Invitation {
        val localVarResponse = stagesInvitationInvitationsUpdateWithHttpInfo(inviteUuid = inviteUuid, invitationRequest = invitationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Invitation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Invitation Viewset
     * @param inviteUuid A UUID string identifying this Invitation.
     * @param invitationRequest 
     * @return ApiResponse<Invitation?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationInvitationsUpdateWithHttpInfo(inviteUuid: java.util.UUID, invitationRequest: InvitationRequest) : ApiResponse<Invitation?> {
        val localVariableConfig = stagesInvitationInvitationsUpdateRequestConfig(inviteUuid = inviteUuid, invitationRequest = invitationRequest)

        return request<InvitationRequest, Invitation>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationInvitationsUpdate
     *
     * @param inviteUuid A UUID string identifying this Invitation.
     * @param invitationRequest 
     * @return RequestConfig
     */
    fun stagesInvitationInvitationsUpdateRequestConfig(inviteUuid: java.util.UUID, invitationRequest: InvitationRequest) : RequestConfig<InvitationRequest> {
        val localVariableBody = invitationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/invitation/invitations/{invite_uuid}/".replace("{"+"invite_uuid"+"}", encodeURIComponent(inviteUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param inviteUuid A UUID string identifying this Invitation.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationInvitationsUsedByList(inviteUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesInvitationInvitationsUsedByListWithHttpInfo(inviteUuid = inviteUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param inviteUuid A UUID string identifying this Invitation.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationInvitationsUsedByListWithHttpInfo(inviteUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesInvitationInvitationsUsedByListRequestConfig(inviteUuid = inviteUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationInvitationsUsedByList
     *
     * @param inviteUuid A UUID string identifying this Invitation.
     * @return RequestConfig
     */
    fun stagesInvitationInvitationsUsedByListRequestConfig(inviteUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/invitation/invitations/{invite_uuid}/used_by/".replace("{"+"invite_uuid"+"}", encodeURIComponent(inviteUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * InvitationStage Viewset
     * @param invitationStageRequest 
     * @return InvitationStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationStagesCreate(invitationStageRequest: InvitationStageRequest) : InvitationStage {
        val localVarResponse = stagesInvitationStagesCreateWithHttpInfo(invitationStageRequest = invitationStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvitationStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * InvitationStage Viewset
     * @param invitationStageRequest 
     * @return ApiResponse<InvitationStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationStagesCreateWithHttpInfo(invitationStageRequest: InvitationStageRequest) : ApiResponse<InvitationStage?> {
        val localVariableConfig = stagesInvitationStagesCreateRequestConfig(invitationStageRequest = invitationStageRequest)

        return request<InvitationStageRequest, InvitationStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationStagesCreate
     *
     * @param invitationStageRequest 
     * @return RequestConfig
     */
    fun stagesInvitationStagesCreateRequestConfig(invitationStageRequest: InvitationStageRequest) : RequestConfig<InvitationStageRequest> {
        val localVariableBody = invitationStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/invitation/stages/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * InvitationStage Viewset
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationStagesDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesInvitationStagesDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * InvitationStage Viewset
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationStagesDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesInvitationStagesDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationStagesDestroy
     *
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @return RequestConfig
     */
    fun stagesInvitationStagesDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/invitation/stages/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * InvitationStage Viewset
     * @param continueFlowWithoutInvitation  (optional)
     * @param name  (optional)
     * @param noFlows  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return PaginatedInvitationStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationStagesList(continueFlowWithoutInvitation: kotlin.Boolean? = null, name: kotlin.String? = null, noFlows: kotlin.Boolean? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null) : PaginatedInvitationStageList {
        val localVarResponse = stagesInvitationStagesListWithHttpInfo(continueFlowWithoutInvitation = continueFlowWithoutInvitation, name = name, noFlows = noFlows, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedInvitationStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * InvitationStage Viewset
     * @param continueFlowWithoutInvitation  (optional)
     * @param name  (optional)
     * @param noFlows  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return ApiResponse<PaginatedInvitationStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationStagesListWithHttpInfo(continueFlowWithoutInvitation: kotlin.Boolean?, name: kotlin.String?, noFlows: kotlin.Boolean?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : ApiResponse<PaginatedInvitationStageList?> {
        val localVariableConfig = stagesInvitationStagesListRequestConfig(continueFlowWithoutInvitation = continueFlowWithoutInvitation, name = name, noFlows = noFlows, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return request<Unit, PaginatedInvitationStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationStagesList
     *
     * @param continueFlowWithoutInvitation  (optional)
     * @param name  (optional)
     * @param noFlows  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return RequestConfig
     */
    fun stagesInvitationStagesListRequestConfig(continueFlowWithoutInvitation: kotlin.Boolean?, name: kotlin.String?, noFlows: kotlin.Boolean?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (continueFlowWithoutInvitation != null) {
                    put("continue_flow_without_invitation", listOf(continueFlowWithoutInvitation.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (noFlows != null) {
                    put("no_flows", listOf(noFlows.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/invitation/stages/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * InvitationStage Viewset
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @param patchedInvitationStageRequest  (optional)
     * @return InvitationStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationStagesPartialUpdate(stageUuid: java.util.UUID, patchedInvitationStageRequest: PatchedInvitationStageRequest? = null) : InvitationStage {
        val localVarResponse = stagesInvitationStagesPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedInvitationStageRequest = patchedInvitationStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvitationStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * InvitationStage Viewset
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @param patchedInvitationStageRequest  (optional)
     * @return ApiResponse<InvitationStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationStagesPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedInvitationStageRequest: PatchedInvitationStageRequest?) : ApiResponse<InvitationStage?> {
        val localVariableConfig = stagesInvitationStagesPartialUpdateRequestConfig(stageUuid = stageUuid, patchedInvitationStageRequest = patchedInvitationStageRequest)

        return request<PatchedInvitationStageRequest, InvitationStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationStagesPartialUpdate
     *
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @param patchedInvitationStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesInvitationStagesPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedInvitationStageRequest: PatchedInvitationStageRequest?) : RequestConfig<PatchedInvitationStageRequest> {
        val localVariableBody = patchedInvitationStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/invitation/stages/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * InvitationStage Viewset
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @return InvitationStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationStagesRetrieve(stageUuid: java.util.UUID) : InvitationStage {
        val localVarResponse = stagesInvitationStagesRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvitationStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * InvitationStage Viewset
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @return ApiResponse<InvitationStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationStagesRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<InvitationStage?> {
        val localVariableConfig = stagesInvitationStagesRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, InvitationStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationStagesRetrieve
     *
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @return RequestConfig
     */
    fun stagesInvitationStagesRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/invitation/stages/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * InvitationStage Viewset
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @param invitationStageRequest 
     * @return InvitationStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationStagesUpdate(stageUuid: java.util.UUID, invitationStageRequest: InvitationStageRequest) : InvitationStage {
        val localVarResponse = stagesInvitationStagesUpdateWithHttpInfo(stageUuid = stageUuid, invitationStageRequest = invitationStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InvitationStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * InvitationStage Viewset
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @param invitationStageRequest 
     * @return ApiResponse<InvitationStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationStagesUpdateWithHttpInfo(stageUuid: java.util.UUID, invitationStageRequest: InvitationStageRequest) : ApiResponse<InvitationStage?> {
        val localVariableConfig = stagesInvitationStagesUpdateRequestConfig(stageUuid = stageUuid, invitationStageRequest = invitationStageRequest)

        return request<InvitationStageRequest, InvitationStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationStagesUpdate
     *
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @param invitationStageRequest 
     * @return RequestConfig
     */
    fun stagesInvitationStagesUpdateRequestConfig(stageUuid: java.util.UUID, invitationStageRequest: InvitationStageRequest) : RequestConfig<InvitationStageRequest> {
        val localVariableBody = invitationStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/invitation/stages/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesInvitationStagesUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesInvitationStagesUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesInvitationStagesUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesInvitationStagesUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesInvitationStagesUsedByList
     *
     * @param stageUuid A UUID string identifying this Invitation Stage.
     * @return RequestConfig
     */
    fun stagesInvitationStagesUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/invitation/stages/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PasswordStage Viewset
     * @param passwordStageRequest 
     * @return PasswordStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPasswordCreate(passwordStageRequest: PasswordStageRequest) : PasswordStage {
        val localVarResponse = stagesPasswordCreateWithHttpInfo(passwordStageRequest = passwordStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PasswordStage Viewset
     * @param passwordStageRequest 
     * @return ApiResponse<PasswordStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPasswordCreateWithHttpInfo(passwordStageRequest: PasswordStageRequest) : ApiResponse<PasswordStage?> {
        val localVariableConfig = stagesPasswordCreateRequestConfig(passwordStageRequest = passwordStageRequest)

        return request<PasswordStageRequest, PasswordStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPasswordCreate
     *
     * @param passwordStageRequest 
     * @return RequestConfig
     */
    fun stagesPasswordCreateRequestConfig(passwordStageRequest: PasswordStageRequest) : RequestConfig<PasswordStageRequest> {
        val localVariableBody = passwordStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/password/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PasswordStage Viewset
     * @param stageUuid A UUID string identifying this Password Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPasswordDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesPasswordDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PasswordStage Viewset
     * @param stageUuid A UUID string identifying this Password Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPasswordDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesPasswordDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPasswordDestroy
     *
     * @param stageUuid A UUID string identifying this Password Stage.
     * @return RequestConfig
     */
    fun stagesPasswordDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/password/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PasswordStage Viewset
     * @param configureFlow  (optional)
     * @param failedAttemptsBeforeCancel  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedPasswordStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPasswordList(configureFlow: java.util.UUID? = null, failedAttemptsBeforeCancel: kotlin.Int? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedPasswordStageList {
        val localVarResponse = stagesPasswordListWithHttpInfo(configureFlow = configureFlow, failedAttemptsBeforeCancel = failedAttemptsBeforeCancel, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPasswordStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PasswordStage Viewset
     * @param configureFlow  (optional)
     * @param failedAttemptsBeforeCancel  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedPasswordStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPasswordListWithHttpInfo(configureFlow: java.util.UUID?, failedAttemptsBeforeCancel: kotlin.Int?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedPasswordStageList?> {
        val localVariableConfig = stagesPasswordListRequestConfig(configureFlow = configureFlow, failedAttemptsBeforeCancel = failedAttemptsBeforeCancel, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedPasswordStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPasswordList
     *
     * @param configureFlow  (optional)
     * @param failedAttemptsBeforeCancel  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun stagesPasswordListRequestConfig(configureFlow: java.util.UUID?, failedAttemptsBeforeCancel: kotlin.Int?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (configureFlow != null) {
                    put("configure_flow", listOf(configureFlow.toString()))
                }
                if (failedAttemptsBeforeCancel != null) {
                    put("failed_attempts_before_cancel", listOf(failedAttemptsBeforeCancel.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/password/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PasswordStage Viewset
     * @param stageUuid A UUID string identifying this Password Stage.
     * @param patchedPasswordStageRequest  (optional)
     * @return PasswordStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPasswordPartialUpdate(stageUuid: java.util.UUID, patchedPasswordStageRequest: PatchedPasswordStageRequest? = null) : PasswordStage {
        val localVarResponse = stagesPasswordPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedPasswordStageRequest = patchedPasswordStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PasswordStage Viewset
     * @param stageUuid A UUID string identifying this Password Stage.
     * @param patchedPasswordStageRequest  (optional)
     * @return ApiResponse<PasswordStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPasswordPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedPasswordStageRequest: PatchedPasswordStageRequest?) : ApiResponse<PasswordStage?> {
        val localVariableConfig = stagesPasswordPartialUpdateRequestConfig(stageUuid = stageUuid, patchedPasswordStageRequest = patchedPasswordStageRequest)

        return request<PatchedPasswordStageRequest, PasswordStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPasswordPartialUpdate
     *
     * @param stageUuid A UUID string identifying this Password Stage.
     * @param patchedPasswordStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesPasswordPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedPasswordStageRequest: PatchedPasswordStageRequest?) : RequestConfig<PatchedPasswordStageRequest> {
        val localVariableBody = patchedPasswordStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/password/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PasswordStage Viewset
     * @param stageUuid A UUID string identifying this Password Stage.
     * @return PasswordStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPasswordRetrieve(stageUuid: java.util.UUID) : PasswordStage {
        val localVarResponse = stagesPasswordRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PasswordStage Viewset
     * @param stageUuid A UUID string identifying this Password Stage.
     * @return ApiResponse<PasswordStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPasswordRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<PasswordStage?> {
        val localVariableConfig = stagesPasswordRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, PasswordStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPasswordRetrieve
     *
     * @param stageUuid A UUID string identifying this Password Stage.
     * @return RequestConfig
     */
    fun stagesPasswordRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/password/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PasswordStage Viewset
     * @param stageUuid A UUID string identifying this Password Stage.
     * @param passwordStageRequest 
     * @return PasswordStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPasswordUpdate(stageUuid: java.util.UUID, passwordStageRequest: PasswordStageRequest) : PasswordStage {
        val localVarResponse = stagesPasswordUpdateWithHttpInfo(stageUuid = stageUuid, passwordStageRequest = passwordStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PasswordStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PasswordStage Viewset
     * @param stageUuid A UUID string identifying this Password Stage.
     * @param passwordStageRequest 
     * @return ApiResponse<PasswordStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPasswordUpdateWithHttpInfo(stageUuid: java.util.UUID, passwordStageRequest: PasswordStageRequest) : ApiResponse<PasswordStage?> {
        val localVariableConfig = stagesPasswordUpdateRequestConfig(stageUuid = stageUuid, passwordStageRequest = passwordStageRequest)

        return request<PasswordStageRequest, PasswordStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPasswordUpdate
     *
     * @param stageUuid A UUID string identifying this Password Stage.
     * @param passwordStageRequest 
     * @return RequestConfig
     */
    fun stagesPasswordUpdateRequestConfig(stageUuid: java.util.UUID, passwordStageRequest: PasswordStageRequest) : RequestConfig<PasswordStageRequest> {
        val localVariableBody = passwordStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/password/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Password Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPasswordUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesPasswordUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Password Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPasswordUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesPasswordUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPasswordUsedByList
     *
     * @param stageUuid A UUID string identifying this Password Stage.
     * @return RequestConfig
     */
    fun stagesPasswordUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/password/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Prompt Viewset
     * @param promptRequest 
     * @return Prompt
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptPromptsCreate(promptRequest: PromptRequest) : Prompt {
        val localVarResponse = stagesPromptPromptsCreateWithHttpInfo(promptRequest = promptRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Prompt
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Prompt Viewset
     * @param promptRequest 
     * @return ApiResponse<Prompt?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptPromptsCreateWithHttpInfo(promptRequest: PromptRequest) : ApiResponse<Prompt?> {
        val localVariableConfig = stagesPromptPromptsCreateRequestConfig(promptRequest = promptRequest)

        return request<PromptRequest, Prompt>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptPromptsCreate
     *
     * @param promptRequest 
     * @return RequestConfig
     */
    fun stagesPromptPromptsCreateRequestConfig(promptRequest: PromptRequest) : RequestConfig<PromptRequest> {
        val localVariableBody = promptRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/prompt/prompts/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Prompt Viewset
     * @param promptUuid A UUID string identifying this Prompt.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptPromptsDestroy(promptUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesPromptPromptsDestroyWithHttpInfo(promptUuid = promptUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Prompt Viewset
     * @param promptUuid A UUID string identifying this Prompt.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptPromptsDestroyWithHttpInfo(promptUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesPromptPromptsDestroyRequestConfig(promptUuid = promptUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptPromptsDestroy
     *
     * @param promptUuid A UUID string identifying this Prompt.
     * @return RequestConfig
     */
    fun stagesPromptPromptsDestroyRequestConfig(promptUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/prompt/prompts/{prompt_uuid}/".replace("{"+"prompt_uuid"+"}", encodeURIComponent(promptUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter type
     */
     enum class Type_stagesPromptPromptsList(val value: kotlin.String) {
         @Json(name = "ak-locale") akMinusLocale("ak-locale"),
         @Json(name = "checkbox") checkbox("checkbox"),
         @Json(name = "date") date("date"),
         @Json(name = "date-time") dateMinusTime("date-time"),
         @Json(name = "dropdown") dropdown("dropdown"),
         @Json(name = "email") email("email"),
         @Json(name = "file") file("file"),
         @Json(name = "hidden") hidden("hidden"),
         @Json(name = "number") number("number"),
         @Json(name = "password") password("password"),
         @Json(name = "radio-button-group") radioMinusButtonMinusGroup("radio-button-group"),
         @Json(name = "separator") separator("separator"),
         @Json(name = "static") static("static"),
         @Json(name = "text") text("text"),
         @Json(name = "text_area") textArea("text_area"),
         @Json(name = "text_area_read_only") textAreaReadOnly("text_area_read_only"),
         @Json(name = "text_read_only") textReadOnly("text_read_only"),
         @Json(name = "username") username("username"),
     }

    /**
     * 
     * Prompt Viewset
     * @param fieldKey  (optional)
     * @param label  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param placeholder  (optional)
     * @param search A search term. (optional)
     * @param type * &#x60;text&#x60; - Text: Simple Text input * &#x60;text_area&#x60; - Text area: Multiline Text Input. * &#x60;text_read_only&#x60; - Text (read-only): Simple Text input, but cannot be edited. * &#x60;text_area_read_only&#x60; - Text area (read-only): Multiline Text input, but cannot be edited. * &#x60;username&#x60; - Username: Same as Text input, but checks for and prevents duplicate usernames. * &#x60;email&#x60; - Email: Text field with Email type. * &#x60;password&#x60; - Password: Masked input, multiple inputs of this type on the same prompt need to be identical. * &#x60;number&#x60; - Number * &#x60;checkbox&#x60; - Checkbox * &#x60;radio-button-group&#x60; - Fixed choice field rendered as a group of radio buttons. * &#x60;dropdown&#x60; - Fixed choice field rendered as a dropdown. * &#x60;date&#x60; - Date * &#x60;date-time&#x60; - Date Time * &#x60;file&#x60; - File: File upload for arbitrary files. File content will be available in flow context as data-URI * &#x60;separator&#x60; - Separator: Static Separator Line * &#x60;hidden&#x60; - Hidden: Hidden field, can be used to insert data into form. * &#x60;static&#x60; - Static: Static value, displayed as-is. * &#x60;ak-locale&#x60; - authentik: Selection of locales authentik supports (optional)
     * @return PaginatedPromptList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptPromptsList(fieldKey: kotlin.String? = null, label: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, placeholder: kotlin.String? = null, search: kotlin.String? = null, type: Type_stagesPromptPromptsList? = null) : PaginatedPromptList {
        val localVarResponse = stagesPromptPromptsListWithHttpInfo(fieldKey = fieldKey, label = label, name = name, ordering = ordering, page = page, pageSize = pageSize, placeholder = placeholder, search = search, type = type)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPromptList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Prompt Viewset
     * @param fieldKey  (optional)
     * @param label  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param placeholder  (optional)
     * @param search A search term. (optional)
     * @param type * &#x60;text&#x60; - Text: Simple Text input * &#x60;text_area&#x60; - Text area: Multiline Text Input. * &#x60;text_read_only&#x60; - Text (read-only): Simple Text input, but cannot be edited. * &#x60;text_area_read_only&#x60; - Text area (read-only): Multiline Text input, but cannot be edited. * &#x60;username&#x60; - Username: Same as Text input, but checks for and prevents duplicate usernames. * &#x60;email&#x60; - Email: Text field with Email type. * &#x60;password&#x60; - Password: Masked input, multiple inputs of this type on the same prompt need to be identical. * &#x60;number&#x60; - Number * &#x60;checkbox&#x60; - Checkbox * &#x60;radio-button-group&#x60; - Fixed choice field rendered as a group of radio buttons. * &#x60;dropdown&#x60; - Fixed choice field rendered as a dropdown. * &#x60;date&#x60; - Date * &#x60;date-time&#x60; - Date Time * &#x60;file&#x60; - File: File upload for arbitrary files. File content will be available in flow context as data-URI * &#x60;separator&#x60; - Separator: Static Separator Line * &#x60;hidden&#x60; - Hidden: Hidden field, can be used to insert data into form. * &#x60;static&#x60; - Static: Static value, displayed as-is. * &#x60;ak-locale&#x60; - authentik: Selection of locales authentik supports (optional)
     * @return ApiResponse<PaginatedPromptList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptPromptsListWithHttpInfo(fieldKey: kotlin.String?, label: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, placeholder: kotlin.String?, search: kotlin.String?, type: Type_stagesPromptPromptsList?) : ApiResponse<PaginatedPromptList?> {
        val localVariableConfig = stagesPromptPromptsListRequestConfig(fieldKey = fieldKey, label = label, name = name, ordering = ordering, page = page, pageSize = pageSize, placeholder = placeholder, search = search, type = type)

        return request<Unit, PaginatedPromptList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptPromptsList
     *
     * @param fieldKey  (optional)
     * @param label  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param placeholder  (optional)
     * @param search A search term. (optional)
     * @param type * &#x60;text&#x60; - Text: Simple Text input * &#x60;text_area&#x60; - Text area: Multiline Text Input. * &#x60;text_read_only&#x60; - Text (read-only): Simple Text input, but cannot be edited. * &#x60;text_area_read_only&#x60; - Text area (read-only): Multiline Text input, but cannot be edited. * &#x60;username&#x60; - Username: Same as Text input, but checks for and prevents duplicate usernames. * &#x60;email&#x60; - Email: Text field with Email type. * &#x60;password&#x60; - Password: Masked input, multiple inputs of this type on the same prompt need to be identical. * &#x60;number&#x60; - Number * &#x60;checkbox&#x60; - Checkbox * &#x60;radio-button-group&#x60; - Fixed choice field rendered as a group of radio buttons. * &#x60;dropdown&#x60; - Fixed choice field rendered as a dropdown. * &#x60;date&#x60; - Date * &#x60;date-time&#x60; - Date Time * &#x60;file&#x60; - File: File upload for arbitrary files. File content will be available in flow context as data-URI * &#x60;separator&#x60; - Separator: Static Separator Line * &#x60;hidden&#x60; - Hidden: Hidden field, can be used to insert data into form. * &#x60;static&#x60; - Static: Static value, displayed as-is. * &#x60;ak-locale&#x60; - authentik: Selection of locales authentik supports (optional)
     * @return RequestConfig
     */
    fun stagesPromptPromptsListRequestConfig(fieldKey: kotlin.String?, label: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, placeholder: kotlin.String?, search: kotlin.String?, type: Type_stagesPromptPromptsList?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fieldKey != null) {
                    put("field_key", listOf(fieldKey.toString()))
                }
                if (label != null) {
                    put("label", listOf(label.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (placeholder != null) {
                    put("placeholder", listOf(placeholder.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/prompt/prompts/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Prompt Viewset
     * @param promptUuid A UUID string identifying this Prompt.
     * @param patchedPromptRequest  (optional)
     * @return Prompt
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptPromptsPartialUpdate(promptUuid: java.util.UUID, patchedPromptRequest: PatchedPromptRequest? = null) : Prompt {
        val localVarResponse = stagesPromptPromptsPartialUpdateWithHttpInfo(promptUuid = promptUuid, patchedPromptRequest = patchedPromptRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Prompt
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Prompt Viewset
     * @param promptUuid A UUID string identifying this Prompt.
     * @param patchedPromptRequest  (optional)
     * @return ApiResponse<Prompt?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptPromptsPartialUpdateWithHttpInfo(promptUuid: java.util.UUID, patchedPromptRequest: PatchedPromptRequest?) : ApiResponse<Prompt?> {
        val localVariableConfig = stagesPromptPromptsPartialUpdateRequestConfig(promptUuid = promptUuid, patchedPromptRequest = patchedPromptRequest)

        return request<PatchedPromptRequest, Prompt>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptPromptsPartialUpdate
     *
     * @param promptUuid A UUID string identifying this Prompt.
     * @param patchedPromptRequest  (optional)
     * @return RequestConfig
     */
    fun stagesPromptPromptsPartialUpdateRequestConfig(promptUuid: java.util.UUID, patchedPromptRequest: PatchedPromptRequest?) : RequestConfig<PatchedPromptRequest> {
        val localVariableBody = patchedPromptRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/prompt/prompts/{prompt_uuid}/".replace("{"+"prompt_uuid"+"}", encodeURIComponent(promptUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Preview a prompt as a challenge, just like a flow would receive
     * @param promptRequest 
     * @return PromptChallenge
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptPromptsPreviewCreate(promptRequest: PromptRequest) : PromptChallenge {
        val localVarResponse = stagesPromptPromptsPreviewCreateWithHttpInfo(promptRequest = promptRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromptChallenge
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Preview a prompt as a challenge, just like a flow would receive
     * @param promptRequest 
     * @return ApiResponse<PromptChallenge?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptPromptsPreviewCreateWithHttpInfo(promptRequest: PromptRequest) : ApiResponse<PromptChallenge?> {
        val localVariableConfig = stagesPromptPromptsPreviewCreateRequestConfig(promptRequest = promptRequest)

        return request<PromptRequest, PromptChallenge>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptPromptsPreviewCreate
     *
     * @param promptRequest 
     * @return RequestConfig
     */
    fun stagesPromptPromptsPreviewCreateRequestConfig(promptRequest: PromptRequest) : RequestConfig<PromptRequest> {
        val localVariableBody = promptRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/prompt/prompts/preview/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Prompt Viewset
     * @param promptUuid A UUID string identifying this Prompt.
     * @return Prompt
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptPromptsRetrieve(promptUuid: java.util.UUID) : Prompt {
        val localVarResponse = stagesPromptPromptsRetrieveWithHttpInfo(promptUuid = promptUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Prompt
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Prompt Viewset
     * @param promptUuid A UUID string identifying this Prompt.
     * @return ApiResponse<Prompt?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptPromptsRetrieveWithHttpInfo(promptUuid: java.util.UUID) : ApiResponse<Prompt?> {
        val localVariableConfig = stagesPromptPromptsRetrieveRequestConfig(promptUuid = promptUuid)

        return request<Unit, Prompt>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptPromptsRetrieve
     *
     * @param promptUuid A UUID string identifying this Prompt.
     * @return RequestConfig
     */
    fun stagesPromptPromptsRetrieveRequestConfig(promptUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/prompt/prompts/{prompt_uuid}/".replace("{"+"prompt_uuid"+"}", encodeURIComponent(promptUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Prompt Viewset
     * @param promptUuid A UUID string identifying this Prompt.
     * @param promptRequest 
     * @return Prompt
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptPromptsUpdate(promptUuid: java.util.UUID, promptRequest: PromptRequest) : Prompt {
        val localVarResponse = stagesPromptPromptsUpdateWithHttpInfo(promptUuid = promptUuid, promptRequest = promptRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Prompt
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Prompt Viewset
     * @param promptUuid A UUID string identifying this Prompt.
     * @param promptRequest 
     * @return ApiResponse<Prompt?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptPromptsUpdateWithHttpInfo(promptUuid: java.util.UUID, promptRequest: PromptRequest) : ApiResponse<Prompt?> {
        val localVariableConfig = stagesPromptPromptsUpdateRequestConfig(promptUuid = promptUuid, promptRequest = promptRequest)

        return request<PromptRequest, Prompt>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptPromptsUpdate
     *
     * @param promptUuid A UUID string identifying this Prompt.
     * @param promptRequest 
     * @return RequestConfig
     */
    fun stagesPromptPromptsUpdateRequestConfig(promptUuid: java.util.UUID, promptRequest: PromptRequest) : RequestConfig<PromptRequest> {
        val localVariableBody = promptRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/prompt/prompts/{prompt_uuid}/".replace("{"+"prompt_uuid"+"}", encodeURIComponent(promptUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param promptUuid A UUID string identifying this Prompt.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptPromptsUsedByList(promptUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesPromptPromptsUsedByListWithHttpInfo(promptUuid = promptUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param promptUuid A UUID string identifying this Prompt.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptPromptsUsedByListWithHttpInfo(promptUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesPromptPromptsUsedByListRequestConfig(promptUuid = promptUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptPromptsUsedByList
     *
     * @param promptUuid A UUID string identifying this Prompt.
     * @return RequestConfig
     */
    fun stagesPromptPromptsUsedByListRequestConfig(promptUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/prompt/prompts/{prompt_uuid}/used_by/".replace("{"+"prompt_uuid"+"}", encodeURIComponent(promptUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PromptStage Viewset
     * @param promptStageRequest 
     * @return PromptStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptStagesCreate(promptStageRequest: PromptStageRequest) : PromptStage {
        val localVarResponse = stagesPromptStagesCreateWithHttpInfo(promptStageRequest = promptStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromptStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PromptStage Viewset
     * @param promptStageRequest 
     * @return ApiResponse<PromptStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptStagesCreateWithHttpInfo(promptStageRequest: PromptStageRequest) : ApiResponse<PromptStage?> {
        val localVariableConfig = stagesPromptStagesCreateRequestConfig(promptStageRequest = promptStageRequest)

        return request<PromptStageRequest, PromptStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptStagesCreate
     *
     * @param promptStageRequest 
     * @return RequestConfig
     */
    fun stagesPromptStagesCreateRequestConfig(promptStageRequest: PromptStageRequest) : RequestConfig<PromptStageRequest> {
        val localVariableBody = promptStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/prompt/stages/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PromptStage Viewset
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptStagesDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesPromptStagesDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PromptStage Viewset
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptStagesDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesPromptStagesDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptStagesDestroy
     *
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @return RequestConfig
     */
    fun stagesPromptStagesDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/prompt/stages/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PromptStage Viewset
     * @param fields  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param validationPolicies  (optional)
     * @return PaginatedPromptStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptStagesList(fields: kotlin.collections.List<java.util.UUID>? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null, validationPolicies: kotlin.collections.List<java.util.UUID>? = null) : PaginatedPromptStageList {
        val localVarResponse = stagesPromptStagesListWithHttpInfo(fields = fields, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid, validationPolicies = validationPolicies)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPromptStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PromptStage Viewset
     * @param fields  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param validationPolicies  (optional)
     * @return ApiResponse<PaginatedPromptStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptStagesListWithHttpInfo(fields: kotlin.collections.List<java.util.UUID>?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?, validationPolicies: kotlin.collections.List<java.util.UUID>?) : ApiResponse<PaginatedPromptStageList?> {
        val localVariableConfig = stagesPromptStagesListRequestConfig(fields = fields, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid, validationPolicies = validationPolicies)

        return request<Unit, PaginatedPromptStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptStagesList
     *
     * @param fields  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param validationPolicies  (optional)
     * @return RequestConfig
     */
    fun stagesPromptStagesListRequestConfig(fields: kotlin.collections.List<java.util.UUID>?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?, validationPolicies: kotlin.collections.List<java.util.UUID>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", toMultiValue(fields.toList(), "multi"))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
                if (validationPolicies != null) {
                    put("validation_policies", toMultiValue(validationPolicies.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/prompt/stages/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PromptStage Viewset
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @param patchedPromptStageRequest  (optional)
     * @return PromptStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptStagesPartialUpdate(stageUuid: java.util.UUID, patchedPromptStageRequest: PatchedPromptStageRequest? = null) : PromptStage {
        val localVarResponse = stagesPromptStagesPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedPromptStageRequest = patchedPromptStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromptStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PromptStage Viewset
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @param patchedPromptStageRequest  (optional)
     * @return ApiResponse<PromptStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptStagesPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedPromptStageRequest: PatchedPromptStageRequest?) : ApiResponse<PromptStage?> {
        val localVariableConfig = stagesPromptStagesPartialUpdateRequestConfig(stageUuid = stageUuid, patchedPromptStageRequest = patchedPromptStageRequest)

        return request<PatchedPromptStageRequest, PromptStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptStagesPartialUpdate
     *
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @param patchedPromptStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesPromptStagesPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedPromptStageRequest: PatchedPromptStageRequest?) : RequestConfig<PatchedPromptStageRequest> {
        val localVariableBody = patchedPromptStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/prompt/stages/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PromptStage Viewset
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @return PromptStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptStagesRetrieve(stageUuid: java.util.UUID) : PromptStage {
        val localVarResponse = stagesPromptStagesRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromptStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PromptStage Viewset
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @return ApiResponse<PromptStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptStagesRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<PromptStage?> {
        val localVariableConfig = stagesPromptStagesRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, PromptStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptStagesRetrieve
     *
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @return RequestConfig
     */
    fun stagesPromptStagesRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/prompt/stages/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * PromptStage Viewset
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @param promptStageRequest 
     * @return PromptStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptStagesUpdate(stageUuid: java.util.UUID, promptStageRequest: PromptStageRequest) : PromptStage {
        val localVarResponse = stagesPromptStagesUpdateWithHttpInfo(stageUuid = stageUuid, promptStageRequest = promptStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromptStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * PromptStage Viewset
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @param promptStageRequest 
     * @return ApiResponse<PromptStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptStagesUpdateWithHttpInfo(stageUuid: java.util.UUID, promptStageRequest: PromptStageRequest) : ApiResponse<PromptStage?> {
        val localVariableConfig = stagesPromptStagesUpdateRequestConfig(stageUuid = stageUuid, promptStageRequest = promptStageRequest)

        return request<PromptStageRequest, PromptStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptStagesUpdate
     *
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @param promptStageRequest 
     * @return RequestConfig
     */
    fun stagesPromptStagesUpdateRequestConfig(stageUuid: java.util.UUID, promptStageRequest: PromptStageRequest) : RequestConfig<PromptStageRequest> {
        val localVariableBody = promptStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/prompt/stages/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesPromptStagesUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesPromptStagesUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesPromptStagesUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesPromptStagesUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesPromptStagesUsedByList
     *
     * @param stageUuid A UUID string identifying this Prompt Stage.
     * @return RequestConfig
     */
    fun stagesPromptStagesUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/prompt/stages/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param userDeleteStageRequest 
     * @return UserDeleteStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserDeleteCreate(userDeleteStageRequest: UserDeleteStageRequest) : UserDeleteStage {
        val localVarResponse = stagesUserDeleteCreateWithHttpInfo(userDeleteStageRequest = userDeleteStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserDeleteStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param userDeleteStageRequest 
     * @return ApiResponse<UserDeleteStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserDeleteCreateWithHttpInfo(userDeleteStageRequest: UserDeleteStageRequest) : ApiResponse<UserDeleteStage?> {
        val localVariableConfig = stagesUserDeleteCreateRequestConfig(userDeleteStageRequest = userDeleteStageRequest)

        return request<UserDeleteStageRequest, UserDeleteStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserDeleteCreate
     *
     * @param userDeleteStageRequest 
     * @return RequestConfig
     */
    fun stagesUserDeleteCreateRequestConfig(userDeleteStageRequest: UserDeleteStageRequest) : RequestConfig<UserDeleteStageRequest> {
        val localVariableBody = userDeleteStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/user_delete/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserDeleteDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesUserDeleteDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserDeleteDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesUserDeleteDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserDeleteDestroy
     *
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @return RequestConfig
     */
    fun stagesUserDeleteDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/user_delete/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return PaginatedUserDeleteStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserDeleteList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null) : PaginatedUserDeleteStageList {
        val localVarResponse = stagesUserDeleteListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedUserDeleteStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return ApiResponse<PaginatedUserDeleteStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserDeleteListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : ApiResponse<PaginatedUserDeleteStageList?> {
        val localVariableConfig = stagesUserDeleteListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return request<Unit, PaginatedUserDeleteStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserDeleteList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return RequestConfig
     */
    fun stagesUserDeleteListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_delete/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @param patchedUserDeleteStageRequest  (optional)
     * @return UserDeleteStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserDeletePartialUpdate(stageUuid: java.util.UUID, patchedUserDeleteStageRequest: PatchedUserDeleteStageRequest? = null) : UserDeleteStage {
        val localVarResponse = stagesUserDeletePartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedUserDeleteStageRequest = patchedUserDeleteStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserDeleteStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @param patchedUserDeleteStageRequest  (optional)
     * @return ApiResponse<UserDeleteStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserDeletePartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedUserDeleteStageRequest: PatchedUserDeleteStageRequest?) : ApiResponse<UserDeleteStage?> {
        val localVariableConfig = stagesUserDeletePartialUpdateRequestConfig(stageUuid = stageUuid, patchedUserDeleteStageRequest = patchedUserDeleteStageRequest)

        return request<PatchedUserDeleteStageRequest, UserDeleteStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserDeletePartialUpdate
     *
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @param patchedUserDeleteStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesUserDeletePartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedUserDeleteStageRequest: PatchedUserDeleteStageRequest?) : RequestConfig<PatchedUserDeleteStageRequest> {
        val localVariableBody = patchedUserDeleteStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/user_delete/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @return UserDeleteStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserDeleteRetrieve(stageUuid: java.util.UUID) : UserDeleteStage {
        val localVarResponse = stagesUserDeleteRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserDeleteStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @return ApiResponse<UserDeleteStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserDeleteRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<UserDeleteStage?> {
        val localVariableConfig = stagesUserDeleteRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, UserDeleteStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserDeleteRetrieve
     *
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @return RequestConfig
     */
    fun stagesUserDeleteRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_delete/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @param userDeleteStageRequest 
     * @return UserDeleteStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserDeleteUpdate(stageUuid: java.util.UUID, userDeleteStageRequest: UserDeleteStageRequest) : UserDeleteStage {
        val localVarResponse = stagesUserDeleteUpdateWithHttpInfo(stageUuid = stageUuid, userDeleteStageRequest = userDeleteStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserDeleteStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserDeleteStage Viewset
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @param userDeleteStageRequest 
     * @return ApiResponse<UserDeleteStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserDeleteUpdateWithHttpInfo(stageUuid: java.util.UUID, userDeleteStageRequest: UserDeleteStageRequest) : ApiResponse<UserDeleteStage?> {
        val localVariableConfig = stagesUserDeleteUpdateRequestConfig(stageUuid = stageUuid, userDeleteStageRequest = userDeleteStageRequest)

        return request<UserDeleteStageRequest, UserDeleteStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserDeleteUpdate
     *
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @param userDeleteStageRequest 
     * @return RequestConfig
     */
    fun stagesUserDeleteUpdateRequestConfig(stageUuid: java.util.UUID, userDeleteStageRequest: UserDeleteStageRequest) : RequestConfig<UserDeleteStageRequest> {
        val localVariableBody = userDeleteStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/user_delete/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserDeleteUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesUserDeleteUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserDeleteUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesUserDeleteUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserDeleteUsedByList
     *
     * @param stageUuid A UUID string identifying this User Delete Stage.
     * @return RequestConfig
     */
    fun stagesUserDeleteUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_delete/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param userLoginStageRequest 
     * @return UserLoginStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLoginCreate(userLoginStageRequest: UserLoginStageRequest) : UserLoginStage {
        val localVarResponse = stagesUserLoginCreateWithHttpInfo(userLoginStageRequest = userLoginStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserLoginStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param userLoginStageRequest 
     * @return ApiResponse<UserLoginStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLoginCreateWithHttpInfo(userLoginStageRequest: UserLoginStageRequest) : ApiResponse<UserLoginStage?> {
        val localVariableConfig = stagesUserLoginCreateRequestConfig(userLoginStageRequest = userLoginStageRequest)

        return request<UserLoginStageRequest, UserLoginStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLoginCreate
     *
     * @param userLoginStageRequest 
     * @return RequestConfig
     */
    fun stagesUserLoginCreateRequestConfig(userLoginStageRequest: UserLoginStageRequest) : RequestConfig<UserLoginStageRequest> {
        val localVariableBody = userLoginStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/user_login/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLoginDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesUserLoginDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLoginDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesUserLoginDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLoginDestroy
     *
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @return RequestConfig
     */
    fun stagesUserLoginDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/user_login/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param rememberMeOffset  (optional)
     * @param search A search term. (optional)
     * @param sessionDuration  (optional)
     * @param stageUuid  (optional)
     * @param terminateOtherSessions  (optional)
     * @return PaginatedUserLoginStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLoginList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, rememberMeOffset: kotlin.String? = null, search: kotlin.String? = null, sessionDuration: kotlin.String? = null, stageUuid: java.util.UUID? = null, terminateOtherSessions: kotlin.Boolean? = null) : PaginatedUserLoginStageList {
        val localVarResponse = stagesUserLoginListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, rememberMeOffset = rememberMeOffset, search = search, sessionDuration = sessionDuration, stageUuid = stageUuid, terminateOtherSessions = terminateOtherSessions)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedUserLoginStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param rememberMeOffset  (optional)
     * @param search A search term. (optional)
     * @param sessionDuration  (optional)
     * @param stageUuid  (optional)
     * @param terminateOtherSessions  (optional)
     * @return ApiResponse<PaginatedUserLoginStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLoginListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, rememberMeOffset: kotlin.String?, search: kotlin.String?, sessionDuration: kotlin.String?, stageUuid: java.util.UUID?, terminateOtherSessions: kotlin.Boolean?) : ApiResponse<PaginatedUserLoginStageList?> {
        val localVariableConfig = stagesUserLoginListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, rememberMeOffset = rememberMeOffset, search = search, sessionDuration = sessionDuration, stageUuid = stageUuid, terminateOtherSessions = terminateOtherSessions)

        return request<Unit, PaginatedUserLoginStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLoginList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param rememberMeOffset  (optional)
     * @param search A search term. (optional)
     * @param sessionDuration  (optional)
     * @param stageUuid  (optional)
     * @param terminateOtherSessions  (optional)
     * @return RequestConfig
     */
    fun stagesUserLoginListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, rememberMeOffset: kotlin.String?, search: kotlin.String?, sessionDuration: kotlin.String?, stageUuid: java.util.UUID?, terminateOtherSessions: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (rememberMeOffset != null) {
                    put("remember_me_offset", listOf(rememberMeOffset.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (sessionDuration != null) {
                    put("session_duration", listOf(sessionDuration.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
                if (terminateOtherSessions != null) {
                    put("terminate_other_sessions", listOf(terminateOtherSessions.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_login/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @param patchedUserLoginStageRequest  (optional)
     * @return UserLoginStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLoginPartialUpdate(stageUuid: java.util.UUID, patchedUserLoginStageRequest: PatchedUserLoginStageRequest? = null) : UserLoginStage {
        val localVarResponse = stagesUserLoginPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedUserLoginStageRequest = patchedUserLoginStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserLoginStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @param patchedUserLoginStageRequest  (optional)
     * @return ApiResponse<UserLoginStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLoginPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedUserLoginStageRequest: PatchedUserLoginStageRequest?) : ApiResponse<UserLoginStage?> {
        val localVariableConfig = stagesUserLoginPartialUpdateRequestConfig(stageUuid = stageUuid, patchedUserLoginStageRequest = patchedUserLoginStageRequest)

        return request<PatchedUserLoginStageRequest, UserLoginStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLoginPartialUpdate
     *
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @param patchedUserLoginStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesUserLoginPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedUserLoginStageRequest: PatchedUserLoginStageRequest?) : RequestConfig<PatchedUserLoginStageRequest> {
        val localVariableBody = patchedUserLoginStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/user_login/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @return UserLoginStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLoginRetrieve(stageUuid: java.util.UUID) : UserLoginStage {
        val localVarResponse = stagesUserLoginRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserLoginStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @return ApiResponse<UserLoginStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLoginRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<UserLoginStage?> {
        val localVariableConfig = stagesUserLoginRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, UserLoginStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLoginRetrieve
     *
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @return RequestConfig
     */
    fun stagesUserLoginRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_login/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @param userLoginStageRequest 
     * @return UserLoginStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLoginUpdate(stageUuid: java.util.UUID, userLoginStageRequest: UserLoginStageRequest) : UserLoginStage {
        val localVarResponse = stagesUserLoginUpdateWithHttpInfo(stageUuid = stageUuid, userLoginStageRequest = userLoginStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserLoginStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLoginStage Viewset
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @param userLoginStageRequest 
     * @return ApiResponse<UserLoginStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLoginUpdateWithHttpInfo(stageUuid: java.util.UUID, userLoginStageRequest: UserLoginStageRequest) : ApiResponse<UserLoginStage?> {
        val localVariableConfig = stagesUserLoginUpdateRequestConfig(stageUuid = stageUuid, userLoginStageRequest = userLoginStageRequest)

        return request<UserLoginStageRequest, UserLoginStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLoginUpdate
     *
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @param userLoginStageRequest 
     * @return RequestConfig
     */
    fun stagesUserLoginUpdateRequestConfig(stageUuid: java.util.UUID, userLoginStageRequest: UserLoginStageRequest) : RequestConfig<UserLoginStageRequest> {
        val localVariableBody = userLoginStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/user_login/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLoginUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesUserLoginUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLoginUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesUserLoginUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLoginUsedByList
     *
     * @param stageUuid A UUID string identifying this User Login Stage.
     * @return RequestConfig
     */
    fun stagesUserLoginUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_login/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param userLogoutStageRequest 
     * @return UserLogoutStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLogoutCreate(userLogoutStageRequest: UserLogoutStageRequest) : UserLogoutStage {
        val localVarResponse = stagesUserLogoutCreateWithHttpInfo(userLogoutStageRequest = userLogoutStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserLogoutStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param userLogoutStageRequest 
     * @return ApiResponse<UserLogoutStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLogoutCreateWithHttpInfo(userLogoutStageRequest: UserLogoutStageRequest) : ApiResponse<UserLogoutStage?> {
        val localVariableConfig = stagesUserLogoutCreateRequestConfig(userLogoutStageRequest = userLogoutStageRequest)

        return request<UserLogoutStageRequest, UserLogoutStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLogoutCreate
     *
     * @param userLogoutStageRequest 
     * @return RequestConfig
     */
    fun stagesUserLogoutCreateRequestConfig(userLogoutStageRequest: UserLogoutStageRequest) : RequestConfig<UserLogoutStageRequest> {
        val localVariableBody = userLogoutStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/user_logout/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLogoutDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesUserLogoutDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLogoutDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesUserLogoutDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLogoutDestroy
     *
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @return RequestConfig
     */
    fun stagesUserLogoutDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/user_logout/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return PaginatedUserLogoutStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLogoutList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null) : PaginatedUserLogoutStageList {
        val localVarResponse = stagesUserLogoutListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedUserLogoutStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return ApiResponse<PaginatedUserLogoutStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLogoutListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : ApiResponse<PaginatedUserLogoutStageList?> {
        val localVariableConfig = stagesUserLogoutListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid)

        return request<Unit, PaginatedUserLogoutStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLogoutList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @return RequestConfig
     */
    fun stagesUserLogoutListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_logout/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @param patchedUserLogoutStageRequest  (optional)
     * @return UserLogoutStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLogoutPartialUpdate(stageUuid: java.util.UUID, patchedUserLogoutStageRequest: PatchedUserLogoutStageRequest? = null) : UserLogoutStage {
        val localVarResponse = stagesUserLogoutPartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedUserLogoutStageRequest = patchedUserLogoutStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserLogoutStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @param patchedUserLogoutStageRequest  (optional)
     * @return ApiResponse<UserLogoutStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLogoutPartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedUserLogoutStageRequest: PatchedUserLogoutStageRequest?) : ApiResponse<UserLogoutStage?> {
        val localVariableConfig = stagesUserLogoutPartialUpdateRequestConfig(stageUuid = stageUuid, patchedUserLogoutStageRequest = patchedUserLogoutStageRequest)

        return request<PatchedUserLogoutStageRequest, UserLogoutStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLogoutPartialUpdate
     *
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @param patchedUserLogoutStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesUserLogoutPartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedUserLogoutStageRequest: PatchedUserLogoutStageRequest?) : RequestConfig<PatchedUserLogoutStageRequest> {
        val localVariableBody = patchedUserLogoutStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/user_logout/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @return UserLogoutStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLogoutRetrieve(stageUuid: java.util.UUID) : UserLogoutStage {
        val localVarResponse = stagesUserLogoutRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserLogoutStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @return ApiResponse<UserLogoutStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLogoutRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<UserLogoutStage?> {
        val localVariableConfig = stagesUserLogoutRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, UserLogoutStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLogoutRetrieve
     *
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @return RequestConfig
     */
    fun stagesUserLogoutRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_logout/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @param userLogoutStageRequest 
     * @return UserLogoutStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLogoutUpdate(stageUuid: java.util.UUID, userLogoutStageRequest: UserLogoutStageRequest) : UserLogoutStage {
        val localVarResponse = stagesUserLogoutUpdateWithHttpInfo(stageUuid = stageUuid, userLogoutStageRequest = userLogoutStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserLogoutStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserLogoutStage Viewset
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @param userLogoutStageRequest 
     * @return ApiResponse<UserLogoutStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLogoutUpdateWithHttpInfo(stageUuid: java.util.UUID, userLogoutStageRequest: UserLogoutStageRequest) : ApiResponse<UserLogoutStage?> {
        val localVariableConfig = stagesUserLogoutUpdateRequestConfig(stageUuid = stageUuid, userLogoutStageRequest = userLogoutStageRequest)

        return request<UserLogoutStageRequest, UserLogoutStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLogoutUpdate
     *
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @param userLogoutStageRequest 
     * @return RequestConfig
     */
    fun stagesUserLogoutUpdateRequestConfig(stageUuid: java.util.UUID, userLogoutStageRequest: UserLogoutStageRequest) : RequestConfig<UserLogoutStageRequest> {
        val localVariableBody = userLogoutStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/user_logout/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserLogoutUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesUserLogoutUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserLogoutUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesUserLogoutUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserLogoutUsedByList
     *
     * @param stageUuid A UUID string identifying this User Logout Stage.
     * @return RequestConfig
     */
    fun stagesUserLogoutUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_logout/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserWriteStage Viewset
     * @param userWriteStageRequest 
     * @return UserWriteStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserWriteCreate(userWriteStageRequest: UserWriteStageRequest) : UserWriteStage {
        val localVarResponse = stagesUserWriteCreateWithHttpInfo(userWriteStageRequest = userWriteStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserWriteStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserWriteStage Viewset
     * @param userWriteStageRequest 
     * @return ApiResponse<UserWriteStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserWriteCreateWithHttpInfo(userWriteStageRequest: UserWriteStageRequest) : ApiResponse<UserWriteStage?> {
        val localVariableConfig = stagesUserWriteCreateRequestConfig(userWriteStageRequest = userWriteStageRequest)

        return request<UserWriteStageRequest, UserWriteStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserWriteCreate
     *
     * @param userWriteStageRequest 
     * @return RequestConfig
     */
    fun stagesUserWriteCreateRequestConfig(userWriteStageRequest: UserWriteStageRequest) : RequestConfig<UserWriteStageRequest> {
        val localVariableBody = userWriteStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/stages/user_write/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserWriteStage Viewset
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserWriteDestroy(stageUuid: java.util.UUID) : Unit {
        val localVarResponse = stagesUserWriteDestroyWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserWriteStage Viewset
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserWriteDestroyWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = stagesUserWriteDestroyRequestConfig(stageUuid = stageUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserWriteDestroy
     *
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @return RequestConfig
     */
    fun stagesUserWriteDestroyRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/stages/user_write/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter userCreationMode
     */
     enum class UserCreationMode_stagesUserWriteList(val value: kotlin.String) {
         @Json(name = "always_create") alwaysCreate("always_create"),
         @Json(name = "create_when_required") createWhenRequired("create_when_required"),
         @Json(name = "never_create") neverCreate("never_create"),
     }

    /**
     * enum for parameter userType
     */
     enum class UserType_stagesUserWriteList(val value: kotlin.String) {
         @Json(name = "external") `external`("external"),
         @Json(name = "internal") `internal`("internal"),
         @Json(name = "internal_service_account") internalServiceAccount("internal_service_account"),
         @Json(name = "service_account") serviceAccount("service_account"),
     }

    /**
     * 
     * UserWriteStage Viewset
     * @param createUsersAsInactive  (optional)
     * @param createUsersGroup  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param userCreationMode * &#x60;never_create&#x60; - Never Create * &#x60;create_when_required&#x60; - Create When Required * &#x60;always_create&#x60; - Always Create (optional)
     * @param userPathTemplate  (optional)
     * @param userType * &#x60;internal&#x60; - Internal * &#x60;external&#x60; - External * &#x60;service_account&#x60; - Service Account * &#x60;internal_service_account&#x60; - Internal Service Account (optional)
     * @return PaginatedUserWriteStageList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserWriteList(createUsersAsInactive: kotlin.Boolean? = null, createUsersGroup: java.util.UUID? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, stageUuid: java.util.UUID? = null, userCreationMode: UserCreationMode_stagesUserWriteList? = null, userPathTemplate: kotlin.String? = null, userType: UserType_stagesUserWriteList? = null) : PaginatedUserWriteStageList {
        val localVarResponse = stagesUserWriteListWithHttpInfo(createUsersAsInactive = createUsersAsInactive, createUsersGroup = createUsersGroup, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid, userCreationMode = userCreationMode, userPathTemplate = userPathTemplate, userType = userType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedUserWriteStageList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserWriteStage Viewset
     * @param createUsersAsInactive  (optional)
     * @param createUsersGroup  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param userCreationMode * &#x60;never_create&#x60; - Never Create * &#x60;create_when_required&#x60; - Create When Required * &#x60;always_create&#x60; - Always Create (optional)
     * @param userPathTemplate  (optional)
     * @param userType * &#x60;internal&#x60; - Internal * &#x60;external&#x60; - External * &#x60;service_account&#x60; - Service Account * &#x60;internal_service_account&#x60; - Internal Service Account (optional)
     * @return ApiResponse<PaginatedUserWriteStageList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserWriteListWithHttpInfo(createUsersAsInactive: kotlin.Boolean?, createUsersGroup: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?, userCreationMode: UserCreationMode_stagesUserWriteList?, userPathTemplate: kotlin.String?, userType: UserType_stagesUserWriteList?) : ApiResponse<PaginatedUserWriteStageList?> {
        val localVariableConfig = stagesUserWriteListRequestConfig(createUsersAsInactive = createUsersAsInactive, createUsersGroup = createUsersGroup, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, stageUuid = stageUuid, userCreationMode = userCreationMode, userPathTemplate = userPathTemplate, userType = userType)

        return request<Unit, PaginatedUserWriteStageList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserWriteList
     *
     * @param createUsersAsInactive  (optional)
     * @param createUsersGroup  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param stageUuid  (optional)
     * @param userCreationMode * &#x60;never_create&#x60; - Never Create * &#x60;create_when_required&#x60; - Create When Required * &#x60;always_create&#x60; - Always Create (optional)
     * @param userPathTemplate  (optional)
     * @param userType * &#x60;internal&#x60; - Internal * &#x60;external&#x60; - External * &#x60;service_account&#x60; - Service Account * &#x60;internal_service_account&#x60; - Internal Service Account (optional)
     * @return RequestConfig
     */
    fun stagesUserWriteListRequestConfig(createUsersAsInactive: kotlin.Boolean?, createUsersGroup: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, stageUuid: java.util.UUID?, userCreationMode: UserCreationMode_stagesUserWriteList?, userPathTemplate: kotlin.String?, userType: UserType_stagesUserWriteList?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (createUsersAsInactive != null) {
                    put("create_users_as_inactive", listOf(createUsersAsInactive.toString()))
                }
                if (createUsersGroup != null) {
                    put("create_users_group", listOf(createUsersGroup.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (stageUuid != null) {
                    put("stage_uuid", listOf(stageUuid.toString()))
                }
                if (userCreationMode != null) {
                    put("user_creation_mode", listOf(userCreationMode.toString()))
                }
                if (userPathTemplate != null) {
                    put("user_path_template", listOf(userPathTemplate.toString()))
                }
                if (userType != null) {
                    put("user_type", listOf(userType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_write/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserWriteStage Viewset
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @param patchedUserWriteStageRequest  (optional)
     * @return UserWriteStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserWritePartialUpdate(stageUuid: java.util.UUID, patchedUserWriteStageRequest: PatchedUserWriteStageRequest? = null) : UserWriteStage {
        val localVarResponse = stagesUserWritePartialUpdateWithHttpInfo(stageUuid = stageUuid, patchedUserWriteStageRequest = patchedUserWriteStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserWriteStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserWriteStage Viewset
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @param patchedUserWriteStageRequest  (optional)
     * @return ApiResponse<UserWriteStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserWritePartialUpdateWithHttpInfo(stageUuid: java.util.UUID, patchedUserWriteStageRequest: PatchedUserWriteStageRequest?) : ApiResponse<UserWriteStage?> {
        val localVariableConfig = stagesUserWritePartialUpdateRequestConfig(stageUuid = stageUuid, patchedUserWriteStageRequest = patchedUserWriteStageRequest)

        return request<PatchedUserWriteStageRequest, UserWriteStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserWritePartialUpdate
     *
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @param patchedUserWriteStageRequest  (optional)
     * @return RequestConfig
     */
    fun stagesUserWritePartialUpdateRequestConfig(stageUuid: java.util.UUID, patchedUserWriteStageRequest: PatchedUserWriteStageRequest?) : RequestConfig<PatchedUserWriteStageRequest> {
        val localVariableBody = patchedUserWriteStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/stages/user_write/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserWriteStage Viewset
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @return UserWriteStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserWriteRetrieve(stageUuid: java.util.UUID) : UserWriteStage {
        val localVarResponse = stagesUserWriteRetrieveWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserWriteStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserWriteStage Viewset
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @return ApiResponse<UserWriteStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserWriteRetrieveWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<UserWriteStage?> {
        val localVariableConfig = stagesUserWriteRetrieveRequestConfig(stageUuid = stageUuid)

        return request<Unit, UserWriteStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserWriteRetrieve
     *
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @return RequestConfig
     */
    fun stagesUserWriteRetrieveRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_write/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * UserWriteStage Viewset
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @param userWriteStageRequest 
     * @return UserWriteStage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserWriteUpdate(stageUuid: java.util.UUID, userWriteStageRequest: UserWriteStageRequest) : UserWriteStage {
        val localVarResponse = stagesUserWriteUpdateWithHttpInfo(stageUuid = stageUuid, userWriteStageRequest = userWriteStageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserWriteStage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * UserWriteStage Viewset
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @param userWriteStageRequest 
     * @return ApiResponse<UserWriteStage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserWriteUpdateWithHttpInfo(stageUuid: java.util.UUID, userWriteStageRequest: UserWriteStageRequest) : ApiResponse<UserWriteStage?> {
        val localVariableConfig = stagesUserWriteUpdateRequestConfig(stageUuid = stageUuid, userWriteStageRequest = userWriteStageRequest)

        return request<UserWriteStageRequest, UserWriteStage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserWriteUpdate
     *
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @param userWriteStageRequest 
     * @return RequestConfig
     */
    fun stagesUserWriteUpdateRequestConfig(stageUuid: java.util.UUID, userWriteStageRequest: UserWriteStageRequest) : RequestConfig<UserWriteStageRequest> {
        val localVariableBody = userWriteStageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/stages/user_write/{stage_uuid}/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stagesUserWriteUsedByList(stageUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = stagesUserWriteUsedByListWithHttpInfo(stageUuid = stageUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun stagesUserWriteUsedByListWithHttpInfo(stageUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = stagesUserWriteUsedByListRequestConfig(stageUuid = stageUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stagesUserWriteUsedByList
     *
     * @param stageUuid A UUID string identifying this User Write Stage.
     * @return RequestConfig
     */
    fun stagesUserWriteUsedByListRequestConfig(stageUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stages/user_write/{stage_uuid}/used_by/".replace("{"+"stage_uuid"+"}", encodeURIComponent(stageUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
