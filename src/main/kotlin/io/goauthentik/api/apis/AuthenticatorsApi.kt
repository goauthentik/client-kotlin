/**
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2023.8.3
 * Contact: hello@goauthentik.io
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.Device
import io.goauthentik.api.models.DuoDevice
import io.goauthentik.api.models.DuoDeviceRequest
import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.PaginatedDuoDeviceList
import io.goauthentik.api.models.PaginatedSMSDeviceList
import io.goauthentik.api.models.PaginatedStaticDeviceList
import io.goauthentik.api.models.PaginatedTOTPDeviceList
import io.goauthentik.api.models.PaginatedWebAuthnDeviceList
import io.goauthentik.api.models.PatchedDuoDeviceRequest
import io.goauthentik.api.models.PatchedSMSDeviceRequest
import io.goauthentik.api.models.PatchedStaticDeviceRequest
import io.goauthentik.api.models.PatchedTOTPDeviceRequest
import io.goauthentik.api.models.PatchedWebAuthnDeviceRequest
import io.goauthentik.api.models.SMSDevice
import io.goauthentik.api.models.SMSDeviceRequest
import io.goauthentik.api.models.StaticDevice
import io.goauthentik.api.models.StaticDeviceRequest
import io.goauthentik.api.models.TOTPDevice
import io.goauthentik.api.models.TOTPDeviceRequest
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.ValidationError
import io.goauthentik.api.models.WebAuthnDevice
import io.goauthentik.api.models.WebAuthnDeviceRequest

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class AuthenticatorsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * Get all devices for current user
     * @param user  (optional)
     * @return kotlin.collections.List<Device>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminAllList(user: kotlin.Int? = null) : kotlin.collections.List<Device> {
        val localVarResponse = authenticatorsAdminAllListWithHttpInfo(user = user)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Device>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all devices for current user
     * @param user  (optional)
     * @return ApiResponse<kotlin.collections.List<Device>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminAllListWithHttpInfo(user: kotlin.Int?) : ApiResponse<kotlin.collections.List<Device>?> {
        val localVariableConfig = authenticatorsAdminAllListRequestConfig(user = user)

        return request<Unit, kotlin.collections.List<Device>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminAllList
     *
     * @param user  (optional)
     * @return RequestConfig
     */
    fun authenticatorsAdminAllListRequestConfig(user: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/admin/all/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param duoDeviceRequest 
     * @return DuoDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminDuoCreate(duoDeviceRequest: DuoDeviceRequest) : DuoDevice {
        val localVarResponse = authenticatorsAdminDuoCreateWithHttpInfo(duoDeviceRequest = duoDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DuoDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param duoDeviceRequest 
     * @return ApiResponse<DuoDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminDuoCreateWithHttpInfo(duoDeviceRequest: DuoDeviceRequest) : ApiResponse<DuoDevice?> {
        val localVariableConfig = authenticatorsAdminDuoCreateRequestConfig(duoDeviceRequest = duoDeviceRequest)

        return request<DuoDeviceRequest, DuoDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminDuoCreate
     *
     * @param duoDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsAdminDuoCreateRequestConfig(duoDeviceRequest: DuoDeviceRequest) : RequestConfig<DuoDeviceRequest> {
        val localVariableBody = duoDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/authenticators/admin/duo/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param id A unique integer value identifying this Duo Device.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminDuoDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = authenticatorsAdminDuoDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param id A unique integer value identifying this Duo Device.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminDuoDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = authenticatorsAdminDuoDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminDuoDestroy
     *
     * @param id A unique integer value identifying this Duo Device.
     * @return RequestConfig
     */
    fun authenticatorsAdminDuoDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/authenticators/admin/duo/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedDuoDeviceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminDuoList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedDuoDeviceList {
        val localVarResponse = authenticatorsAdminDuoListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDuoDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedDuoDeviceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminDuoListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedDuoDeviceList?> {
        val localVariableConfig = authenticatorsAdminDuoListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedDuoDeviceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminDuoList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun authenticatorsAdminDuoListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/admin/duo/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param id A unique integer value identifying this Duo Device.
     * @param patchedDuoDeviceRequest  (optional)
     * @return DuoDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminDuoPartialUpdate(id: kotlin.Int, patchedDuoDeviceRequest: PatchedDuoDeviceRequest? = null) : DuoDevice {
        val localVarResponse = authenticatorsAdminDuoPartialUpdateWithHttpInfo(id = id, patchedDuoDeviceRequest = patchedDuoDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DuoDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param id A unique integer value identifying this Duo Device.
     * @param patchedDuoDeviceRequest  (optional)
     * @return ApiResponse<DuoDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminDuoPartialUpdateWithHttpInfo(id: kotlin.Int, patchedDuoDeviceRequest: PatchedDuoDeviceRequest?) : ApiResponse<DuoDevice?> {
        val localVariableConfig = authenticatorsAdminDuoPartialUpdateRequestConfig(id = id, patchedDuoDeviceRequest = patchedDuoDeviceRequest)

        return request<PatchedDuoDeviceRequest, DuoDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminDuoPartialUpdate
     *
     * @param id A unique integer value identifying this Duo Device.
     * @param patchedDuoDeviceRequest  (optional)
     * @return RequestConfig
     */
    fun authenticatorsAdminDuoPartialUpdateRequestConfig(id: kotlin.Int, patchedDuoDeviceRequest: PatchedDuoDeviceRequest?) : RequestConfig<PatchedDuoDeviceRequest> {
        val localVariableBody = patchedDuoDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/authenticators/admin/duo/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param id A unique integer value identifying this Duo Device.
     * @return DuoDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminDuoRetrieve(id: kotlin.Int) : DuoDevice {
        val localVarResponse = authenticatorsAdminDuoRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DuoDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param id A unique integer value identifying this Duo Device.
     * @return ApiResponse<DuoDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminDuoRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<DuoDevice?> {
        val localVariableConfig = authenticatorsAdminDuoRetrieveRequestConfig(id = id)

        return request<Unit, DuoDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminDuoRetrieve
     *
     * @param id A unique integer value identifying this Duo Device.
     * @return RequestConfig
     */
    fun authenticatorsAdminDuoRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/admin/duo/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param id A unique integer value identifying this Duo Device.
     * @param duoDeviceRequest 
     * @return DuoDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminDuoUpdate(id: kotlin.Int, duoDeviceRequest: DuoDeviceRequest) : DuoDevice {
        val localVarResponse = authenticatorsAdminDuoUpdateWithHttpInfo(id = id, duoDeviceRequest = duoDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DuoDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for Duo authenticator devices (for admins)
     * @param id A unique integer value identifying this Duo Device.
     * @param duoDeviceRequest 
     * @return ApiResponse<DuoDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminDuoUpdateWithHttpInfo(id: kotlin.Int, duoDeviceRequest: DuoDeviceRequest) : ApiResponse<DuoDevice?> {
        val localVariableConfig = authenticatorsAdminDuoUpdateRequestConfig(id = id, duoDeviceRequest = duoDeviceRequest)

        return request<DuoDeviceRequest, DuoDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminDuoUpdate
     *
     * @param id A unique integer value identifying this Duo Device.
     * @param duoDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsAdminDuoUpdateRequestConfig(id: kotlin.Int, duoDeviceRequest: DuoDeviceRequest) : RequestConfig<DuoDeviceRequest> {
        val localVariableBody = duoDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/authenticators/admin/duo/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param smSDeviceRequest 
     * @return SMSDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminSmsCreate(smSDeviceRequest: SMSDeviceRequest) : SMSDevice {
        val localVarResponse = authenticatorsAdminSmsCreateWithHttpInfo(smSDeviceRequest = smSDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SMSDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param smSDeviceRequest 
     * @return ApiResponse<SMSDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminSmsCreateWithHttpInfo(smSDeviceRequest: SMSDeviceRequest) : ApiResponse<SMSDevice?> {
        val localVariableConfig = authenticatorsAdminSmsCreateRequestConfig(smSDeviceRequest = smSDeviceRequest)

        return request<SMSDeviceRequest, SMSDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminSmsCreate
     *
     * @param smSDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsAdminSmsCreateRequestConfig(smSDeviceRequest: SMSDeviceRequest) : RequestConfig<SMSDeviceRequest> {
        val localVariableBody = smSDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/authenticators/admin/sms/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param id A unique integer value identifying this SMS Device.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminSmsDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = authenticatorsAdminSmsDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param id A unique integer value identifying this SMS Device.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminSmsDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = authenticatorsAdminSmsDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminSmsDestroy
     *
     * @param id A unique integer value identifying this SMS Device.
     * @return RequestConfig
     */
    fun authenticatorsAdminSmsDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/authenticators/admin/sms/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedSMSDeviceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminSmsList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedSMSDeviceList {
        val localVarResponse = authenticatorsAdminSmsListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedSMSDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedSMSDeviceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminSmsListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedSMSDeviceList?> {
        val localVariableConfig = authenticatorsAdminSmsListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedSMSDeviceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminSmsList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun authenticatorsAdminSmsListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/admin/sms/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param id A unique integer value identifying this SMS Device.
     * @param patchedSMSDeviceRequest  (optional)
     * @return SMSDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminSmsPartialUpdate(id: kotlin.Int, patchedSMSDeviceRequest: PatchedSMSDeviceRequest? = null) : SMSDevice {
        val localVarResponse = authenticatorsAdminSmsPartialUpdateWithHttpInfo(id = id, patchedSMSDeviceRequest = patchedSMSDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SMSDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param id A unique integer value identifying this SMS Device.
     * @param patchedSMSDeviceRequest  (optional)
     * @return ApiResponse<SMSDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminSmsPartialUpdateWithHttpInfo(id: kotlin.Int, patchedSMSDeviceRequest: PatchedSMSDeviceRequest?) : ApiResponse<SMSDevice?> {
        val localVariableConfig = authenticatorsAdminSmsPartialUpdateRequestConfig(id = id, patchedSMSDeviceRequest = patchedSMSDeviceRequest)

        return request<PatchedSMSDeviceRequest, SMSDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminSmsPartialUpdate
     *
     * @param id A unique integer value identifying this SMS Device.
     * @param patchedSMSDeviceRequest  (optional)
     * @return RequestConfig
     */
    fun authenticatorsAdminSmsPartialUpdateRequestConfig(id: kotlin.Int, patchedSMSDeviceRequest: PatchedSMSDeviceRequest?) : RequestConfig<PatchedSMSDeviceRequest> {
        val localVariableBody = patchedSMSDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/authenticators/admin/sms/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param id A unique integer value identifying this SMS Device.
     * @return SMSDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminSmsRetrieve(id: kotlin.Int) : SMSDevice {
        val localVarResponse = authenticatorsAdminSmsRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SMSDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param id A unique integer value identifying this SMS Device.
     * @return ApiResponse<SMSDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminSmsRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<SMSDevice?> {
        val localVariableConfig = authenticatorsAdminSmsRetrieveRequestConfig(id = id)

        return request<Unit, SMSDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminSmsRetrieve
     *
     * @param id A unique integer value identifying this SMS Device.
     * @return RequestConfig
     */
    fun authenticatorsAdminSmsRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/admin/sms/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param id A unique integer value identifying this SMS Device.
     * @param smSDeviceRequest 
     * @return SMSDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminSmsUpdate(id: kotlin.Int, smSDeviceRequest: SMSDeviceRequest) : SMSDevice {
        val localVarResponse = authenticatorsAdminSmsUpdateWithHttpInfo(id = id, smSDeviceRequest = smSDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SMSDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for sms authenticator devices (for admins)
     * @param id A unique integer value identifying this SMS Device.
     * @param smSDeviceRequest 
     * @return ApiResponse<SMSDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminSmsUpdateWithHttpInfo(id: kotlin.Int, smSDeviceRequest: SMSDeviceRequest) : ApiResponse<SMSDevice?> {
        val localVariableConfig = authenticatorsAdminSmsUpdateRequestConfig(id = id, smSDeviceRequest = smSDeviceRequest)

        return request<SMSDeviceRequest, SMSDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminSmsUpdate
     *
     * @param id A unique integer value identifying this SMS Device.
     * @param smSDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsAdminSmsUpdateRequestConfig(id: kotlin.Int, smSDeviceRequest: SMSDeviceRequest) : RequestConfig<SMSDeviceRequest> {
        val localVariableBody = smSDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/authenticators/admin/sms/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param staticDeviceRequest 
     * @return StaticDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminStaticCreate(staticDeviceRequest: StaticDeviceRequest) : StaticDevice {
        val localVarResponse = authenticatorsAdminStaticCreateWithHttpInfo(staticDeviceRequest = staticDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StaticDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param staticDeviceRequest 
     * @return ApiResponse<StaticDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminStaticCreateWithHttpInfo(staticDeviceRequest: StaticDeviceRequest) : ApiResponse<StaticDevice?> {
        val localVariableConfig = authenticatorsAdminStaticCreateRequestConfig(staticDeviceRequest = staticDeviceRequest)

        return request<StaticDeviceRequest, StaticDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminStaticCreate
     *
     * @param staticDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsAdminStaticCreateRequestConfig(staticDeviceRequest: StaticDeviceRequest) : RequestConfig<StaticDeviceRequest> {
        val localVariableBody = staticDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/authenticators/admin/static/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param id A unique integer value identifying this Static Device.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminStaticDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = authenticatorsAdminStaticDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param id A unique integer value identifying this Static Device.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminStaticDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = authenticatorsAdminStaticDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminStaticDestroy
     *
     * @param id A unique integer value identifying this Static Device.
     * @return RequestConfig
     */
    fun authenticatorsAdminStaticDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/authenticators/admin/static/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedStaticDeviceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminStaticList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedStaticDeviceList {
        val localVarResponse = authenticatorsAdminStaticListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedStaticDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedStaticDeviceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminStaticListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedStaticDeviceList?> {
        val localVariableConfig = authenticatorsAdminStaticListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedStaticDeviceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminStaticList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun authenticatorsAdminStaticListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/admin/static/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param id A unique integer value identifying this Static Device.
     * @param patchedStaticDeviceRequest  (optional)
     * @return StaticDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminStaticPartialUpdate(id: kotlin.Int, patchedStaticDeviceRequest: PatchedStaticDeviceRequest? = null) : StaticDevice {
        val localVarResponse = authenticatorsAdminStaticPartialUpdateWithHttpInfo(id = id, patchedStaticDeviceRequest = patchedStaticDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StaticDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param id A unique integer value identifying this Static Device.
     * @param patchedStaticDeviceRequest  (optional)
     * @return ApiResponse<StaticDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminStaticPartialUpdateWithHttpInfo(id: kotlin.Int, patchedStaticDeviceRequest: PatchedStaticDeviceRequest?) : ApiResponse<StaticDevice?> {
        val localVariableConfig = authenticatorsAdminStaticPartialUpdateRequestConfig(id = id, patchedStaticDeviceRequest = patchedStaticDeviceRequest)

        return request<PatchedStaticDeviceRequest, StaticDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminStaticPartialUpdate
     *
     * @param id A unique integer value identifying this Static Device.
     * @param patchedStaticDeviceRequest  (optional)
     * @return RequestConfig
     */
    fun authenticatorsAdminStaticPartialUpdateRequestConfig(id: kotlin.Int, patchedStaticDeviceRequest: PatchedStaticDeviceRequest?) : RequestConfig<PatchedStaticDeviceRequest> {
        val localVariableBody = patchedStaticDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/authenticators/admin/static/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param id A unique integer value identifying this Static Device.
     * @return StaticDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminStaticRetrieve(id: kotlin.Int) : StaticDevice {
        val localVarResponse = authenticatorsAdminStaticRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StaticDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param id A unique integer value identifying this Static Device.
     * @return ApiResponse<StaticDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminStaticRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<StaticDevice?> {
        val localVariableConfig = authenticatorsAdminStaticRetrieveRequestConfig(id = id)

        return request<Unit, StaticDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminStaticRetrieve
     *
     * @param id A unique integer value identifying this Static Device.
     * @return RequestConfig
     */
    fun authenticatorsAdminStaticRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/admin/static/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param id A unique integer value identifying this Static Device.
     * @param staticDeviceRequest 
     * @return StaticDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminStaticUpdate(id: kotlin.Int, staticDeviceRequest: StaticDeviceRequest) : StaticDevice {
        val localVarResponse = authenticatorsAdminStaticUpdateWithHttpInfo(id = id, staticDeviceRequest = staticDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StaticDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for static authenticator devices (for admins)
     * @param id A unique integer value identifying this Static Device.
     * @param staticDeviceRequest 
     * @return ApiResponse<StaticDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminStaticUpdateWithHttpInfo(id: kotlin.Int, staticDeviceRequest: StaticDeviceRequest) : ApiResponse<StaticDevice?> {
        val localVariableConfig = authenticatorsAdminStaticUpdateRequestConfig(id = id, staticDeviceRequest = staticDeviceRequest)

        return request<StaticDeviceRequest, StaticDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminStaticUpdate
     *
     * @param id A unique integer value identifying this Static Device.
     * @param staticDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsAdminStaticUpdateRequestConfig(id: kotlin.Int, staticDeviceRequest: StaticDeviceRequest) : RequestConfig<StaticDeviceRequest> {
        val localVariableBody = staticDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/authenticators/admin/static/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param toTPDeviceRequest 
     * @return TOTPDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminTotpCreate(toTPDeviceRequest: TOTPDeviceRequest) : TOTPDevice {
        val localVarResponse = authenticatorsAdminTotpCreateWithHttpInfo(toTPDeviceRequest = toTPDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TOTPDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param toTPDeviceRequest 
     * @return ApiResponse<TOTPDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminTotpCreateWithHttpInfo(toTPDeviceRequest: TOTPDeviceRequest) : ApiResponse<TOTPDevice?> {
        val localVariableConfig = authenticatorsAdminTotpCreateRequestConfig(toTPDeviceRequest = toTPDeviceRequest)

        return request<TOTPDeviceRequest, TOTPDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminTotpCreate
     *
     * @param toTPDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsAdminTotpCreateRequestConfig(toTPDeviceRequest: TOTPDeviceRequest) : RequestConfig<TOTPDeviceRequest> {
        val localVariableBody = toTPDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/authenticators/admin/totp/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param id A unique integer value identifying this TOTP Device.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminTotpDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = authenticatorsAdminTotpDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param id A unique integer value identifying this TOTP Device.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminTotpDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = authenticatorsAdminTotpDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminTotpDestroy
     *
     * @param id A unique integer value identifying this TOTP Device.
     * @return RequestConfig
     */
    fun authenticatorsAdminTotpDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/authenticators/admin/totp/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedTOTPDeviceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminTotpList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedTOTPDeviceList {
        val localVarResponse = authenticatorsAdminTotpListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedTOTPDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedTOTPDeviceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminTotpListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedTOTPDeviceList?> {
        val localVariableConfig = authenticatorsAdminTotpListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedTOTPDeviceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminTotpList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun authenticatorsAdminTotpListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/admin/totp/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param id A unique integer value identifying this TOTP Device.
     * @param patchedTOTPDeviceRequest  (optional)
     * @return TOTPDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminTotpPartialUpdate(id: kotlin.Int, patchedTOTPDeviceRequest: PatchedTOTPDeviceRequest? = null) : TOTPDevice {
        val localVarResponse = authenticatorsAdminTotpPartialUpdateWithHttpInfo(id = id, patchedTOTPDeviceRequest = patchedTOTPDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TOTPDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param id A unique integer value identifying this TOTP Device.
     * @param patchedTOTPDeviceRequest  (optional)
     * @return ApiResponse<TOTPDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminTotpPartialUpdateWithHttpInfo(id: kotlin.Int, patchedTOTPDeviceRequest: PatchedTOTPDeviceRequest?) : ApiResponse<TOTPDevice?> {
        val localVariableConfig = authenticatorsAdminTotpPartialUpdateRequestConfig(id = id, patchedTOTPDeviceRequest = patchedTOTPDeviceRequest)

        return request<PatchedTOTPDeviceRequest, TOTPDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminTotpPartialUpdate
     *
     * @param id A unique integer value identifying this TOTP Device.
     * @param patchedTOTPDeviceRequest  (optional)
     * @return RequestConfig
     */
    fun authenticatorsAdminTotpPartialUpdateRequestConfig(id: kotlin.Int, patchedTOTPDeviceRequest: PatchedTOTPDeviceRequest?) : RequestConfig<PatchedTOTPDeviceRequest> {
        val localVariableBody = patchedTOTPDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/authenticators/admin/totp/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param id A unique integer value identifying this TOTP Device.
     * @return TOTPDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminTotpRetrieve(id: kotlin.Int) : TOTPDevice {
        val localVarResponse = authenticatorsAdminTotpRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TOTPDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param id A unique integer value identifying this TOTP Device.
     * @return ApiResponse<TOTPDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminTotpRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<TOTPDevice?> {
        val localVariableConfig = authenticatorsAdminTotpRetrieveRequestConfig(id = id)

        return request<Unit, TOTPDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminTotpRetrieve
     *
     * @param id A unique integer value identifying this TOTP Device.
     * @return RequestConfig
     */
    fun authenticatorsAdminTotpRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/admin/totp/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param id A unique integer value identifying this TOTP Device.
     * @param toTPDeviceRequest 
     * @return TOTPDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminTotpUpdate(id: kotlin.Int, toTPDeviceRequest: TOTPDeviceRequest) : TOTPDevice {
        val localVarResponse = authenticatorsAdminTotpUpdateWithHttpInfo(id = id, toTPDeviceRequest = toTPDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TOTPDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for totp authenticator devices (for admins)
     * @param id A unique integer value identifying this TOTP Device.
     * @param toTPDeviceRequest 
     * @return ApiResponse<TOTPDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminTotpUpdateWithHttpInfo(id: kotlin.Int, toTPDeviceRequest: TOTPDeviceRequest) : ApiResponse<TOTPDevice?> {
        val localVariableConfig = authenticatorsAdminTotpUpdateRequestConfig(id = id, toTPDeviceRequest = toTPDeviceRequest)

        return request<TOTPDeviceRequest, TOTPDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminTotpUpdate
     *
     * @param id A unique integer value identifying this TOTP Device.
     * @param toTPDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsAdminTotpUpdateRequestConfig(id: kotlin.Int, toTPDeviceRequest: TOTPDeviceRequest) : RequestConfig<TOTPDeviceRequest> {
        val localVariableBody = toTPDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/authenticators/admin/totp/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param webAuthnDeviceRequest 
     * @return WebAuthnDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminWebauthnCreate(webAuthnDeviceRequest: WebAuthnDeviceRequest) : WebAuthnDevice {
        val localVarResponse = authenticatorsAdminWebauthnCreateWithHttpInfo(webAuthnDeviceRequest = webAuthnDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WebAuthnDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param webAuthnDeviceRequest 
     * @return ApiResponse<WebAuthnDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminWebauthnCreateWithHttpInfo(webAuthnDeviceRequest: WebAuthnDeviceRequest) : ApiResponse<WebAuthnDevice?> {
        val localVariableConfig = authenticatorsAdminWebauthnCreateRequestConfig(webAuthnDeviceRequest = webAuthnDeviceRequest)

        return request<WebAuthnDeviceRequest, WebAuthnDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminWebauthnCreate
     *
     * @param webAuthnDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsAdminWebauthnCreateRequestConfig(webAuthnDeviceRequest: WebAuthnDeviceRequest) : RequestConfig<WebAuthnDeviceRequest> {
        val localVariableBody = webAuthnDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/authenticators/admin/webauthn/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminWebauthnDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = authenticatorsAdminWebauthnDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminWebauthnDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = authenticatorsAdminWebauthnDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminWebauthnDestroy
     *
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return RequestConfig
     */
    fun authenticatorsAdminWebauthnDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/authenticators/admin/webauthn/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedWebAuthnDeviceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminWebauthnList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedWebAuthnDeviceList {
        val localVarResponse = authenticatorsAdminWebauthnListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedWebAuthnDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedWebAuthnDeviceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminWebauthnListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedWebAuthnDeviceList?> {
        val localVariableConfig = authenticatorsAdminWebauthnListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedWebAuthnDeviceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminWebauthnList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun authenticatorsAdminWebauthnListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/admin/webauthn/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param patchedWebAuthnDeviceRequest  (optional)
     * @return WebAuthnDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminWebauthnPartialUpdate(id: kotlin.Int, patchedWebAuthnDeviceRequest: PatchedWebAuthnDeviceRequest? = null) : WebAuthnDevice {
        val localVarResponse = authenticatorsAdminWebauthnPartialUpdateWithHttpInfo(id = id, patchedWebAuthnDeviceRequest = patchedWebAuthnDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WebAuthnDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param patchedWebAuthnDeviceRequest  (optional)
     * @return ApiResponse<WebAuthnDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminWebauthnPartialUpdateWithHttpInfo(id: kotlin.Int, patchedWebAuthnDeviceRequest: PatchedWebAuthnDeviceRequest?) : ApiResponse<WebAuthnDevice?> {
        val localVariableConfig = authenticatorsAdminWebauthnPartialUpdateRequestConfig(id = id, patchedWebAuthnDeviceRequest = patchedWebAuthnDeviceRequest)

        return request<PatchedWebAuthnDeviceRequest, WebAuthnDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminWebauthnPartialUpdate
     *
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param patchedWebAuthnDeviceRequest  (optional)
     * @return RequestConfig
     */
    fun authenticatorsAdminWebauthnPartialUpdateRequestConfig(id: kotlin.Int, patchedWebAuthnDeviceRequest: PatchedWebAuthnDeviceRequest?) : RequestConfig<PatchedWebAuthnDeviceRequest> {
        val localVariableBody = patchedWebAuthnDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/authenticators/admin/webauthn/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return WebAuthnDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminWebauthnRetrieve(id: kotlin.Int) : WebAuthnDevice {
        val localVarResponse = authenticatorsAdminWebauthnRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WebAuthnDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return ApiResponse<WebAuthnDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminWebauthnRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<WebAuthnDevice?> {
        val localVariableConfig = authenticatorsAdminWebauthnRetrieveRequestConfig(id = id)

        return request<Unit, WebAuthnDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminWebauthnRetrieve
     *
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return RequestConfig
     */
    fun authenticatorsAdminWebauthnRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/admin/webauthn/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param webAuthnDeviceRequest 
     * @return WebAuthnDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAdminWebauthnUpdate(id: kotlin.Int, webAuthnDeviceRequest: WebAuthnDeviceRequest) : WebAuthnDevice {
        val localVarResponse = authenticatorsAdminWebauthnUpdateWithHttpInfo(id = id, webAuthnDeviceRequest = webAuthnDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WebAuthnDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices (for admins)
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param webAuthnDeviceRequest 
     * @return ApiResponse<WebAuthnDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAdminWebauthnUpdateWithHttpInfo(id: kotlin.Int, webAuthnDeviceRequest: WebAuthnDeviceRequest) : ApiResponse<WebAuthnDevice?> {
        val localVariableConfig = authenticatorsAdminWebauthnUpdateRequestConfig(id = id, webAuthnDeviceRequest = webAuthnDeviceRequest)

        return request<WebAuthnDeviceRequest, WebAuthnDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAdminWebauthnUpdate
     *
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param webAuthnDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsAdminWebauthnUpdateRequestConfig(id: kotlin.Int, webAuthnDeviceRequest: WebAuthnDeviceRequest) : RequestConfig<WebAuthnDeviceRequest> {
        val localVariableBody = webAuthnDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/authenticators/admin/webauthn/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all devices for current user
     * @return kotlin.collections.List<Device>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsAllList() : kotlin.collections.List<Device> {
        val localVarResponse = authenticatorsAllListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Device>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all devices for current user
     * @return ApiResponse<kotlin.collections.List<Device>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsAllListWithHttpInfo() : ApiResponse<kotlin.collections.List<Device>?> {
        val localVariableConfig = authenticatorsAllListRequestConfig()

        return request<Unit, kotlin.collections.List<Device>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsAllList
     *
     * @return RequestConfig
     */
    fun authenticatorsAllListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/all/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for Duo authenticator devices
     * @param id A unique integer value identifying this Duo Device.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsDuoDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = authenticatorsDuoDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for Duo authenticator devices
     * @param id A unique integer value identifying this Duo Device.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsDuoDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = authenticatorsDuoDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsDuoDestroy
     *
     * @param id A unique integer value identifying this Duo Device.
     * @return RequestConfig
     */
    fun authenticatorsDuoDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/authenticators/duo/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for Duo authenticator devices
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedDuoDeviceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsDuoList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedDuoDeviceList {
        val localVarResponse = authenticatorsDuoListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDuoDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for Duo authenticator devices
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedDuoDeviceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsDuoListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedDuoDeviceList?> {
        val localVariableConfig = authenticatorsDuoListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedDuoDeviceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsDuoList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun authenticatorsDuoListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/duo/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for Duo authenticator devices
     * @param id A unique integer value identifying this Duo Device.
     * @param patchedDuoDeviceRequest  (optional)
     * @return DuoDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsDuoPartialUpdate(id: kotlin.Int, patchedDuoDeviceRequest: PatchedDuoDeviceRequest? = null) : DuoDevice {
        val localVarResponse = authenticatorsDuoPartialUpdateWithHttpInfo(id = id, patchedDuoDeviceRequest = patchedDuoDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DuoDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for Duo authenticator devices
     * @param id A unique integer value identifying this Duo Device.
     * @param patchedDuoDeviceRequest  (optional)
     * @return ApiResponse<DuoDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsDuoPartialUpdateWithHttpInfo(id: kotlin.Int, patchedDuoDeviceRequest: PatchedDuoDeviceRequest?) : ApiResponse<DuoDevice?> {
        val localVariableConfig = authenticatorsDuoPartialUpdateRequestConfig(id = id, patchedDuoDeviceRequest = patchedDuoDeviceRequest)

        return request<PatchedDuoDeviceRequest, DuoDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsDuoPartialUpdate
     *
     * @param id A unique integer value identifying this Duo Device.
     * @param patchedDuoDeviceRequest  (optional)
     * @return RequestConfig
     */
    fun authenticatorsDuoPartialUpdateRequestConfig(id: kotlin.Int, patchedDuoDeviceRequest: PatchedDuoDeviceRequest?) : RequestConfig<PatchedDuoDeviceRequest> {
        val localVariableBody = patchedDuoDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/authenticators/duo/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for Duo authenticator devices
     * @param id A unique integer value identifying this Duo Device.
     * @return DuoDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsDuoRetrieve(id: kotlin.Int) : DuoDevice {
        val localVarResponse = authenticatorsDuoRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DuoDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for Duo authenticator devices
     * @param id A unique integer value identifying this Duo Device.
     * @return ApiResponse<DuoDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsDuoRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<DuoDevice?> {
        val localVariableConfig = authenticatorsDuoRetrieveRequestConfig(id = id)

        return request<Unit, DuoDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsDuoRetrieve
     *
     * @param id A unique integer value identifying this Duo Device.
     * @return RequestConfig
     */
    fun authenticatorsDuoRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/duo/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for Duo authenticator devices
     * @param id A unique integer value identifying this Duo Device.
     * @param duoDeviceRequest 
     * @return DuoDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsDuoUpdate(id: kotlin.Int, duoDeviceRequest: DuoDeviceRequest) : DuoDevice {
        val localVarResponse = authenticatorsDuoUpdateWithHttpInfo(id = id, duoDeviceRequest = duoDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DuoDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for Duo authenticator devices
     * @param id A unique integer value identifying this Duo Device.
     * @param duoDeviceRequest 
     * @return ApiResponse<DuoDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsDuoUpdateWithHttpInfo(id: kotlin.Int, duoDeviceRequest: DuoDeviceRequest) : ApiResponse<DuoDevice?> {
        val localVariableConfig = authenticatorsDuoUpdateRequestConfig(id = id, duoDeviceRequest = duoDeviceRequest)

        return request<DuoDeviceRequest, DuoDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsDuoUpdate
     *
     * @param id A unique integer value identifying this Duo Device.
     * @param duoDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsDuoUpdateRequestConfig(id: kotlin.Int, duoDeviceRequest: DuoDeviceRequest) : RequestConfig<DuoDeviceRequest> {
        val localVariableBody = duoDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/authenticators/duo/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this Duo Device.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsDuoUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = authenticatorsDuoUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this Duo Device.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsDuoUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = authenticatorsDuoUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsDuoUsedByList
     *
     * @param id A unique integer value identifying this Duo Device.
     * @return RequestConfig
     */
    fun authenticatorsDuoUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/duo/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for sms authenticator devices
     * @param id A unique integer value identifying this SMS Device.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsSmsDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = authenticatorsSmsDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for sms authenticator devices
     * @param id A unique integer value identifying this SMS Device.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsSmsDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = authenticatorsSmsDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsSmsDestroy
     *
     * @param id A unique integer value identifying this SMS Device.
     * @return RequestConfig
     */
    fun authenticatorsSmsDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/authenticators/sms/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for sms authenticator devices
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedSMSDeviceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsSmsList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedSMSDeviceList {
        val localVarResponse = authenticatorsSmsListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedSMSDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for sms authenticator devices
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedSMSDeviceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsSmsListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedSMSDeviceList?> {
        val localVariableConfig = authenticatorsSmsListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedSMSDeviceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsSmsList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun authenticatorsSmsListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/sms/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for sms authenticator devices
     * @param id A unique integer value identifying this SMS Device.
     * @param patchedSMSDeviceRequest  (optional)
     * @return SMSDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsSmsPartialUpdate(id: kotlin.Int, patchedSMSDeviceRequest: PatchedSMSDeviceRequest? = null) : SMSDevice {
        val localVarResponse = authenticatorsSmsPartialUpdateWithHttpInfo(id = id, patchedSMSDeviceRequest = patchedSMSDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SMSDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for sms authenticator devices
     * @param id A unique integer value identifying this SMS Device.
     * @param patchedSMSDeviceRequest  (optional)
     * @return ApiResponse<SMSDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsSmsPartialUpdateWithHttpInfo(id: kotlin.Int, patchedSMSDeviceRequest: PatchedSMSDeviceRequest?) : ApiResponse<SMSDevice?> {
        val localVariableConfig = authenticatorsSmsPartialUpdateRequestConfig(id = id, patchedSMSDeviceRequest = patchedSMSDeviceRequest)

        return request<PatchedSMSDeviceRequest, SMSDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsSmsPartialUpdate
     *
     * @param id A unique integer value identifying this SMS Device.
     * @param patchedSMSDeviceRequest  (optional)
     * @return RequestConfig
     */
    fun authenticatorsSmsPartialUpdateRequestConfig(id: kotlin.Int, patchedSMSDeviceRequest: PatchedSMSDeviceRequest?) : RequestConfig<PatchedSMSDeviceRequest> {
        val localVariableBody = patchedSMSDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/authenticators/sms/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for sms authenticator devices
     * @param id A unique integer value identifying this SMS Device.
     * @return SMSDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsSmsRetrieve(id: kotlin.Int) : SMSDevice {
        val localVarResponse = authenticatorsSmsRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SMSDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for sms authenticator devices
     * @param id A unique integer value identifying this SMS Device.
     * @return ApiResponse<SMSDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsSmsRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<SMSDevice?> {
        val localVariableConfig = authenticatorsSmsRetrieveRequestConfig(id = id)

        return request<Unit, SMSDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsSmsRetrieve
     *
     * @param id A unique integer value identifying this SMS Device.
     * @return RequestConfig
     */
    fun authenticatorsSmsRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/sms/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for sms authenticator devices
     * @param id A unique integer value identifying this SMS Device.
     * @param smSDeviceRequest 
     * @return SMSDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsSmsUpdate(id: kotlin.Int, smSDeviceRequest: SMSDeviceRequest) : SMSDevice {
        val localVarResponse = authenticatorsSmsUpdateWithHttpInfo(id = id, smSDeviceRequest = smSDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SMSDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for sms authenticator devices
     * @param id A unique integer value identifying this SMS Device.
     * @param smSDeviceRequest 
     * @return ApiResponse<SMSDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsSmsUpdateWithHttpInfo(id: kotlin.Int, smSDeviceRequest: SMSDeviceRequest) : ApiResponse<SMSDevice?> {
        val localVariableConfig = authenticatorsSmsUpdateRequestConfig(id = id, smSDeviceRequest = smSDeviceRequest)

        return request<SMSDeviceRequest, SMSDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsSmsUpdate
     *
     * @param id A unique integer value identifying this SMS Device.
     * @param smSDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsSmsUpdateRequestConfig(id: kotlin.Int, smSDeviceRequest: SMSDeviceRequest) : RequestConfig<SMSDeviceRequest> {
        val localVariableBody = smSDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/authenticators/sms/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this SMS Device.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsSmsUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = authenticatorsSmsUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this SMS Device.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsSmsUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = authenticatorsSmsUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsSmsUsedByList
     *
     * @param id A unique integer value identifying this SMS Device.
     * @return RequestConfig
     */
    fun authenticatorsSmsUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/sms/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for static authenticator devices
     * @param id A unique integer value identifying this Static Device.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsStaticDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = authenticatorsStaticDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for static authenticator devices
     * @param id A unique integer value identifying this Static Device.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsStaticDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = authenticatorsStaticDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsStaticDestroy
     *
     * @param id A unique integer value identifying this Static Device.
     * @return RequestConfig
     */
    fun authenticatorsStaticDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/authenticators/static/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for static authenticator devices
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedStaticDeviceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsStaticList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedStaticDeviceList {
        val localVarResponse = authenticatorsStaticListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedStaticDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for static authenticator devices
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedStaticDeviceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsStaticListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedStaticDeviceList?> {
        val localVariableConfig = authenticatorsStaticListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedStaticDeviceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsStaticList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun authenticatorsStaticListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/static/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for static authenticator devices
     * @param id A unique integer value identifying this Static Device.
     * @param patchedStaticDeviceRequest  (optional)
     * @return StaticDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsStaticPartialUpdate(id: kotlin.Int, patchedStaticDeviceRequest: PatchedStaticDeviceRequest? = null) : StaticDevice {
        val localVarResponse = authenticatorsStaticPartialUpdateWithHttpInfo(id = id, patchedStaticDeviceRequest = patchedStaticDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StaticDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for static authenticator devices
     * @param id A unique integer value identifying this Static Device.
     * @param patchedStaticDeviceRequest  (optional)
     * @return ApiResponse<StaticDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsStaticPartialUpdateWithHttpInfo(id: kotlin.Int, patchedStaticDeviceRequest: PatchedStaticDeviceRequest?) : ApiResponse<StaticDevice?> {
        val localVariableConfig = authenticatorsStaticPartialUpdateRequestConfig(id = id, patchedStaticDeviceRequest = patchedStaticDeviceRequest)

        return request<PatchedStaticDeviceRequest, StaticDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsStaticPartialUpdate
     *
     * @param id A unique integer value identifying this Static Device.
     * @param patchedStaticDeviceRequest  (optional)
     * @return RequestConfig
     */
    fun authenticatorsStaticPartialUpdateRequestConfig(id: kotlin.Int, patchedStaticDeviceRequest: PatchedStaticDeviceRequest?) : RequestConfig<PatchedStaticDeviceRequest> {
        val localVariableBody = patchedStaticDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/authenticators/static/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for static authenticator devices
     * @param id A unique integer value identifying this Static Device.
     * @return StaticDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsStaticRetrieve(id: kotlin.Int) : StaticDevice {
        val localVarResponse = authenticatorsStaticRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StaticDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for static authenticator devices
     * @param id A unique integer value identifying this Static Device.
     * @return ApiResponse<StaticDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsStaticRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<StaticDevice?> {
        val localVariableConfig = authenticatorsStaticRetrieveRequestConfig(id = id)

        return request<Unit, StaticDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsStaticRetrieve
     *
     * @param id A unique integer value identifying this Static Device.
     * @return RequestConfig
     */
    fun authenticatorsStaticRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/static/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for static authenticator devices
     * @param id A unique integer value identifying this Static Device.
     * @param staticDeviceRequest 
     * @return StaticDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsStaticUpdate(id: kotlin.Int, staticDeviceRequest: StaticDeviceRequest) : StaticDevice {
        val localVarResponse = authenticatorsStaticUpdateWithHttpInfo(id = id, staticDeviceRequest = staticDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StaticDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for static authenticator devices
     * @param id A unique integer value identifying this Static Device.
     * @param staticDeviceRequest 
     * @return ApiResponse<StaticDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsStaticUpdateWithHttpInfo(id: kotlin.Int, staticDeviceRequest: StaticDeviceRequest) : ApiResponse<StaticDevice?> {
        val localVariableConfig = authenticatorsStaticUpdateRequestConfig(id = id, staticDeviceRequest = staticDeviceRequest)

        return request<StaticDeviceRequest, StaticDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsStaticUpdate
     *
     * @param id A unique integer value identifying this Static Device.
     * @param staticDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsStaticUpdateRequestConfig(id: kotlin.Int, staticDeviceRequest: StaticDeviceRequest) : RequestConfig<StaticDeviceRequest> {
        val localVariableBody = staticDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/authenticators/static/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this Static Device.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsStaticUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = authenticatorsStaticUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this Static Device.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsStaticUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = authenticatorsStaticUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsStaticUsedByList
     *
     * @param id A unique integer value identifying this Static Device.
     * @return RequestConfig
     */
    fun authenticatorsStaticUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/static/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for totp authenticator devices
     * @param id A unique integer value identifying this TOTP Device.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsTotpDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = authenticatorsTotpDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for totp authenticator devices
     * @param id A unique integer value identifying this TOTP Device.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsTotpDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = authenticatorsTotpDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsTotpDestroy
     *
     * @param id A unique integer value identifying this TOTP Device.
     * @return RequestConfig
     */
    fun authenticatorsTotpDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/authenticators/totp/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for totp authenticator devices
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedTOTPDeviceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsTotpList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedTOTPDeviceList {
        val localVarResponse = authenticatorsTotpListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedTOTPDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for totp authenticator devices
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedTOTPDeviceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsTotpListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedTOTPDeviceList?> {
        val localVariableConfig = authenticatorsTotpListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedTOTPDeviceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsTotpList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun authenticatorsTotpListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/totp/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for totp authenticator devices
     * @param id A unique integer value identifying this TOTP Device.
     * @param patchedTOTPDeviceRequest  (optional)
     * @return TOTPDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsTotpPartialUpdate(id: kotlin.Int, patchedTOTPDeviceRequest: PatchedTOTPDeviceRequest? = null) : TOTPDevice {
        val localVarResponse = authenticatorsTotpPartialUpdateWithHttpInfo(id = id, patchedTOTPDeviceRequest = patchedTOTPDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TOTPDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for totp authenticator devices
     * @param id A unique integer value identifying this TOTP Device.
     * @param patchedTOTPDeviceRequest  (optional)
     * @return ApiResponse<TOTPDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsTotpPartialUpdateWithHttpInfo(id: kotlin.Int, patchedTOTPDeviceRequest: PatchedTOTPDeviceRequest?) : ApiResponse<TOTPDevice?> {
        val localVariableConfig = authenticatorsTotpPartialUpdateRequestConfig(id = id, patchedTOTPDeviceRequest = patchedTOTPDeviceRequest)

        return request<PatchedTOTPDeviceRequest, TOTPDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsTotpPartialUpdate
     *
     * @param id A unique integer value identifying this TOTP Device.
     * @param patchedTOTPDeviceRequest  (optional)
     * @return RequestConfig
     */
    fun authenticatorsTotpPartialUpdateRequestConfig(id: kotlin.Int, patchedTOTPDeviceRequest: PatchedTOTPDeviceRequest?) : RequestConfig<PatchedTOTPDeviceRequest> {
        val localVariableBody = patchedTOTPDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/authenticators/totp/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for totp authenticator devices
     * @param id A unique integer value identifying this TOTP Device.
     * @return TOTPDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsTotpRetrieve(id: kotlin.Int) : TOTPDevice {
        val localVarResponse = authenticatorsTotpRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TOTPDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for totp authenticator devices
     * @param id A unique integer value identifying this TOTP Device.
     * @return ApiResponse<TOTPDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsTotpRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<TOTPDevice?> {
        val localVariableConfig = authenticatorsTotpRetrieveRequestConfig(id = id)

        return request<Unit, TOTPDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsTotpRetrieve
     *
     * @param id A unique integer value identifying this TOTP Device.
     * @return RequestConfig
     */
    fun authenticatorsTotpRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/totp/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for totp authenticator devices
     * @param id A unique integer value identifying this TOTP Device.
     * @param toTPDeviceRequest 
     * @return TOTPDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsTotpUpdate(id: kotlin.Int, toTPDeviceRequest: TOTPDeviceRequest) : TOTPDevice {
        val localVarResponse = authenticatorsTotpUpdateWithHttpInfo(id = id, toTPDeviceRequest = toTPDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TOTPDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for totp authenticator devices
     * @param id A unique integer value identifying this TOTP Device.
     * @param toTPDeviceRequest 
     * @return ApiResponse<TOTPDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsTotpUpdateWithHttpInfo(id: kotlin.Int, toTPDeviceRequest: TOTPDeviceRequest) : ApiResponse<TOTPDevice?> {
        val localVariableConfig = authenticatorsTotpUpdateRequestConfig(id = id, toTPDeviceRequest = toTPDeviceRequest)

        return request<TOTPDeviceRequest, TOTPDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsTotpUpdate
     *
     * @param id A unique integer value identifying this TOTP Device.
     * @param toTPDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsTotpUpdateRequestConfig(id: kotlin.Int, toTPDeviceRequest: TOTPDeviceRequest) : RequestConfig<TOTPDeviceRequest> {
        val localVariableBody = toTPDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/authenticators/totp/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this TOTP Device.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsTotpUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = authenticatorsTotpUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this TOTP Device.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsTotpUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = authenticatorsTotpUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsTotpUsedByList
     *
     * @param id A unique integer value identifying this TOTP Device.
     * @return RequestConfig
     */
    fun authenticatorsTotpUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/totp/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsWebauthnDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = authenticatorsWebauthnDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsWebauthnDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = authenticatorsWebauthnDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsWebauthnDestroy
     *
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return RequestConfig
     */
    fun authenticatorsWebauthnDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/authenticators/webauthn/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedWebAuthnDeviceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsWebauthnList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedWebAuthnDeviceList {
        val localVarResponse = authenticatorsWebauthnListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedWebAuthnDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedWebAuthnDeviceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsWebauthnListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedWebAuthnDeviceList?> {
        val localVariableConfig = authenticatorsWebauthnListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedWebAuthnDeviceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsWebauthnList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun authenticatorsWebauthnListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/webauthn/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param patchedWebAuthnDeviceRequest  (optional)
     * @return WebAuthnDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsWebauthnPartialUpdate(id: kotlin.Int, patchedWebAuthnDeviceRequest: PatchedWebAuthnDeviceRequest? = null) : WebAuthnDevice {
        val localVarResponse = authenticatorsWebauthnPartialUpdateWithHttpInfo(id = id, patchedWebAuthnDeviceRequest = patchedWebAuthnDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WebAuthnDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param patchedWebAuthnDeviceRequest  (optional)
     * @return ApiResponse<WebAuthnDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsWebauthnPartialUpdateWithHttpInfo(id: kotlin.Int, patchedWebAuthnDeviceRequest: PatchedWebAuthnDeviceRequest?) : ApiResponse<WebAuthnDevice?> {
        val localVariableConfig = authenticatorsWebauthnPartialUpdateRequestConfig(id = id, patchedWebAuthnDeviceRequest = patchedWebAuthnDeviceRequest)

        return request<PatchedWebAuthnDeviceRequest, WebAuthnDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsWebauthnPartialUpdate
     *
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param patchedWebAuthnDeviceRequest  (optional)
     * @return RequestConfig
     */
    fun authenticatorsWebauthnPartialUpdateRequestConfig(id: kotlin.Int, patchedWebAuthnDeviceRequest: PatchedWebAuthnDeviceRequest?) : RequestConfig<PatchedWebAuthnDeviceRequest> {
        val localVariableBody = patchedWebAuthnDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/authenticators/webauthn/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return WebAuthnDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsWebauthnRetrieve(id: kotlin.Int) : WebAuthnDevice {
        val localVarResponse = authenticatorsWebauthnRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WebAuthnDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return ApiResponse<WebAuthnDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsWebauthnRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<WebAuthnDevice?> {
        val localVariableConfig = authenticatorsWebauthnRetrieveRequestConfig(id = id)

        return request<Unit, WebAuthnDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsWebauthnRetrieve
     *
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return RequestConfig
     */
    fun authenticatorsWebauthnRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/webauthn/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param webAuthnDeviceRequest 
     * @return WebAuthnDevice
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsWebauthnUpdate(id: kotlin.Int, webAuthnDeviceRequest: WebAuthnDeviceRequest) : WebAuthnDevice {
        val localVarResponse = authenticatorsWebauthnUpdateWithHttpInfo(id = id, webAuthnDeviceRequest = webAuthnDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WebAuthnDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Viewset for WebAuthn authenticator devices
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param webAuthnDeviceRequest 
     * @return ApiResponse<WebAuthnDevice?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsWebauthnUpdateWithHttpInfo(id: kotlin.Int, webAuthnDeviceRequest: WebAuthnDeviceRequest) : ApiResponse<WebAuthnDevice?> {
        val localVariableConfig = authenticatorsWebauthnUpdateRequestConfig(id = id, webAuthnDeviceRequest = webAuthnDeviceRequest)

        return request<WebAuthnDeviceRequest, WebAuthnDevice>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsWebauthnUpdate
     *
     * @param id A unique integer value identifying this WebAuthn Device.
     * @param webAuthnDeviceRequest 
     * @return RequestConfig
     */
    fun authenticatorsWebauthnUpdateRequestConfig(id: kotlin.Int, webAuthnDeviceRequest: WebAuthnDeviceRequest) : RequestConfig<WebAuthnDeviceRequest> {
        val localVariableBody = webAuthnDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/authenticators/webauthn/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun authenticatorsWebauthnUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = authenticatorsWebauthnUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun authenticatorsWebauthnUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = authenticatorsWebauthnUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation authenticatorsWebauthnUsedByList
     *
     * @param id A unique integer value identifying this WebAuthn Device.
     * @return RequestConfig
     */
    fun authenticatorsWebauthnUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/authenticators/webauthn/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
