/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.LDAPProvider
import io.goauthentik.api.models.LDAPProviderRequest
import io.goauthentik.api.models.OAuth2Provider
import io.goauthentik.api.models.OAuth2ProviderRequest
import io.goauthentik.api.models.OAuth2ProviderSetupURLs
import io.goauthentik.api.models.PaginatedLDAPProviderList
import io.goauthentik.api.models.PaginatedOAuth2ProviderList
import io.goauthentik.api.models.PaginatedProviderList
import io.goauthentik.api.models.PaginatedProxyProviderList
import io.goauthentik.api.models.PaginatedRadiusProviderList
import io.goauthentik.api.models.PaginatedSAMLProviderList
import io.goauthentik.api.models.PaginatedSCIMProviderList
import io.goauthentik.api.models.PatchedLDAPProviderRequest
import io.goauthentik.api.models.PatchedOAuth2ProviderRequest
import io.goauthentik.api.models.PatchedProxyProviderRequest
import io.goauthentik.api.models.PatchedRadiusProviderRequest
import io.goauthentik.api.models.PatchedSAMLProviderRequest
import io.goauthentik.api.models.PatchedSCIMProviderRequest
import io.goauthentik.api.models.PropertyMappingPreview
import io.goauthentik.api.models.Provider
import io.goauthentik.api.models.ProxyProvider
import io.goauthentik.api.models.ProxyProviderRequest
import io.goauthentik.api.models.RadiusProvider
import io.goauthentik.api.models.RadiusProviderRequest
import io.goauthentik.api.models.SAMLMetadata
import io.goauthentik.api.models.SAMLProvider
import io.goauthentik.api.models.SAMLProviderRequest
import io.goauthentik.api.models.SCIMProvider
import io.goauthentik.api.models.SCIMProviderRequest
import io.goauthentik.api.models.SCIMSyncStatus
import io.goauthentik.api.models.TypeCreate
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.ValidationError

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class ProvidersApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * Provider Viewset
     * @param id A unique integer value identifying this provider.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersAllDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = providersAllDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Provider Viewset
     * @param id A unique integer value identifying this provider.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun providersAllDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = providersAllDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersAllDestroy
     *
     * @param id A unique integer value identifying this provider.
     * @return RequestConfig
     */
    fun providersAllDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/providers/all/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Provider Viewset
     * @param applicationIsnull  (optional)
     * @param backchannelOnly  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedProviderList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersAllList(applicationIsnull: kotlin.Boolean? = null, backchannelOnly: kotlin.Boolean? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedProviderList {
        val localVarResponse = providersAllListWithHttpInfo(applicationIsnull = applicationIsnull, backchannelOnly = backchannelOnly, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedProviderList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Provider Viewset
     * @param applicationIsnull  (optional)
     * @param backchannelOnly  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedProviderList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersAllListWithHttpInfo(applicationIsnull: kotlin.Boolean?, backchannelOnly: kotlin.Boolean?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedProviderList?> {
        val localVariableConfig = providersAllListRequestConfig(applicationIsnull = applicationIsnull, backchannelOnly = backchannelOnly, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedProviderList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersAllList
     *
     * @param applicationIsnull  (optional)
     * @param backchannelOnly  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun providersAllListRequestConfig(applicationIsnull: kotlin.Boolean?, backchannelOnly: kotlin.Boolean?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (applicationIsnull != null) {
                    put("application__isnull", listOf(applicationIsnull.toString()))
                }
                if (backchannelOnly != null) {
                    put("backchannel_only", listOf(backchannelOnly.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/all/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Provider Viewset
     * @param id A unique integer value identifying this provider.
     * @return Provider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersAllRetrieve(id: kotlin.Int) : Provider {
        val localVarResponse = providersAllRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Provider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Provider Viewset
     * @param id A unique integer value identifying this provider.
     * @return ApiResponse<Provider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersAllRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<Provider?> {
        val localVariableConfig = providersAllRetrieveRequestConfig(id = id)

        return request<Unit, Provider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersAllRetrieve
     *
     * @param id A unique integer value identifying this provider.
     * @return RequestConfig
     */
    fun providersAllRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/all/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all creatable provider types
     * @return kotlin.collections.List<TypeCreate>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersAllTypesList() : kotlin.collections.List<TypeCreate> {
        val localVarResponse = providersAllTypesListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TypeCreate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all creatable provider types
     * @return ApiResponse<kotlin.collections.List<TypeCreate>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersAllTypesListWithHttpInfo() : ApiResponse<kotlin.collections.List<TypeCreate>?> {
        val localVariableConfig = providersAllTypesListRequestConfig()

        return request<Unit, kotlin.collections.List<TypeCreate>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersAllTypesList
     *
     * @return RequestConfig
     */
    fun providersAllTypesListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/all/types/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this provider.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersAllUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = providersAllUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this provider.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersAllUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = providersAllUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersAllUsedByList
     *
     * @param id A unique integer value identifying this provider.
     * @return RequestConfig
     */
    fun providersAllUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/all/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param ldAPProviderRequest 
     * @return LDAPProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersLdapCreate(ldAPProviderRequest: LDAPProviderRequest) : LDAPProvider {
        val localVarResponse = providersLdapCreateWithHttpInfo(ldAPProviderRequest = ldAPProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param ldAPProviderRequest 
     * @return ApiResponse<LDAPProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersLdapCreateWithHttpInfo(ldAPProviderRequest: LDAPProviderRequest) : ApiResponse<LDAPProvider?> {
        val localVariableConfig = providersLdapCreateRequestConfig(ldAPProviderRequest = ldAPProviderRequest)

        return request<LDAPProviderRequest, LDAPProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersLdapCreate
     *
     * @param ldAPProviderRequest 
     * @return RequestConfig
     */
    fun providersLdapCreateRequestConfig(ldAPProviderRequest: LDAPProviderRequest) : RequestConfig<LDAPProviderRequest> {
        val localVariableBody = ldAPProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/providers/ldap/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param id A unique integer value identifying this LDAP Provider.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersLdapDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = providersLdapDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param id A unique integer value identifying this LDAP Provider.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun providersLdapDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = providersLdapDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersLdapDestroy
     *
     * @param id A unique integer value identifying this LDAP Provider.
     * @return RequestConfig
     */
    fun providersLdapDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/providers/ldap/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param applicationIsnull  (optional)
     * @param authorizationFlowSlugIexact  (optional)
     * @param baseDnIexact  (optional)
     * @param certificateKpUuidIexact  (optional)
     * @param certificateNameIexact  (optional)
     * @param gidStartNumberIexact  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param searchGroupGroupUuidIexact  (optional)
     * @param searchGroupNameIexact  (optional)
     * @param tlsServerNameIexact  (optional)
     * @param uidStartNumberIexact  (optional)
     * @return PaginatedLDAPProviderList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersLdapList(applicationIsnull: kotlin.Boolean? = null, authorizationFlowSlugIexact: kotlin.String? = null, baseDnIexact: kotlin.String? = null, certificateKpUuidIexact: java.util.UUID? = null, certificateNameIexact: kotlin.String? = null, gidStartNumberIexact: kotlin.Int? = null, nameIexact: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, searchGroupGroupUuidIexact: java.util.UUID? = null, searchGroupNameIexact: kotlin.String? = null, tlsServerNameIexact: kotlin.String? = null, uidStartNumberIexact: kotlin.Int? = null) : PaginatedLDAPProviderList {
        val localVarResponse = providersLdapListWithHttpInfo(applicationIsnull = applicationIsnull, authorizationFlowSlugIexact = authorizationFlowSlugIexact, baseDnIexact = baseDnIexact, certificateKpUuidIexact = certificateKpUuidIexact, certificateNameIexact = certificateNameIexact, gidStartNumberIexact = gidStartNumberIexact, nameIexact = nameIexact, ordering = ordering, page = page, pageSize = pageSize, search = search, searchGroupGroupUuidIexact = searchGroupGroupUuidIexact, searchGroupNameIexact = searchGroupNameIexact, tlsServerNameIexact = tlsServerNameIexact, uidStartNumberIexact = uidStartNumberIexact)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedLDAPProviderList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param applicationIsnull  (optional)
     * @param authorizationFlowSlugIexact  (optional)
     * @param baseDnIexact  (optional)
     * @param certificateKpUuidIexact  (optional)
     * @param certificateNameIexact  (optional)
     * @param gidStartNumberIexact  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param searchGroupGroupUuidIexact  (optional)
     * @param searchGroupNameIexact  (optional)
     * @param tlsServerNameIexact  (optional)
     * @param uidStartNumberIexact  (optional)
     * @return ApiResponse<PaginatedLDAPProviderList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersLdapListWithHttpInfo(applicationIsnull: kotlin.Boolean?, authorizationFlowSlugIexact: kotlin.String?, baseDnIexact: kotlin.String?, certificateKpUuidIexact: java.util.UUID?, certificateNameIexact: kotlin.String?, gidStartNumberIexact: kotlin.Int?, nameIexact: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, searchGroupGroupUuidIexact: java.util.UUID?, searchGroupNameIexact: kotlin.String?, tlsServerNameIexact: kotlin.String?, uidStartNumberIexact: kotlin.Int?) : ApiResponse<PaginatedLDAPProviderList?> {
        val localVariableConfig = providersLdapListRequestConfig(applicationIsnull = applicationIsnull, authorizationFlowSlugIexact = authorizationFlowSlugIexact, baseDnIexact = baseDnIexact, certificateKpUuidIexact = certificateKpUuidIexact, certificateNameIexact = certificateNameIexact, gidStartNumberIexact = gidStartNumberIexact, nameIexact = nameIexact, ordering = ordering, page = page, pageSize = pageSize, search = search, searchGroupGroupUuidIexact = searchGroupGroupUuidIexact, searchGroupNameIexact = searchGroupNameIexact, tlsServerNameIexact = tlsServerNameIexact, uidStartNumberIexact = uidStartNumberIexact)

        return request<Unit, PaginatedLDAPProviderList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersLdapList
     *
     * @param applicationIsnull  (optional)
     * @param authorizationFlowSlugIexact  (optional)
     * @param baseDnIexact  (optional)
     * @param certificateKpUuidIexact  (optional)
     * @param certificateNameIexact  (optional)
     * @param gidStartNumberIexact  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param searchGroupGroupUuidIexact  (optional)
     * @param searchGroupNameIexact  (optional)
     * @param tlsServerNameIexact  (optional)
     * @param uidStartNumberIexact  (optional)
     * @return RequestConfig
     */
    fun providersLdapListRequestConfig(applicationIsnull: kotlin.Boolean?, authorizationFlowSlugIexact: kotlin.String?, baseDnIexact: kotlin.String?, certificateKpUuidIexact: java.util.UUID?, certificateNameIexact: kotlin.String?, gidStartNumberIexact: kotlin.Int?, nameIexact: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, searchGroupGroupUuidIexact: java.util.UUID?, searchGroupNameIexact: kotlin.String?, tlsServerNameIexact: kotlin.String?, uidStartNumberIexact: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (applicationIsnull != null) {
                    put("application__isnull", listOf(applicationIsnull.toString()))
                }
                if (authorizationFlowSlugIexact != null) {
                    put("authorization_flow__slug__iexact", listOf(authorizationFlowSlugIexact.toString()))
                }
                if (baseDnIexact != null) {
                    put("base_dn__iexact", listOf(baseDnIexact.toString()))
                }
                if (certificateKpUuidIexact != null) {
                    put("certificate__kp_uuid__iexact", listOf(certificateKpUuidIexact.toString()))
                }
                if (certificateNameIexact != null) {
                    put("certificate__name__iexact", listOf(certificateNameIexact.toString()))
                }
                if (gidStartNumberIexact != null) {
                    put("gid_start_number__iexact", listOf(gidStartNumberIexact.toString()))
                }
                if (nameIexact != null) {
                    put("name__iexact", listOf(nameIexact.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (searchGroupGroupUuidIexact != null) {
                    put("search_group__group_uuid__iexact", listOf(searchGroupGroupUuidIexact.toString()))
                }
                if (searchGroupNameIexact != null) {
                    put("search_group__name__iexact", listOf(searchGroupNameIexact.toString()))
                }
                if (tlsServerNameIexact != null) {
                    put("tls_server_name__iexact", listOf(tlsServerNameIexact.toString()))
                }
                if (uidStartNumberIexact != null) {
                    put("uid_start_number__iexact", listOf(uidStartNumberIexact.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/ldap/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param id A unique integer value identifying this LDAP Provider.
     * @param patchedLDAPProviderRequest  (optional)
     * @return LDAPProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersLdapPartialUpdate(id: kotlin.Int, patchedLDAPProviderRequest: PatchedLDAPProviderRequest? = null) : LDAPProvider {
        val localVarResponse = providersLdapPartialUpdateWithHttpInfo(id = id, patchedLDAPProviderRequest = patchedLDAPProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param id A unique integer value identifying this LDAP Provider.
     * @param patchedLDAPProviderRequest  (optional)
     * @return ApiResponse<LDAPProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersLdapPartialUpdateWithHttpInfo(id: kotlin.Int, patchedLDAPProviderRequest: PatchedLDAPProviderRequest?) : ApiResponse<LDAPProvider?> {
        val localVariableConfig = providersLdapPartialUpdateRequestConfig(id = id, patchedLDAPProviderRequest = patchedLDAPProviderRequest)

        return request<PatchedLDAPProviderRequest, LDAPProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersLdapPartialUpdate
     *
     * @param id A unique integer value identifying this LDAP Provider.
     * @param patchedLDAPProviderRequest  (optional)
     * @return RequestConfig
     */
    fun providersLdapPartialUpdateRequestConfig(id: kotlin.Int, patchedLDAPProviderRequest: PatchedLDAPProviderRequest?) : RequestConfig<PatchedLDAPProviderRequest> {
        val localVariableBody = patchedLDAPProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/providers/ldap/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param id A unique integer value identifying this LDAP Provider.
     * @return LDAPProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersLdapRetrieve(id: kotlin.Int) : LDAPProvider {
        val localVarResponse = providersLdapRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param id A unique integer value identifying this LDAP Provider.
     * @return ApiResponse<LDAPProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersLdapRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<LDAPProvider?> {
        val localVariableConfig = providersLdapRetrieveRequestConfig(id = id)

        return request<Unit, LDAPProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersLdapRetrieve
     *
     * @param id A unique integer value identifying this LDAP Provider.
     * @return RequestConfig
     */
    fun providersLdapRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/ldap/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param id A unique integer value identifying this LDAP Provider.
     * @param ldAPProviderRequest 
     * @return LDAPProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersLdapUpdate(id: kotlin.Int, ldAPProviderRequest: LDAPProviderRequest) : LDAPProvider {
        val localVarResponse = providersLdapUpdateWithHttpInfo(id = id, ldAPProviderRequest = ldAPProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAPProvider Viewset
     * @param id A unique integer value identifying this LDAP Provider.
     * @param ldAPProviderRequest 
     * @return ApiResponse<LDAPProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersLdapUpdateWithHttpInfo(id: kotlin.Int, ldAPProviderRequest: LDAPProviderRequest) : ApiResponse<LDAPProvider?> {
        val localVariableConfig = providersLdapUpdateRequestConfig(id = id, ldAPProviderRequest = ldAPProviderRequest)

        return request<LDAPProviderRequest, LDAPProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersLdapUpdate
     *
     * @param id A unique integer value identifying this LDAP Provider.
     * @param ldAPProviderRequest 
     * @return RequestConfig
     */
    fun providersLdapUpdateRequestConfig(id: kotlin.Int, ldAPProviderRequest: LDAPProviderRequest) : RequestConfig<LDAPProviderRequest> {
        val localVariableBody = ldAPProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/providers/ldap/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this LDAP Provider.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersLdapUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = providersLdapUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this LDAP Provider.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersLdapUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = providersLdapUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersLdapUsedByList
     *
     * @param id A unique integer value identifying this LDAP Provider.
     * @return RequestConfig
     */
    fun providersLdapUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/ldap/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * OAuth2Provider Viewset
     * @param oauth2ProviderRequest 
     * @return OAuth2Provider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersOauth2Create(oauth2ProviderRequest: OAuth2ProviderRequest) : OAuth2Provider {
        val localVarResponse = providersOauth2CreateWithHttpInfo(oauth2ProviderRequest = oauth2ProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OAuth2Provider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * OAuth2Provider Viewset
     * @param oauth2ProviderRequest 
     * @return ApiResponse<OAuth2Provider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersOauth2CreateWithHttpInfo(oauth2ProviderRequest: OAuth2ProviderRequest) : ApiResponse<OAuth2Provider?> {
        val localVariableConfig = providersOauth2CreateRequestConfig(oauth2ProviderRequest = oauth2ProviderRequest)

        return request<OAuth2ProviderRequest, OAuth2Provider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersOauth2Create
     *
     * @param oauth2ProviderRequest 
     * @return RequestConfig
     */
    fun providersOauth2CreateRequestConfig(oauth2ProviderRequest: OAuth2ProviderRequest) : RequestConfig<OAuth2ProviderRequest> {
        val localVariableBody = oauth2ProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/providers/oauth2/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * OAuth2Provider Viewset
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersOauth2Destroy(id: kotlin.Int) : Unit {
        val localVarResponse = providersOauth2DestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * OAuth2Provider Viewset
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun providersOauth2DestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = providersOauth2DestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersOauth2Destroy
     *
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return RequestConfig
     */
    fun providersOauth2DestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/providers/oauth2/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter clientType
     */
     enum class ClientTypeProvidersOauth2List(val value: kotlin.String) {
         @Json(name = "confidential") confidential("confidential"),
         @Json(name = "public") `public`("public"),
     }

    /**
     * enum for parameter issuerMode
     */
     enum class IssuerModeProvidersOauth2List(val value: kotlin.String) {
         @Json(name = "global") global("global"),
         @Json(name = "per_provider") perProvider("per_provider"),
     }

    /**
     * enum for parameter subMode
     */
     enum class SubModeProvidersOauth2List(val value: kotlin.String) {
         @Json(name = "hashed_user_id") hashedUserId("hashed_user_id"),
         @Json(name = "user_email") userEmail("user_email"),
         @Json(name = "user_id") userId("user_id"),
         @Json(name = "user_upn") userUpn("user_upn"),
         @Json(name = "user_username") userUsername("user_username"),
         @Json(name = "user_uuid") userUuid("user_uuid"),
     }

    /**
     * 
     * OAuth2Provider Viewset
     * @param accessCodeValidity  (optional)
     * @param accessTokenValidity  (optional)
     * @param application  (optional)
     * @param authorizationFlow  (optional)
     * @param clientId  (optional)
     * @param clientType Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable  * &#x60;confidential&#x60; - Confidential * &#x60;public&#x60; - Public (optional)
     * @param includeClaimsInIdToken  (optional)
     * @param issuerMode Configure how the issuer field of the ID Token should be filled.  * &#x60;global&#x60; - Same identifier is used for all providers * &#x60;per_provider&#x60; - Each provider has a different issuer, based on the application slug. (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param propertyMappings  (optional)
     * @param redirectUris  (optional)
     * @param refreshTokenValidity  (optional)
     * @param search A search term. (optional)
     * @param signingKey  (optional)
     * @param subMode Configure what data should be used as unique User Identifier. For most cases, the default should be fine.  * &#x60;hashed_user_id&#x60; - Based on the Hashed User ID * &#x60;user_id&#x60; - Based on user ID * &#x60;user_uuid&#x60; - Based on user UUID * &#x60;user_username&#x60; - Based on the username * &#x60;user_email&#x60; - Based on the User&#39;s Email. This is recommended over the UPN method. * &#x60;user_upn&#x60; - Based on the User&#39;s UPN, only works if user has a &#39;upn&#39; attribute set. Use this method only if you have different UPN and Mail domains. (optional)
     * @return PaginatedOAuth2ProviderList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersOauth2List(accessCodeValidity: kotlin.String? = null, accessTokenValidity: kotlin.String? = null, application: java.util.UUID? = null, authorizationFlow: java.util.UUID? = null, clientId: kotlin.String? = null, clientType: ClientTypeProvidersOauth2List? = null, includeClaimsInIdToken: kotlin.Boolean? = null, issuerMode: IssuerModeProvidersOauth2List? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, propertyMappings: kotlin.collections.List<java.util.UUID>? = null, redirectUris: kotlin.String? = null, refreshTokenValidity: kotlin.String? = null, search: kotlin.String? = null, signingKey: java.util.UUID? = null, subMode: SubModeProvidersOauth2List? = null) : PaginatedOAuth2ProviderList {
        val localVarResponse = providersOauth2ListWithHttpInfo(accessCodeValidity = accessCodeValidity, accessTokenValidity = accessTokenValidity, application = application, authorizationFlow = authorizationFlow, clientId = clientId, clientType = clientType, includeClaimsInIdToken = includeClaimsInIdToken, issuerMode = issuerMode, name = name, ordering = ordering, page = page, pageSize = pageSize, propertyMappings = propertyMappings, redirectUris = redirectUris, refreshTokenValidity = refreshTokenValidity, search = search, signingKey = signingKey, subMode = subMode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedOAuth2ProviderList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * OAuth2Provider Viewset
     * @param accessCodeValidity  (optional)
     * @param accessTokenValidity  (optional)
     * @param application  (optional)
     * @param authorizationFlow  (optional)
     * @param clientId  (optional)
     * @param clientType Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable  * &#x60;confidential&#x60; - Confidential * &#x60;public&#x60; - Public (optional)
     * @param includeClaimsInIdToken  (optional)
     * @param issuerMode Configure how the issuer field of the ID Token should be filled.  * &#x60;global&#x60; - Same identifier is used for all providers * &#x60;per_provider&#x60; - Each provider has a different issuer, based on the application slug. (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param propertyMappings  (optional)
     * @param redirectUris  (optional)
     * @param refreshTokenValidity  (optional)
     * @param search A search term. (optional)
     * @param signingKey  (optional)
     * @param subMode Configure what data should be used as unique User Identifier. For most cases, the default should be fine.  * &#x60;hashed_user_id&#x60; - Based on the Hashed User ID * &#x60;user_id&#x60; - Based on user ID * &#x60;user_uuid&#x60; - Based on user UUID * &#x60;user_username&#x60; - Based on the username * &#x60;user_email&#x60; - Based on the User&#39;s Email. This is recommended over the UPN method. * &#x60;user_upn&#x60; - Based on the User&#39;s UPN, only works if user has a &#39;upn&#39; attribute set. Use this method only if you have different UPN and Mail domains. (optional)
     * @return ApiResponse<PaginatedOAuth2ProviderList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersOauth2ListWithHttpInfo(accessCodeValidity: kotlin.String?, accessTokenValidity: kotlin.String?, application: java.util.UUID?, authorizationFlow: java.util.UUID?, clientId: kotlin.String?, clientType: ClientTypeProvidersOauth2List?, includeClaimsInIdToken: kotlin.Boolean?, issuerMode: IssuerModeProvidersOauth2List?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, propertyMappings: kotlin.collections.List<java.util.UUID>?, redirectUris: kotlin.String?, refreshTokenValidity: kotlin.String?, search: kotlin.String?, signingKey: java.util.UUID?, subMode: SubModeProvidersOauth2List?) : ApiResponse<PaginatedOAuth2ProviderList?> {
        val localVariableConfig = providersOauth2ListRequestConfig(accessCodeValidity = accessCodeValidity, accessTokenValidity = accessTokenValidity, application = application, authorizationFlow = authorizationFlow, clientId = clientId, clientType = clientType, includeClaimsInIdToken = includeClaimsInIdToken, issuerMode = issuerMode, name = name, ordering = ordering, page = page, pageSize = pageSize, propertyMappings = propertyMappings, redirectUris = redirectUris, refreshTokenValidity = refreshTokenValidity, search = search, signingKey = signingKey, subMode = subMode)

        return request<Unit, PaginatedOAuth2ProviderList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersOauth2List
     *
     * @param accessCodeValidity  (optional)
     * @param accessTokenValidity  (optional)
     * @param application  (optional)
     * @param authorizationFlow  (optional)
     * @param clientId  (optional)
     * @param clientType Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable  * &#x60;confidential&#x60; - Confidential * &#x60;public&#x60; - Public (optional)
     * @param includeClaimsInIdToken  (optional)
     * @param issuerMode Configure how the issuer field of the ID Token should be filled.  * &#x60;global&#x60; - Same identifier is used for all providers * &#x60;per_provider&#x60; - Each provider has a different issuer, based on the application slug. (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param propertyMappings  (optional)
     * @param redirectUris  (optional)
     * @param refreshTokenValidity  (optional)
     * @param search A search term. (optional)
     * @param signingKey  (optional)
     * @param subMode Configure what data should be used as unique User Identifier. For most cases, the default should be fine.  * &#x60;hashed_user_id&#x60; - Based on the Hashed User ID * &#x60;user_id&#x60; - Based on user ID * &#x60;user_uuid&#x60; - Based on user UUID * &#x60;user_username&#x60; - Based on the username * &#x60;user_email&#x60; - Based on the User&#39;s Email. This is recommended over the UPN method. * &#x60;user_upn&#x60; - Based on the User&#39;s UPN, only works if user has a &#39;upn&#39; attribute set. Use this method only if you have different UPN and Mail domains. (optional)
     * @return RequestConfig
     */
    fun providersOauth2ListRequestConfig(accessCodeValidity: kotlin.String?, accessTokenValidity: kotlin.String?, application: java.util.UUID?, authorizationFlow: java.util.UUID?, clientId: kotlin.String?, clientType: ClientTypeProvidersOauth2List?, includeClaimsInIdToken: kotlin.Boolean?, issuerMode: IssuerModeProvidersOauth2List?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, propertyMappings: kotlin.collections.List<java.util.UUID>?, redirectUris: kotlin.String?, refreshTokenValidity: kotlin.String?, search: kotlin.String?, signingKey: java.util.UUID?, subMode: SubModeProvidersOauth2List?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accessCodeValidity != null) {
                    put("access_code_validity", listOf(accessCodeValidity.toString()))
                }
                if (accessTokenValidity != null) {
                    put("access_token_validity", listOf(accessTokenValidity.toString()))
                }
                if (application != null) {
                    put("application", listOf(application.toString()))
                }
                if (authorizationFlow != null) {
                    put("authorization_flow", listOf(authorizationFlow.toString()))
                }
                if (clientId != null) {
                    put("client_id", listOf(clientId.toString()))
                }
                if (clientType != null) {
                    put("client_type", listOf(clientType.value))
                }
                if (includeClaimsInIdToken != null) {
                    put("include_claims_in_id_token", listOf(includeClaimsInIdToken.toString()))
                }
                if (issuerMode != null) {
                    put("issuer_mode", listOf(issuerMode.value))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (propertyMappings != null) {
                    put("property_mappings", toMultiValue(propertyMappings.toList(), "multi"))
                }
                if (redirectUris != null) {
                    put("redirect_uris", listOf(redirectUris.toString()))
                }
                if (refreshTokenValidity != null) {
                    put("refresh_token_validity", listOf(refreshTokenValidity.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (signingKey != null) {
                    put("signing_key", listOf(signingKey.toString()))
                }
                if (subMode != null) {
                    put("sub_mode", listOf(subMode.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/oauth2/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * OAuth2Provider Viewset
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @param patchedOAuth2ProviderRequest  (optional)
     * @return OAuth2Provider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersOauth2PartialUpdate(id: kotlin.Int, patchedOAuth2ProviderRequest: PatchedOAuth2ProviderRequest? = null) : OAuth2Provider {
        val localVarResponse = providersOauth2PartialUpdateWithHttpInfo(id = id, patchedOAuth2ProviderRequest = patchedOAuth2ProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OAuth2Provider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * OAuth2Provider Viewset
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @param patchedOAuth2ProviderRequest  (optional)
     * @return ApiResponse<OAuth2Provider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersOauth2PartialUpdateWithHttpInfo(id: kotlin.Int, patchedOAuth2ProviderRequest: PatchedOAuth2ProviderRequest?) : ApiResponse<OAuth2Provider?> {
        val localVariableConfig = providersOauth2PartialUpdateRequestConfig(id = id, patchedOAuth2ProviderRequest = patchedOAuth2ProviderRequest)

        return request<PatchedOAuth2ProviderRequest, OAuth2Provider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersOauth2PartialUpdate
     *
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @param patchedOAuth2ProviderRequest  (optional)
     * @return RequestConfig
     */
    fun providersOauth2PartialUpdateRequestConfig(id: kotlin.Int, patchedOAuth2ProviderRequest: PatchedOAuth2ProviderRequest?) : RequestConfig<PatchedOAuth2ProviderRequest> {
        val localVariableBody = patchedOAuth2ProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/providers/oauth2/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Preview user data for provider
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return PropertyMappingPreview
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersOauth2PreviewUserRetrieve(id: kotlin.Int) : PropertyMappingPreview {
        val localVarResponse = providersOauth2PreviewUserRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PropertyMappingPreview
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Preview user data for provider
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return ApiResponse<PropertyMappingPreview?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersOauth2PreviewUserRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<PropertyMappingPreview?> {
        val localVariableConfig = providersOauth2PreviewUserRetrieveRequestConfig(id = id)

        return request<Unit, PropertyMappingPreview>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersOauth2PreviewUserRetrieve
     *
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return RequestConfig
     */
    fun providersOauth2PreviewUserRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/oauth2/{id}/preview_user/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * OAuth2Provider Viewset
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return OAuth2Provider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersOauth2Retrieve(id: kotlin.Int) : OAuth2Provider {
        val localVarResponse = providersOauth2RetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OAuth2Provider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * OAuth2Provider Viewset
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return ApiResponse<OAuth2Provider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersOauth2RetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<OAuth2Provider?> {
        val localVariableConfig = providersOauth2RetrieveRequestConfig(id = id)

        return request<Unit, OAuth2Provider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersOauth2Retrieve
     *
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return RequestConfig
     */
    fun providersOauth2RetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/oauth2/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get Providers setup URLs
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return OAuth2ProviderSetupURLs
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersOauth2SetupUrlsRetrieve(id: kotlin.Int) : OAuth2ProviderSetupURLs {
        val localVarResponse = providersOauth2SetupUrlsRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OAuth2ProviderSetupURLs
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get Providers setup URLs
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return ApiResponse<OAuth2ProviderSetupURLs?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersOauth2SetupUrlsRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<OAuth2ProviderSetupURLs?> {
        val localVariableConfig = providersOauth2SetupUrlsRetrieveRequestConfig(id = id)

        return request<Unit, OAuth2ProviderSetupURLs>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersOauth2SetupUrlsRetrieve
     *
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return RequestConfig
     */
    fun providersOauth2SetupUrlsRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/oauth2/{id}/setup_urls/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * OAuth2Provider Viewset
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @param oauth2ProviderRequest 
     * @return OAuth2Provider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersOauth2Update(id: kotlin.Int, oauth2ProviderRequest: OAuth2ProviderRequest) : OAuth2Provider {
        val localVarResponse = providersOauth2UpdateWithHttpInfo(id = id, oauth2ProviderRequest = oauth2ProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OAuth2Provider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * OAuth2Provider Viewset
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @param oauth2ProviderRequest 
     * @return ApiResponse<OAuth2Provider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersOauth2UpdateWithHttpInfo(id: kotlin.Int, oauth2ProviderRequest: OAuth2ProviderRequest) : ApiResponse<OAuth2Provider?> {
        val localVariableConfig = providersOauth2UpdateRequestConfig(id = id, oauth2ProviderRequest = oauth2ProviderRequest)

        return request<OAuth2ProviderRequest, OAuth2Provider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersOauth2Update
     *
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @param oauth2ProviderRequest 
     * @return RequestConfig
     */
    fun providersOauth2UpdateRequestConfig(id: kotlin.Int, oauth2ProviderRequest: OAuth2ProviderRequest) : RequestConfig<OAuth2ProviderRequest> {
        val localVariableBody = oauth2ProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/providers/oauth2/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersOauth2UsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = providersOauth2UsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersOauth2UsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = providersOauth2UsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersOauth2UsedByList
     *
     * @param id A unique integer value identifying this OAuth2/OpenID Provider.
     * @return RequestConfig
     */
    fun providersOauth2UsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/oauth2/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param proxyProviderRequest 
     * @return ProxyProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersProxyCreate(proxyProviderRequest: ProxyProviderRequest) : ProxyProvider {
        val localVarResponse = providersProxyCreateWithHttpInfo(proxyProviderRequest = proxyProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProxyProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param proxyProviderRequest 
     * @return ApiResponse<ProxyProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersProxyCreateWithHttpInfo(proxyProviderRequest: ProxyProviderRequest) : ApiResponse<ProxyProvider?> {
        val localVariableConfig = providersProxyCreateRequestConfig(proxyProviderRequest = proxyProviderRequest)

        return request<ProxyProviderRequest, ProxyProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersProxyCreate
     *
     * @param proxyProviderRequest 
     * @return RequestConfig
     */
    fun providersProxyCreateRequestConfig(proxyProviderRequest: ProxyProviderRequest) : RequestConfig<ProxyProviderRequest> {
        val localVariableBody = proxyProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/providers/proxy/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param id A unique integer value identifying this Proxy Provider.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersProxyDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = providersProxyDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param id A unique integer value identifying this Proxy Provider.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun providersProxyDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = providersProxyDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersProxyDestroy
     *
     * @param id A unique integer value identifying this Proxy Provider.
     * @return RequestConfig
     */
    fun providersProxyDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/providers/proxy/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param applicationIsnull  (optional)
     * @param authorizationFlowSlugIexact  (optional)
     * @param basicAuthEnabledIexact  (optional)
     * @param basicAuthPasswordAttributeIexact  (optional)
     * @param basicAuthUserAttributeIexact  (optional)
     * @param certificateKpUuidIexact  (optional)
     * @param certificateNameIexact  (optional)
     * @param cookieDomainIexact  (optional)
     * @param externalHostIexact  (optional)
     * @param internalHostIexact  (optional)
     * @param internalHostSslValidationIexact  (optional)
     * @param modeIexact  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param propertyMappingsIexact  (optional)
     * @param redirectUrisIexact  (optional)
     * @param search A search term. (optional)
     * @param skipPathRegexIexact  (optional)
     * @return PaginatedProxyProviderList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersProxyList(applicationIsnull: kotlin.Boolean? = null, authorizationFlowSlugIexact: kotlin.String? = null, basicAuthEnabledIexact: kotlin.Boolean? = null, basicAuthPasswordAttributeIexact: kotlin.String? = null, basicAuthUserAttributeIexact: kotlin.String? = null, certificateKpUuidIexact: java.util.UUID? = null, certificateNameIexact: kotlin.String? = null, cookieDomainIexact: kotlin.String? = null, externalHostIexact: kotlin.String? = null, internalHostIexact: kotlin.String? = null, internalHostSslValidationIexact: kotlin.Boolean? = null, modeIexact: kotlin.String? = null, nameIexact: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, propertyMappingsIexact: kotlin.collections.List<java.util.UUID>? = null, redirectUrisIexact: kotlin.String? = null, search: kotlin.String? = null, skipPathRegexIexact: kotlin.String? = null) : PaginatedProxyProviderList {
        val localVarResponse = providersProxyListWithHttpInfo(applicationIsnull = applicationIsnull, authorizationFlowSlugIexact = authorizationFlowSlugIexact, basicAuthEnabledIexact = basicAuthEnabledIexact, basicAuthPasswordAttributeIexact = basicAuthPasswordAttributeIexact, basicAuthUserAttributeIexact = basicAuthUserAttributeIexact, certificateKpUuidIexact = certificateKpUuidIexact, certificateNameIexact = certificateNameIexact, cookieDomainIexact = cookieDomainIexact, externalHostIexact = externalHostIexact, internalHostIexact = internalHostIexact, internalHostSslValidationIexact = internalHostSslValidationIexact, modeIexact = modeIexact, nameIexact = nameIexact, ordering = ordering, page = page, pageSize = pageSize, propertyMappingsIexact = propertyMappingsIexact, redirectUrisIexact = redirectUrisIexact, search = search, skipPathRegexIexact = skipPathRegexIexact)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedProxyProviderList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param applicationIsnull  (optional)
     * @param authorizationFlowSlugIexact  (optional)
     * @param basicAuthEnabledIexact  (optional)
     * @param basicAuthPasswordAttributeIexact  (optional)
     * @param basicAuthUserAttributeIexact  (optional)
     * @param certificateKpUuidIexact  (optional)
     * @param certificateNameIexact  (optional)
     * @param cookieDomainIexact  (optional)
     * @param externalHostIexact  (optional)
     * @param internalHostIexact  (optional)
     * @param internalHostSslValidationIexact  (optional)
     * @param modeIexact  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param propertyMappingsIexact  (optional)
     * @param redirectUrisIexact  (optional)
     * @param search A search term. (optional)
     * @param skipPathRegexIexact  (optional)
     * @return ApiResponse<PaginatedProxyProviderList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersProxyListWithHttpInfo(applicationIsnull: kotlin.Boolean?, authorizationFlowSlugIexact: kotlin.String?, basicAuthEnabledIexact: kotlin.Boolean?, basicAuthPasswordAttributeIexact: kotlin.String?, basicAuthUserAttributeIexact: kotlin.String?, certificateKpUuidIexact: java.util.UUID?, certificateNameIexact: kotlin.String?, cookieDomainIexact: kotlin.String?, externalHostIexact: kotlin.String?, internalHostIexact: kotlin.String?, internalHostSslValidationIexact: kotlin.Boolean?, modeIexact: kotlin.String?, nameIexact: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, propertyMappingsIexact: kotlin.collections.List<java.util.UUID>?, redirectUrisIexact: kotlin.String?, search: kotlin.String?, skipPathRegexIexact: kotlin.String?) : ApiResponse<PaginatedProxyProviderList?> {
        val localVariableConfig = providersProxyListRequestConfig(applicationIsnull = applicationIsnull, authorizationFlowSlugIexact = authorizationFlowSlugIexact, basicAuthEnabledIexact = basicAuthEnabledIexact, basicAuthPasswordAttributeIexact = basicAuthPasswordAttributeIexact, basicAuthUserAttributeIexact = basicAuthUserAttributeIexact, certificateKpUuidIexact = certificateKpUuidIexact, certificateNameIexact = certificateNameIexact, cookieDomainIexact = cookieDomainIexact, externalHostIexact = externalHostIexact, internalHostIexact = internalHostIexact, internalHostSslValidationIexact = internalHostSslValidationIexact, modeIexact = modeIexact, nameIexact = nameIexact, ordering = ordering, page = page, pageSize = pageSize, propertyMappingsIexact = propertyMappingsIexact, redirectUrisIexact = redirectUrisIexact, search = search, skipPathRegexIexact = skipPathRegexIexact)

        return request<Unit, PaginatedProxyProviderList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersProxyList
     *
     * @param applicationIsnull  (optional)
     * @param authorizationFlowSlugIexact  (optional)
     * @param basicAuthEnabledIexact  (optional)
     * @param basicAuthPasswordAttributeIexact  (optional)
     * @param basicAuthUserAttributeIexact  (optional)
     * @param certificateKpUuidIexact  (optional)
     * @param certificateNameIexact  (optional)
     * @param cookieDomainIexact  (optional)
     * @param externalHostIexact  (optional)
     * @param internalHostIexact  (optional)
     * @param internalHostSslValidationIexact  (optional)
     * @param modeIexact  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param propertyMappingsIexact  (optional)
     * @param redirectUrisIexact  (optional)
     * @param search A search term. (optional)
     * @param skipPathRegexIexact  (optional)
     * @return RequestConfig
     */
    fun providersProxyListRequestConfig(applicationIsnull: kotlin.Boolean?, authorizationFlowSlugIexact: kotlin.String?, basicAuthEnabledIexact: kotlin.Boolean?, basicAuthPasswordAttributeIexact: kotlin.String?, basicAuthUserAttributeIexact: kotlin.String?, certificateKpUuidIexact: java.util.UUID?, certificateNameIexact: kotlin.String?, cookieDomainIexact: kotlin.String?, externalHostIexact: kotlin.String?, internalHostIexact: kotlin.String?, internalHostSslValidationIexact: kotlin.Boolean?, modeIexact: kotlin.String?, nameIexact: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, propertyMappingsIexact: kotlin.collections.List<java.util.UUID>?, redirectUrisIexact: kotlin.String?, search: kotlin.String?, skipPathRegexIexact: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (applicationIsnull != null) {
                    put("application__isnull", listOf(applicationIsnull.toString()))
                }
                if (authorizationFlowSlugIexact != null) {
                    put("authorization_flow__slug__iexact", listOf(authorizationFlowSlugIexact.toString()))
                }
                if (basicAuthEnabledIexact != null) {
                    put("basic_auth_enabled__iexact", listOf(basicAuthEnabledIexact.toString()))
                }
                if (basicAuthPasswordAttributeIexact != null) {
                    put("basic_auth_password_attribute__iexact", listOf(basicAuthPasswordAttributeIexact.toString()))
                }
                if (basicAuthUserAttributeIexact != null) {
                    put("basic_auth_user_attribute__iexact", listOf(basicAuthUserAttributeIexact.toString()))
                }
                if (certificateKpUuidIexact != null) {
                    put("certificate__kp_uuid__iexact", listOf(certificateKpUuidIexact.toString()))
                }
                if (certificateNameIexact != null) {
                    put("certificate__name__iexact", listOf(certificateNameIexact.toString()))
                }
                if (cookieDomainIexact != null) {
                    put("cookie_domain__iexact", listOf(cookieDomainIexact.toString()))
                }
                if (externalHostIexact != null) {
                    put("external_host__iexact", listOf(externalHostIexact.toString()))
                }
                if (internalHostIexact != null) {
                    put("internal_host__iexact", listOf(internalHostIexact.toString()))
                }
                if (internalHostSslValidationIexact != null) {
                    put("internal_host_ssl_validation__iexact", listOf(internalHostSslValidationIexact.toString()))
                }
                if (modeIexact != null) {
                    put("mode__iexact", listOf(modeIexact.toString()))
                }
                if (nameIexact != null) {
                    put("name__iexact", listOf(nameIexact.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (propertyMappingsIexact != null) {
                    put("property_mappings__iexact", toMultiValue(propertyMappingsIexact.toList(), "multi"))
                }
                if (redirectUrisIexact != null) {
                    put("redirect_uris__iexact", listOf(redirectUrisIexact.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (skipPathRegexIexact != null) {
                    put("skip_path_regex__iexact", listOf(skipPathRegexIexact.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/proxy/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param id A unique integer value identifying this Proxy Provider.
     * @param patchedProxyProviderRequest  (optional)
     * @return ProxyProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersProxyPartialUpdate(id: kotlin.Int, patchedProxyProviderRequest: PatchedProxyProviderRequest? = null) : ProxyProvider {
        val localVarResponse = providersProxyPartialUpdateWithHttpInfo(id = id, patchedProxyProviderRequest = patchedProxyProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProxyProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param id A unique integer value identifying this Proxy Provider.
     * @param patchedProxyProviderRequest  (optional)
     * @return ApiResponse<ProxyProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersProxyPartialUpdateWithHttpInfo(id: kotlin.Int, patchedProxyProviderRequest: PatchedProxyProviderRequest?) : ApiResponse<ProxyProvider?> {
        val localVariableConfig = providersProxyPartialUpdateRequestConfig(id = id, patchedProxyProviderRequest = patchedProxyProviderRequest)

        return request<PatchedProxyProviderRequest, ProxyProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersProxyPartialUpdate
     *
     * @param id A unique integer value identifying this Proxy Provider.
     * @param patchedProxyProviderRequest  (optional)
     * @return RequestConfig
     */
    fun providersProxyPartialUpdateRequestConfig(id: kotlin.Int, patchedProxyProviderRequest: PatchedProxyProviderRequest?) : RequestConfig<PatchedProxyProviderRequest> {
        val localVariableBody = patchedProxyProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/providers/proxy/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param id A unique integer value identifying this Proxy Provider.
     * @return ProxyProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersProxyRetrieve(id: kotlin.Int) : ProxyProvider {
        val localVarResponse = providersProxyRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProxyProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param id A unique integer value identifying this Proxy Provider.
     * @return ApiResponse<ProxyProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersProxyRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<ProxyProvider?> {
        val localVariableConfig = providersProxyRetrieveRequestConfig(id = id)

        return request<Unit, ProxyProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersProxyRetrieve
     *
     * @param id A unique integer value identifying this Proxy Provider.
     * @return RequestConfig
     */
    fun providersProxyRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/proxy/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param id A unique integer value identifying this Proxy Provider.
     * @param proxyProviderRequest 
     * @return ProxyProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersProxyUpdate(id: kotlin.Int, proxyProviderRequest: ProxyProviderRequest) : ProxyProvider {
        val localVarResponse = providersProxyUpdateWithHttpInfo(id = id, proxyProviderRequest = proxyProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProxyProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * ProxyProvider Viewset
     * @param id A unique integer value identifying this Proxy Provider.
     * @param proxyProviderRequest 
     * @return ApiResponse<ProxyProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersProxyUpdateWithHttpInfo(id: kotlin.Int, proxyProviderRequest: ProxyProviderRequest) : ApiResponse<ProxyProvider?> {
        val localVariableConfig = providersProxyUpdateRequestConfig(id = id, proxyProviderRequest = proxyProviderRequest)

        return request<ProxyProviderRequest, ProxyProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersProxyUpdate
     *
     * @param id A unique integer value identifying this Proxy Provider.
     * @param proxyProviderRequest 
     * @return RequestConfig
     */
    fun providersProxyUpdateRequestConfig(id: kotlin.Int, proxyProviderRequest: ProxyProviderRequest) : RequestConfig<ProxyProviderRequest> {
        val localVariableBody = proxyProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/providers/proxy/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this Proxy Provider.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersProxyUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = providersProxyUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this Proxy Provider.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersProxyUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = providersProxyUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersProxyUsedByList
     *
     * @param id A unique integer value identifying this Proxy Provider.
     * @return RequestConfig
     */
    fun providersProxyUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/proxy/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param radiusProviderRequest 
     * @return RadiusProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersRadiusCreate(radiusProviderRequest: RadiusProviderRequest) : RadiusProvider {
        val localVarResponse = providersRadiusCreateWithHttpInfo(radiusProviderRequest = radiusProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RadiusProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param radiusProviderRequest 
     * @return ApiResponse<RadiusProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersRadiusCreateWithHttpInfo(radiusProviderRequest: RadiusProviderRequest) : ApiResponse<RadiusProvider?> {
        val localVariableConfig = providersRadiusCreateRequestConfig(radiusProviderRequest = radiusProviderRequest)

        return request<RadiusProviderRequest, RadiusProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersRadiusCreate
     *
     * @param radiusProviderRequest 
     * @return RequestConfig
     */
    fun providersRadiusCreateRequestConfig(radiusProviderRequest: RadiusProviderRequest) : RequestConfig<RadiusProviderRequest> {
        val localVariableBody = radiusProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/providers/radius/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param id A unique integer value identifying this Radius Provider.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersRadiusDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = providersRadiusDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param id A unique integer value identifying this Radius Provider.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun providersRadiusDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = providersRadiusDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersRadiusDestroy
     *
     * @param id A unique integer value identifying this Radius Provider.
     * @return RequestConfig
     */
    fun providersRadiusDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/providers/radius/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param applicationIsnull  (optional)
     * @param authorizationFlowSlugIexact  (optional)
     * @param clientNetworksIexact  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return PaginatedRadiusProviderList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersRadiusList(applicationIsnull: kotlin.Boolean? = null, authorizationFlowSlugIexact: kotlin.String? = null, clientNetworksIexact: kotlin.String? = null, nameIexact: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null) : PaginatedRadiusProviderList {
        val localVarResponse = providersRadiusListWithHttpInfo(applicationIsnull = applicationIsnull, authorizationFlowSlugIexact = authorizationFlowSlugIexact, clientNetworksIexact = clientNetworksIexact, nameIexact = nameIexact, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedRadiusProviderList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param applicationIsnull  (optional)
     * @param authorizationFlowSlugIexact  (optional)
     * @param clientNetworksIexact  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return ApiResponse<PaginatedRadiusProviderList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersRadiusListWithHttpInfo(applicationIsnull: kotlin.Boolean?, authorizationFlowSlugIexact: kotlin.String?, clientNetworksIexact: kotlin.String?, nameIexact: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : ApiResponse<PaginatedRadiusProviderList?> {
        val localVariableConfig = providersRadiusListRequestConfig(applicationIsnull = applicationIsnull, authorizationFlowSlugIexact = authorizationFlowSlugIexact, clientNetworksIexact = clientNetworksIexact, nameIexact = nameIexact, ordering = ordering, page = page, pageSize = pageSize, search = search)

        return request<Unit, PaginatedRadiusProviderList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersRadiusList
     *
     * @param applicationIsnull  (optional)
     * @param authorizationFlowSlugIexact  (optional)
     * @param clientNetworksIexact  (optional)
     * @param nameIexact  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @return RequestConfig
     */
    fun providersRadiusListRequestConfig(applicationIsnull: kotlin.Boolean?, authorizationFlowSlugIexact: kotlin.String?, clientNetworksIexact: kotlin.String?, nameIexact: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (applicationIsnull != null) {
                    put("application__isnull", listOf(applicationIsnull.toString()))
                }
                if (authorizationFlowSlugIexact != null) {
                    put("authorization_flow__slug__iexact", listOf(authorizationFlowSlugIexact.toString()))
                }
                if (clientNetworksIexact != null) {
                    put("client_networks__iexact", listOf(clientNetworksIexact.toString()))
                }
                if (nameIexact != null) {
                    put("name__iexact", listOf(nameIexact.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/radius/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param id A unique integer value identifying this Radius Provider.
     * @param patchedRadiusProviderRequest  (optional)
     * @return RadiusProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersRadiusPartialUpdate(id: kotlin.Int, patchedRadiusProviderRequest: PatchedRadiusProviderRequest? = null) : RadiusProvider {
        val localVarResponse = providersRadiusPartialUpdateWithHttpInfo(id = id, patchedRadiusProviderRequest = patchedRadiusProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RadiusProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param id A unique integer value identifying this Radius Provider.
     * @param patchedRadiusProviderRequest  (optional)
     * @return ApiResponse<RadiusProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersRadiusPartialUpdateWithHttpInfo(id: kotlin.Int, patchedRadiusProviderRequest: PatchedRadiusProviderRequest?) : ApiResponse<RadiusProvider?> {
        val localVariableConfig = providersRadiusPartialUpdateRequestConfig(id = id, patchedRadiusProviderRequest = patchedRadiusProviderRequest)

        return request<PatchedRadiusProviderRequest, RadiusProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersRadiusPartialUpdate
     *
     * @param id A unique integer value identifying this Radius Provider.
     * @param patchedRadiusProviderRequest  (optional)
     * @return RequestConfig
     */
    fun providersRadiusPartialUpdateRequestConfig(id: kotlin.Int, patchedRadiusProviderRequest: PatchedRadiusProviderRequest?) : RequestConfig<PatchedRadiusProviderRequest> {
        val localVariableBody = patchedRadiusProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/providers/radius/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param id A unique integer value identifying this Radius Provider.
     * @return RadiusProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersRadiusRetrieve(id: kotlin.Int) : RadiusProvider {
        val localVarResponse = providersRadiusRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RadiusProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param id A unique integer value identifying this Radius Provider.
     * @return ApiResponse<RadiusProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersRadiusRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<RadiusProvider?> {
        val localVariableConfig = providersRadiusRetrieveRequestConfig(id = id)

        return request<Unit, RadiusProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersRadiusRetrieve
     *
     * @param id A unique integer value identifying this Radius Provider.
     * @return RequestConfig
     */
    fun providersRadiusRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/radius/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param id A unique integer value identifying this Radius Provider.
     * @param radiusProviderRequest 
     * @return RadiusProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersRadiusUpdate(id: kotlin.Int, radiusProviderRequest: RadiusProviderRequest) : RadiusProvider {
        val localVarResponse = providersRadiusUpdateWithHttpInfo(id = id, radiusProviderRequest = radiusProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RadiusProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * RadiusProvider Viewset
     * @param id A unique integer value identifying this Radius Provider.
     * @param radiusProviderRequest 
     * @return ApiResponse<RadiusProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersRadiusUpdateWithHttpInfo(id: kotlin.Int, radiusProviderRequest: RadiusProviderRequest) : ApiResponse<RadiusProvider?> {
        val localVariableConfig = providersRadiusUpdateRequestConfig(id = id, radiusProviderRequest = radiusProviderRequest)

        return request<RadiusProviderRequest, RadiusProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersRadiusUpdate
     *
     * @param id A unique integer value identifying this Radius Provider.
     * @param radiusProviderRequest 
     * @return RequestConfig
     */
    fun providersRadiusUpdateRequestConfig(id: kotlin.Int, radiusProviderRequest: RadiusProviderRequest) : RequestConfig<RadiusProviderRequest> {
        val localVariableBody = radiusProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/providers/radius/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this Radius Provider.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersRadiusUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = providersRadiusUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this Radius Provider.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersRadiusUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = providersRadiusUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersRadiusUsedByList
     *
     * @param id A unique integer value identifying this Radius Provider.
     * @return RequestConfig
     */
    fun providersRadiusUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/radius/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLProvider Viewset
     * @param saMLProviderRequest 
     * @return SAMLProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersSamlCreate(saMLProviderRequest: SAMLProviderRequest) : SAMLProvider {
        val localVarResponse = providersSamlCreateWithHttpInfo(saMLProviderRequest = saMLProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLProvider Viewset
     * @param saMLProviderRequest 
     * @return ApiResponse<SAMLProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersSamlCreateWithHttpInfo(saMLProviderRequest: SAMLProviderRequest) : ApiResponse<SAMLProvider?> {
        val localVariableConfig = providersSamlCreateRequestConfig(saMLProviderRequest = saMLProviderRequest)

        return request<SAMLProviderRequest, SAMLProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersSamlCreate
     *
     * @param saMLProviderRequest 
     * @return RequestConfig
     */
    fun providersSamlCreateRequestConfig(saMLProviderRequest: SAMLProviderRequest) : RequestConfig<SAMLProviderRequest> {
        val localVariableBody = saMLProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/providers/saml/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLProvider Viewset
     * @param id A unique integer value identifying this SAML Provider.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersSamlDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = providersSamlDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLProvider Viewset
     * @param id A unique integer value identifying this SAML Provider.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun providersSamlDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = providersSamlDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersSamlDestroy
     *
     * @param id A unique integer value identifying this SAML Provider.
     * @return RequestConfig
     */
    fun providersSamlDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/providers/saml/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Create provider from SAML Metadata
     * @param name 
     * @param authorizationFlow 
     * @param file 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersSamlImportMetadataCreate(name: kotlin.String, authorizationFlow: java.util.UUID, file: java.io.File) : Unit {
        val localVarResponse = providersSamlImportMetadataCreateWithHttpInfo(name = name, authorizationFlow = authorizationFlow, file = file)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Create provider from SAML Metadata
     * @param name 
     * @param authorizationFlow 
     * @param file 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun providersSamlImportMetadataCreateWithHttpInfo(name: kotlin.String, authorizationFlow: java.util.UUID, file: java.io.File) : ApiResponse<Unit?> {
        val localVariableConfig = providersSamlImportMetadataCreateRequestConfig(name = name, authorizationFlow = authorizationFlow, file = file)

        return request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersSamlImportMetadataCreate
     *
     * @param name 
     * @param authorizationFlow 
     * @param file 
     * @return RequestConfig
     */
    fun providersSamlImportMetadataCreateRequestConfig(name: kotlin.String, authorizationFlow: java.util.UUID, file: java.io.File) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "name" to PartConfig(body = name, headers = mutableMapOf()),
            "authorization_flow" to PartConfig(body = authorizationFlow, headers = mutableMapOf()),
            "file" to PartConfig(body = file, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/providers/saml/import_metadata/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter digestAlgorithm
     */
     enum class DigestAlgorithmProvidersSamlList(val value: kotlin.String) {
         @Json(name = "http://www.w3.org/2000/09/xmldsig#sha1") _2000slash09SlashXmldsigHashSha1("http://www.w3.org/2000/09/xmldsig#sha1"),
         @Json(name = "http://www.w3.org/2001/04/xmldsig-more#sha384") _2001slash04SlashXmldsigMinusMoreHashSha384("http://www.w3.org/2001/04/xmldsig-more#sha384"),
         @Json(name = "http://www.w3.org/2001/04/xmlenc#sha256") _2001slash04SlashXmlencHashSha256("http://www.w3.org/2001/04/xmlenc#sha256"),
         @Json(name = "http://www.w3.org/2001/04/xmlenc#sha512") _2001slash04SlashXmlencHashSha512("http://www.w3.org/2001/04/xmlenc#sha512"),
     }

    /**
     * enum for parameter signatureAlgorithm
     */
     enum class SignatureAlgorithmProvidersSamlList(val value: kotlin.String) {
         @Json(name = "http://www.w3.org/2000/09/xmldsig#dsa-sha1") _2000slash09SlashXmldsigHashDsaMinusSha1("http://www.w3.org/2000/09/xmldsig#dsa-sha1"),
         @Json(name = "http://www.w3.org/2000/09/xmldsig#rsa-sha1") _2000slash09SlashXmldsigHashRsaMinusSha1("http://www.w3.org/2000/09/xmldsig#rsa-sha1"),
         @Json(name = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256") _2001slash04SlashXmldsigMinusMoreHashRsaMinusSha256("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"),
         @Json(name = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384") _2001slash04SlashXmldsigMinusMoreHashRsaMinusSha384("http://www.w3.org/2001/04/xmldsig-more#rsa-sha384"),
         @Json(name = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512") _2001slash04SlashXmldsigMinusMoreHashRsaMinusSha512("http://www.w3.org/2001/04/xmldsig-more#rsa-sha512"),
     }

    /**
     * enum for parameter spBinding
     */
     enum class SpBindingProvidersSamlList(val value: kotlin.String) {
         @Json(name = "post") post("post"),
         @Json(name = "redirect") redirect("redirect"),
     }

    /**
     * 
     * SAMLProvider Viewset
     * @param acsUrl  (optional)
     * @param assertionValidNotBefore  (optional)
     * @param assertionValidNotOnOrAfter  (optional)
     * @param audience  (optional)
     * @param authenticationFlow  (optional)
     * @param authorizationFlow  (optional)
     * @param backchannelApplication  (optional)
     * @param defaultRelayState  (optional)
     * @param digestAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#sha1&#x60; - SHA1 * &#x60;http://www.w3.org/2001/04/xmlenc#sha256&#x60; - SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#sha384&#x60; - SHA384 * &#x60;http://www.w3.org/2001/04/xmlenc#sha512&#x60; - SHA512 (optional)
     * @param isBackchannel  (optional)
     * @param issuer  (optional)
     * @param name  (optional)
     * @param nameIdMapping  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param propertyMappings  (optional)
     * @param search A search term. (optional)
     * @param sessionValidNotOnOrAfter  (optional)
     * @param signatureAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#rsa-sha1&#x60; - RSA-SHA1 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha256&#x60; - RSA-SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha384&#x60; - RSA-SHA384 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha512&#x60; - RSA-SHA512 * &#x60;http://www.w3.org/2000/09/xmldsig#dsa-sha1&#x60; - DSA-SHA1 (optional)
     * @param signingKp  (optional)
     * @param spBinding This determines how authentik sends the response back to the Service Provider.  * &#x60;redirect&#x60; - Redirect * &#x60;post&#x60; - Post (optional)
     * @param verificationKp  (optional)
     * @return PaginatedSAMLProviderList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersSamlList(acsUrl: kotlin.String? = null, assertionValidNotBefore: kotlin.String? = null, assertionValidNotOnOrAfter: kotlin.String? = null, audience: kotlin.String? = null, authenticationFlow: java.util.UUID? = null, authorizationFlow: java.util.UUID? = null, backchannelApplication: java.util.UUID? = null, defaultRelayState: kotlin.String? = null, digestAlgorithm: DigestAlgorithmProvidersSamlList? = null, isBackchannel: kotlin.Boolean? = null, issuer: kotlin.String? = null, name: kotlin.String? = null, nameIdMapping: java.util.UUID? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, propertyMappings: kotlin.collections.List<java.util.UUID>? = null, search: kotlin.String? = null, sessionValidNotOnOrAfter: kotlin.String? = null, signatureAlgorithm: SignatureAlgorithmProvidersSamlList? = null, signingKp: java.util.UUID? = null, spBinding: SpBindingProvidersSamlList? = null, verificationKp: java.util.UUID? = null) : PaginatedSAMLProviderList {
        val localVarResponse = providersSamlListWithHttpInfo(acsUrl = acsUrl, assertionValidNotBefore = assertionValidNotBefore, assertionValidNotOnOrAfter = assertionValidNotOnOrAfter, audience = audience, authenticationFlow = authenticationFlow, authorizationFlow = authorizationFlow, backchannelApplication = backchannelApplication, defaultRelayState = defaultRelayState, digestAlgorithm = digestAlgorithm, isBackchannel = isBackchannel, issuer = issuer, name = name, nameIdMapping = nameIdMapping, ordering = ordering, page = page, pageSize = pageSize, propertyMappings = propertyMappings, search = search, sessionValidNotOnOrAfter = sessionValidNotOnOrAfter, signatureAlgorithm = signatureAlgorithm, signingKp = signingKp, spBinding = spBinding, verificationKp = verificationKp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedSAMLProviderList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLProvider Viewset
     * @param acsUrl  (optional)
     * @param assertionValidNotBefore  (optional)
     * @param assertionValidNotOnOrAfter  (optional)
     * @param audience  (optional)
     * @param authenticationFlow  (optional)
     * @param authorizationFlow  (optional)
     * @param backchannelApplication  (optional)
     * @param defaultRelayState  (optional)
     * @param digestAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#sha1&#x60; - SHA1 * &#x60;http://www.w3.org/2001/04/xmlenc#sha256&#x60; - SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#sha384&#x60; - SHA384 * &#x60;http://www.w3.org/2001/04/xmlenc#sha512&#x60; - SHA512 (optional)
     * @param isBackchannel  (optional)
     * @param issuer  (optional)
     * @param name  (optional)
     * @param nameIdMapping  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param propertyMappings  (optional)
     * @param search A search term. (optional)
     * @param sessionValidNotOnOrAfter  (optional)
     * @param signatureAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#rsa-sha1&#x60; - RSA-SHA1 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha256&#x60; - RSA-SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha384&#x60; - RSA-SHA384 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha512&#x60; - RSA-SHA512 * &#x60;http://www.w3.org/2000/09/xmldsig#dsa-sha1&#x60; - DSA-SHA1 (optional)
     * @param signingKp  (optional)
     * @param spBinding This determines how authentik sends the response back to the Service Provider.  * &#x60;redirect&#x60; - Redirect * &#x60;post&#x60; - Post (optional)
     * @param verificationKp  (optional)
     * @return ApiResponse<PaginatedSAMLProviderList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersSamlListWithHttpInfo(acsUrl: kotlin.String?, assertionValidNotBefore: kotlin.String?, assertionValidNotOnOrAfter: kotlin.String?, audience: kotlin.String?, authenticationFlow: java.util.UUID?, authorizationFlow: java.util.UUID?, backchannelApplication: java.util.UUID?, defaultRelayState: kotlin.String?, digestAlgorithm: DigestAlgorithmProvidersSamlList?, isBackchannel: kotlin.Boolean?, issuer: kotlin.String?, name: kotlin.String?, nameIdMapping: java.util.UUID?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, propertyMappings: kotlin.collections.List<java.util.UUID>?, search: kotlin.String?, sessionValidNotOnOrAfter: kotlin.String?, signatureAlgorithm: SignatureAlgorithmProvidersSamlList?, signingKp: java.util.UUID?, spBinding: SpBindingProvidersSamlList?, verificationKp: java.util.UUID?) : ApiResponse<PaginatedSAMLProviderList?> {
        val localVariableConfig = providersSamlListRequestConfig(acsUrl = acsUrl, assertionValidNotBefore = assertionValidNotBefore, assertionValidNotOnOrAfter = assertionValidNotOnOrAfter, audience = audience, authenticationFlow = authenticationFlow, authorizationFlow = authorizationFlow, backchannelApplication = backchannelApplication, defaultRelayState = defaultRelayState, digestAlgorithm = digestAlgorithm, isBackchannel = isBackchannel, issuer = issuer, name = name, nameIdMapping = nameIdMapping, ordering = ordering, page = page, pageSize = pageSize, propertyMappings = propertyMappings, search = search, sessionValidNotOnOrAfter = sessionValidNotOnOrAfter, signatureAlgorithm = signatureAlgorithm, signingKp = signingKp, spBinding = spBinding, verificationKp = verificationKp)

        return request<Unit, PaginatedSAMLProviderList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersSamlList
     *
     * @param acsUrl  (optional)
     * @param assertionValidNotBefore  (optional)
     * @param assertionValidNotOnOrAfter  (optional)
     * @param audience  (optional)
     * @param authenticationFlow  (optional)
     * @param authorizationFlow  (optional)
     * @param backchannelApplication  (optional)
     * @param defaultRelayState  (optional)
     * @param digestAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#sha1&#x60; - SHA1 * &#x60;http://www.w3.org/2001/04/xmlenc#sha256&#x60; - SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#sha384&#x60; - SHA384 * &#x60;http://www.w3.org/2001/04/xmlenc#sha512&#x60; - SHA512 (optional)
     * @param isBackchannel  (optional)
     * @param issuer  (optional)
     * @param name  (optional)
     * @param nameIdMapping  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param propertyMappings  (optional)
     * @param search A search term. (optional)
     * @param sessionValidNotOnOrAfter  (optional)
     * @param signatureAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#rsa-sha1&#x60; - RSA-SHA1 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha256&#x60; - RSA-SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha384&#x60; - RSA-SHA384 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha512&#x60; - RSA-SHA512 * &#x60;http://www.w3.org/2000/09/xmldsig#dsa-sha1&#x60; - DSA-SHA1 (optional)
     * @param signingKp  (optional)
     * @param spBinding This determines how authentik sends the response back to the Service Provider.  * &#x60;redirect&#x60; - Redirect * &#x60;post&#x60; - Post (optional)
     * @param verificationKp  (optional)
     * @return RequestConfig
     */
    fun providersSamlListRequestConfig(acsUrl: kotlin.String?, assertionValidNotBefore: kotlin.String?, assertionValidNotOnOrAfter: kotlin.String?, audience: kotlin.String?, authenticationFlow: java.util.UUID?, authorizationFlow: java.util.UUID?, backchannelApplication: java.util.UUID?, defaultRelayState: kotlin.String?, digestAlgorithm: DigestAlgorithmProvidersSamlList?, isBackchannel: kotlin.Boolean?, issuer: kotlin.String?, name: kotlin.String?, nameIdMapping: java.util.UUID?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, propertyMappings: kotlin.collections.List<java.util.UUID>?, search: kotlin.String?, sessionValidNotOnOrAfter: kotlin.String?, signatureAlgorithm: SignatureAlgorithmProvidersSamlList?, signingKp: java.util.UUID?, spBinding: SpBindingProvidersSamlList?, verificationKp: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (acsUrl != null) {
                    put("acs_url", listOf(acsUrl.toString()))
                }
                if (assertionValidNotBefore != null) {
                    put("assertion_valid_not_before", listOf(assertionValidNotBefore.toString()))
                }
                if (assertionValidNotOnOrAfter != null) {
                    put("assertion_valid_not_on_or_after", listOf(assertionValidNotOnOrAfter.toString()))
                }
                if (audience != null) {
                    put("audience", listOf(audience.toString()))
                }
                if (authenticationFlow != null) {
                    put("authentication_flow", listOf(authenticationFlow.toString()))
                }
                if (authorizationFlow != null) {
                    put("authorization_flow", listOf(authorizationFlow.toString()))
                }
                if (backchannelApplication != null) {
                    put("backchannel_application", listOf(backchannelApplication.toString()))
                }
                if (defaultRelayState != null) {
                    put("default_relay_state", listOf(defaultRelayState.toString()))
                }
                if (digestAlgorithm != null) {
                    put("digest_algorithm", listOf(digestAlgorithm.value))
                }
                if (isBackchannel != null) {
                    put("is_backchannel", listOf(isBackchannel.toString()))
                }
                if (issuer != null) {
                    put("issuer", listOf(issuer.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (nameIdMapping != null) {
                    put("name_id_mapping", listOf(nameIdMapping.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (propertyMappings != null) {
                    put("property_mappings", toMultiValue(propertyMappings.toList(), "multi"))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (sessionValidNotOnOrAfter != null) {
                    put("session_valid_not_on_or_after", listOf(sessionValidNotOnOrAfter.toString()))
                }
                if (signatureAlgorithm != null) {
                    put("signature_algorithm", listOf(signatureAlgorithm.value))
                }
                if (signingKp != null) {
                    put("signing_kp", listOf(signingKp.toString()))
                }
                if (spBinding != null) {
                    put("sp_binding", listOf(spBinding.value))
                }
                if (verificationKp != null) {
                    put("verification_kp", listOf(verificationKp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/saml/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter forceBinding
     */
     enum class ForceBindingProvidersSamlMetadataRetrieve(val value: kotlin.String) {
         @Json(name = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST") pOST("urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"),
         @Json(name = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect") redirect("urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"),
     }

    /**
     * 
     * Return metadata as XML string
     * @param id A unique integer value identifying this SAML Provider.
     * @param download  (optional)
     * @param forceBinding Optionally force the metadata to only include one binding. (optional)
     * @return SAMLMetadata
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersSamlMetadataRetrieve(id: kotlin.Int, download: kotlin.Boolean? = null, forceBinding: ForceBindingProvidersSamlMetadataRetrieve? = null) : SAMLMetadata {
        val localVarResponse = providersSamlMetadataRetrieveWithHttpInfo(id = id, download = download, forceBinding = forceBinding)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLMetadata
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Return metadata as XML string
     * @param id A unique integer value identifying this SAML Provider.
     * @param download  (optional)
     * @param forceBinding Optionally force the metadata to only include one binding. (optional)
     * @return ApiResponse<SAMLMetadata?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersSamlMetadataRetrieveWithHttpInfo(id: kotlin.Int, download: kotlin.Boolean?, forceBinding: ForceBindingProvidersSamlMetadataRetrieve?) : ApiResponse<SAMLMetadata?> {
        val localVariableConfig = providersSamlMetadataRetrieveRequestConfig(id = id, download = download, forceBinding = forceBinding)

        return request<Unit, SAMLMetadata>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersSamlMetadataRetrieve
     *
     * @param id A unique integer value identifying this SAML Provider.
     * @param download  (optional)
     * @param forceBinding Optionally force the metadata to only include one binding. (optional)
     * @return RequestConfig
     */
    fun providersSamlMetadataRetrieveRequestConfig(id: kotlin.Int, download: kotlin.Boolean?, forceBinding: ForceBindingProvidersSamlMetadataRetrieve?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (download != null) {
                    put("download", listOf(download.toString()))
                }
                if (forceBinding != null) {
                    put("force_binding", listOf(forceBinding.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/saml/{id}/metadata/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLProvider Viewset
     * @param id A unique integer value identifying this SAML Provider.
     * @param patchedSAMLProviderRequest  (optional)
     * @return SAMLProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersSamlPartialUpdate(id: kotlin.Int, patchedSAMLProviderRequest: PatchedSAMLProviderRequest? = null) : SAMLProvider {
        val localVarResponse = providersSamlPartialUpdateWithHttpInfo(id = id, patchedSAMLProviderRequest = patchedSAMLProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLProvider Viewset
     * @param id A unique integer value identifying this SAML Provider.
     * @param patchedSAMLProviderRequest  (optional)
     * @return ApiResponse<SAMLProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersSamlPartialUpdateWithHttpInfo(id: kotlin.Int, patchedSAMLProviderRequest: PatchedSAMLProviderRequest?) : ApiResponse<SAMLProvider?> {
        val localVariableConfig = providersSamlPartialUpdateRequestConfig(id = id, patchedSAMLProviderRequest = patchedSAMLProviderRequest)

        return request<PatchedSAMLProviderRequest, SAMLProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersSamlPartialUpdate
     *
     * @param id A unique integer value identifying this SAML Provider.
     * @param patchedSAMLProviderRequest  (optional)
     * @return RequestConfig
     */
    fun providersSamlPartialUpdateRequestConfig(id: kotlin.Int, patchedSAMLProviderRequest: PatchedSAMLProviderRequest?) : RequestConfig<PatchedSAMLProviderRequest> {
        val localVariableBody = patchedSAMLProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/providers/saml/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Preview user data for provider
     * @param id A unique integer value identifying this SAML Provider.
     * @return PropertyMappingPreview
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersSamlPreviewUserRetrieve(id: kotlin.Int) : PropertyMappingPreview {
        val localVarResponse = providersSamlPreviewUserRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PropertyMappingPreview
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Preview user data for provider
     * @param id A unique integer value identifying this SAML Provider.
     * @return ApiResponse<PropertyMappingPreview?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersSamlPreviewUserRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<PropertyMappingPreview?> {
        val localVariableConfig = providersSamlPreviewUserRetrieveRequestConfig(id = id)

        return request<Unit, PropertyMappingPreview>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersSamlPreviewUserRetrieve
     *
     * @param id A unique integer value identifying this SAML Provider.
     * @return RequestConfig
     */
    fun providersSamlPreviewUserRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/saml/{id}/preview_user/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLProvider Viewset
     * @param id A unique integer value identifying this SAML Provider.
     * @return SAMLProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersSamlRetrieve(id: kotlin.Int) : SAMLProvider {
        val localVarResponse = providersSamlRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLProvider Viewset
     * @param id A unique integer value identifying this SAML Provider.
     * @return ApiResponse<SAMLProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersSamlRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<SAMLProvider?> {
        val localVariableConfig = providersSamlRetrieveRequestConfig(id = id)

        return request<Unit, SAMLProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersSamlRetrieve
     *
     * @param id A unique integer value identifying this SAML Provider.
     * @return RequestConfig
     */
    fun providersSamlRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/saml/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLProvider Viewset
     * @param id A unique integer value identifying this SAML Provider.
     * @param saMLProviderRequest 
     * @return SAMLProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersSamlUpdate(id: kotlin.Int, saMLProviderRequest: SAMLProviderRequest) : SAMLProvider {
        val localVarResponse = providersSamlUpdateWithHttpInfo(id = id, saMLProviderRequest = saMLProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLProvider Viewset
     * @param id A unique integer value identifying this SAML Provider.
     * @param saMLProviderRequest 
     * @return ApiResponse<SAMLProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersSamlUpdateWithHttpInfo(id: kotlin.Int, saMLProviderRequest: SAMLProviderRequest) : ApiResponse<SAMLProvider?> {
        val localVariableConfig = providersSamlUpdateRequestConfig(id = id, saMLProviderRequest = saMLProviderRequest)

        return request<SAMLProviderRequest, SAMLProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersSamlUpdate
     *
     * @param id A unique integer value identifying this SAML Provider.
     * @param saMLProviderRequest 
     * @return RequestConfig
     */
    fun providersSamlUpdateRequestConfig(id: kotlin.Int, saMLProviderRequest: SAMLProviderRequest) : RequestConfig<SAMLProviderRequest> {
        val localVariableBody = saMLProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/providers/saml/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this SAML Provider.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersSamlUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = providersSamlUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this SAML Provider.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersSamlUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = providersSamlUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersSamlUsedByList
     *
     * @param id A unique integer value identifying this SAML Provider.
     * @return RequestConfig
     */
    fun providersSamlUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/saml/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param scIMProviderRequest 
     * @return SCIMProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersScimCreate(scIMProviderRequest: SCIMProviderRequest) : SCIMProvider {
        val localVarResponse = providersScimCreateWithHttpInfo(scIMProviderRequest = scIMProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SCIMProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param scIMProviderRequest 
     * @return ApiResponse<SCIMProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersScimCreateWithHttpInfo(scIMProviderRequest: SCIMProviderRequest) : ApiResponse<SCIMProvider?> {
        val localVariableConfig = providersScimCreateRequestConfig(scIMProviderRequest = scIMProviderRequest)

        return request<SCIMProviderRequest, SCIMProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersScimCreate
     *
     * @param scIMProviderRequest 
     * @return RequestConfig
     */
    fun providersScimCreateRequestConfig(scIMProviderRequest: SCIMProviderRequest) : RequestConfig<SCIMProviderRequest> {
        val localVariableBody = scIMProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/providers/scim/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param id A unique integer value identifying this SCIM Provider.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersScimDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = providersScimDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param id A unique integer value identifying this SCIM Provider.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun providersScimDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = providersScimDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersScimDestroy
     *
     * @param id A unique integer value identifying this SCIM Provider.
     * @return RequestConfig
     */
    fun providersScimDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/providers/scim/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param excludeUsersServiceAccount  (optional)
     * @param filterGroup  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param url  (optional)
     * @return PaginatedSCIMProviderList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersScimList(excludeUsersServiceAccount: kotlin.Boolean? = null, filterGroup: java.util.UUID? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, url: kotlin.String? = null) : PaginatedSCIMProviderList {
        val localVarResponse = providersScimListWithHttpInfo(excludeUsersServiceAccount = excludeUsersServiceAccount, filterGroup = filterGroup, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, url = url)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedSCIMProviderList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param excludeUsersServiceAccount  (optional)
     * @param filterGroup  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param url  (optional)
     * @return ApiResponse<PaginatedSCIMProviderList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersScimListWithHttpInfo(excludeUsersServiceAccount: kotlin.Boolean?, filterGroup: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, url: kotlin.String?) : ApiResponse<PaginatedSCIMProviderList?> {
        val localVariableConfig = providersScimListRequestConfig(excludeUsersServiceAccount = excludeUsersServiceAccount, filterGroup = filterGroup, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, url = url)

        return request<Unit, PaginatedSCIMProviderList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersScimList
     *
     * @param excludeUsersServiceAccount  (optional)
     * @param filterGroup  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param url  (optional)
     * @return RequestConfig
     */
    fun providersScimListRequestConfig(excludeUsersServiceAccount: kotlin.Boolean?, filterGroup: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, url: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (excludeUsersServiceAccount != null) {
                    put("exclude_users_service_account", listOf(excludeUsersServiceAccount.toString()))
                }
                if (filterGroup != null) {
                    put("filter_group", listOf(filterGroup.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (url != null) {
                    put("url", listOf(url.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/scim/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param id A unique integer value identifying this SCIM Provider.
     * @param patchedSCIMProviderRequest  (optional)
     * @return SCIMProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersScimPartialUpdate(id: kotlin.Int, patchedSCIMProviderRequest: PatchedSCIMProviderRequest? = null) : SCIMProvider {
        val localVarResponse = providersScimPartialUpdateWithHttpInfo(id = id, patchedSCIMProviderRequest = patchedSCIMProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SCIMProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param id A unique integer value identifying this SCIM Provider.
     * @param patchedSCIMProviderRequest  (optional)
     * @return ApiResponse<SCIMProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersScimPartialUpdateWithHttpInfo(id: kotlin.Int, patchedSCIMProviderRequest: PatchedSCIMProviderRequest?) : ApiResponse<SCIMProvider?> {
        val localVariableConfig = providersScimPartialUpdateRequestConfig(id = id, patchedSCIMProviderRequest = patchedSCIMProviderRequest)

        return request<PatchedSCIMProviderRequest, SCIMProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersScimPartialUpdate
     *
     * @param id A unique integer value identifying this SCIM Provider.
     * @param patchedSCIMProviderRequest  (optional)
     * @return RequestConfig
     */
    fun providersScimPartialUpdateRequestConfig(id: kotlin.Int, patchedSCIMProviderRequest: PatchedSCIMProviderRequest?) : RequestConfig<PatchedSCIMProviderRequest> {
        val localVariableBody = patchedSCIMProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/providers/scim/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param id A unique integer value identifying this SCIM Provider.
     * @return SCIMProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersScimRetrieve(id: kotlin.Int) : SCIMProvider {
        val localVarResponse = providersScimRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SCIMProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param id A unique integer value identifying this SCIM Provider.
     * @return ApiResponse<SCIMProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersScimRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<SCIMProvider?> {
        val localVariableConfig = providersScimRetrieveRequestConfig(id = id)

        return request<Unit, SCIMProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersScimRetrieve
     *
     * @param id A unique integer value identifying this SCIM Provider.
     * @return RequestConfig
     */
    fun providersScimRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/scim/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get provider&#39;s sync status
     * @param id A unique integer value identifying this SCIM Provider.
     * @return SCIMSyncStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersScimSyncStatusRetrieve(id: kotlin.Int) : SCIMSyncStatus {
        val localVarResponse = providersScimSyncStatusRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SCIMSyncStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get provider&#39;s sync status
     * @param id A unique integer value identifying this SCIM Provider.
     * @return ApiResponse<SCIMSyncStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersScimSyncStatusRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<SCIMSyncStatus?> {
        val localVariableConfig = providersScimSyncStatusRetrieveRequestConfig(id = id)

        return request<Unit, SCIMSyncStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersScimSyncStatusRetrieve
     *
     * @param id A unique integer value identifying this SCIM Provider.
     * @return RequestConfig
     */
    fun providersScimSyncStatusRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/scim/{id}/sync_status/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param id A unique integer value identifying this SCIM Provider.
     * @param scIMProviderRequest 
     * @return SCIMProvider
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersScimUpdate(id: kotlin.Int, scIMProviderRequest: SCIMProviderRequest) : SCIMProvider {
        val localVarResponse = providersScimUpdateWithHttpInfo(id = id, scIMProviderRequest = scIMProviderRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SCIMProvider
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SCIMProvider Viewset
     * @param id A unique integer value identifying this SCIM Provider.
     * @param scIMProviderRequest 
     * @return ApiResponse<SCIMProvider?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersScimUpdateWithHttpInfo(id: kotlin.Int, scIMProviderRequest: SCIMProviderRequest) : ApiResponse<SCIMProvider?> {
        val localVariableConfig = providersScimUpdateRequestConfig(id = id, scIMProviderRequest = scIMProviderRequest)

        return request<SCIMProviderRequest, SCIMProvider>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersScimUpdate
     *
     * @param id A unique integer value identifying this SCIM Provider.
     * @param scIMProviderRequest 
     * @return RequestConfig
     */
    fun providersScimUpdateRequestConfig(id: kotlin.Int, scIMProviderRequest: SCIMProviderRequest) : RequestConfig<SCIMProviderRequest> {
        val localVariableBody = scIMProviderRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/providers/scim/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this SCIM Provider.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun providersScimUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = providersScimUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this SCIM Provider.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun providersScimUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = providersScimUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation providersScimUsedByList
     *
     * @param id A unique integer value identifying this SCIM Provider.
     * @return RequestConfig
     */
    fun providersScimUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/providers/scim/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
