/**
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2023.10.2
 * Contact: hello@goauthentik.io
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.FilePathRequest
import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.LDAPDebug
import io.goauthentik.api.models.LDAPSource
import io.goauthentik.api.models.LDAPSourceRequest
import io.goauthentik.api.models.OAuthSource
import io.goauthentik.api.models.OAuthSourceRequest
import io.goauthentik.api.models.PaginatedLDAPSourceList
import io.goauthentik.api.models.PaginatedOAuthSourceList
import io.goauthentik.api.models.PaginatedPlexSourceConnectionList
import io.goauthentik.api.models.PaginatedPlexSourceList
import io.goauthentik.api.models.PaginatedSAMLSourceList
import io.goauthentik.api.models.PaginatedSourceList
import io.goauthentik.api.models.PaginatedUserOAuthSourceConnectionList
import io.goauthentik.api.models.PaginatedUserSAMLSourceConnectionList
import io.goauthentik.api.models.PaginatedUserSourceConnectionList
import io.goauthentik.api.models.PatchedLDAPSourceRequest
import io.goauthentik.api.models.PatchedOAuthSourceRequest
import io.goauthentik.api.models.PatchedPlexSourceConnectionRequest
import io.goauthentik.api.models.PatchedPlexSourceRequest
import io.goauthentik.api.models.PatchedSAMLSourceRequest
import io.goauthentik.api.models.PatchedUserOAuthSourceConnectionRequest
import io.goauthentik.api.models.PatchedUserSAMLSourceConnectionRequest
import io.goauthentik.api.models.PlexSource
import io.goauthentik.api.models.PlexSourceConnection
import io.goauthentik.api.models.PlexSourceConnectionRequest
import io.goauthentik.api.models.PlexSourceRequest
import io.goauthentik.api.models.PlexTokenRedeemRequest
import io.goauthentik.api.models.RedirectChallenge
import io.goauthentik.api.models.SAMLMetadata
import io.goauthentik.api.models.SAMLSource
import io.goauthentik.api.models.SAMLSourceRequest
import io.goauthentik.api.models.Source
import io.goauthentik.api.models.SourceType
import io.goauthentik.api.models.Task
import io.goauthentik.api.models.TypeCreate
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.UserOAuthSourceConnection
import io.goauthentik.api.models.UserOAuthSourceConnectionRequest
import io.goauthentik.api.models.UserSAMLSourceConnection
import io.goauthentik.api.models.UserSAMLSourceConnectionRequest
import io.goauthentik.api.models.UserSetting
import io.goauthentik.api.models.UserSourceConnection
import io.goauthentik.api.models.ValidationError

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class SourcesApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesAllDestroy(slug: kotlin.String) : Unit {
        val localVarResponse = sourcesAllDestroyWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesAllDestroyWithHttpInfo(slug: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesAllDestroyRequestConfig(slug = slug)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesAllDestroy
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesAllDestroyRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/sources/all/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @return PaginatedSourceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesAllList(managed: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, slug: kotlin.String? = null) : PaginatedSourceList {
        val localVarResponse = sourcesAllListWithHttpInfo(managed = managed, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedSourceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @return ApiResponse<PaginatedSourceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesAllListWithHttpInfo(managed: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, slug: kotlin.String?) : ApiResponse<PaginatedSourceList?> {
        val localVariableConfig = sourcesAllListRequestConfig(managed = managed, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, slug = slug)

        return request<Unit, PaginatedSourceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesAllList
     *
     * @param managed  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @return RequestConfig
     */
    fun sourcesAllListRequestConfig(managed: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, slug: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (managed != null) {
                    put("managed", listOf(managed.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (slug != null) {
                    put("slug", listOf(slug.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/all/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @return Source
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesAllRetrieve(slug: kotlin.String) : Source {
        val localVarResponse = sourcesAllRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Source
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @return ApiResponse<Source?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesAllRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<Source?> {
        val localVariableConfig = sourcesAllRetrieveRequestConfig(slug = slug)

        return request<Unit, Source>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesAllRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesAllRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/all/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set source icon
     * @param slug 
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesAllSetIconCreate(slug: kotlin.String, file: java.io.File? = null, clear: kotlin.Boolean? = false) : Unit {
        val localVarResponse = sourcesAllSetIconCreateWithHttpInfo(slug = slug, file = file, clear = clear)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set source icon
     * @param slug 
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesAllSetIconCreateWithHttpInfo(slug: kotlin.String, file: java.io.File?, clear: kotlin.Boolean?) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesAllSetIconCreateRequestConfig(slug = slug, file = file, clear = clear)

        return request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesAllSetIconCreate
     *
     * @param slug 
     * @param file  (optional)
     * @param clear  (optional, default to false)
     * @return RequestConfig
     */
    fun sourcesAllSetIconCreateRequestConfig(slug: kotlin.String, file: java.io.File?, clear: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "clear" to PartConfig(body = clear, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/sources/all/{slug}/set_icon/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Set source icon (as URL)
     * @param slug 
     * @param filePathRequest 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesAllSetIconUrlCreate(slug: kotlin.String, filePathRequest: FilePathRequest) : Unit {
        val localVarResponse = sourcesAllSetIconUrlCreateWithHttpInfo(slug = slug, filePathRequest = filePathRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Set source icon (as URL)
     * @param slug 
     * @param filePathRequest 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesAllSetIconUrlCreateWithHttpInfo(slug: kotlin.String, filePathRequest: FilePathRequest) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesAllSetIconUrlCreateRequestConfig(slug = slug, filePathRequest = filePathRequest)

        return request<FilePathRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesAllSetIconUrlCreate
     *
     * @param slug 
     * @param filePathRequest 
     * @return RequestConfig
     */
    fun sourcesAllSetIconUrlCreateRequestConfig(slug: kotlin.String, filePathRequest: FilePathRequest) : RequestConfig<FilePathRequest> {
        val localVariableBody = filePathRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/sources/all/{slug}/set_icon_url/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all creatable source types
     * @return kotlin.collections.List<TypeCreate>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesAllTypesList() : kotlin.collections.List<TypeCreate> {
        val localVarResponse = sourcesAllTypesListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TypeCreate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all creatable source types
     * @return ApiResponse<kotlin.collections.List<TypeCreate>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesAllTypesListWithHttpInfo() : ApiResponse<kotlin.collections.List<TypeCreate>?> {
        val localVariableConfig = sourcesAllTypesListRequestConfig()

        return request<Unit, kotlin.collections.List<TypeCreate>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesAllTypesList
     *
     * @return RequestConfig
     */
    fun sourcesAllTypesListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/all/types/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesAllUsedByList(slug: kotlin.String) : kotlin.collections.List<UsedBy> {
        val localVarResponse = sourcesAllUsedByListWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesAllUsedByListWithHttpInfo(slug: kotlin.String) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = sourcesAllUsedByListRequestConfig(slug = slug)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesAllUsedByList
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesAllUsedByListRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/all/{slug}/used_by/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all sources the user can configure
     * @return kotlin.collections.List<UserSetting>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesAllUserSettingsList() : kotlin.collections.List<UserSetting> {
        val localVarResponse = sourcesAllUserSettingsListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UserSetting>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all sources the user can configure
     * @return ApiResponse<kotlin.collections.List<UserSetting>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesAllUserSettingsListWithHttpInfo() : ApiResponse<kotlin.collections.List<UserSetting>?> {
        val localVariableConfig = sourcesAllUserSettingsListRequestConfig()

        return request<Unit, kotlin.collections.List<UserSetting>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesAllUserSettingsList
     *
     * @return RequestConfig
     */
    fun sourcesAllUserSettingsListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/all/user_settings/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP Source Viewset
     * @param ldAPSourceRequest 
     * @return LDAPSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesLdapCreate(ldAPSourceRequest: LDAPSourceRequest) : LDAPSource {
        val localVarResponse = sourcesLdapCreateWithHttpInfo(ldAPSourceRequest = ldAPSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP Source Viewset
     * @param ldAPSourceRequest 
     * @return ApiResponse<LDAPSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesLdapCreateWithHttpInfo(ldAPSourceRequest: LDAPSourceRequest) : ApiResponse<LDAPSource?> {
        val localVariableConfig = sourcesLdapCreateRequestConfig(ldAPSourceRequest = ldAPSourceRequest)

        return request<LDAPSourceRequest, LDAPSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesLdapCreate
     *
     * @param ldAPSourceRequest 
     * @return RequestConfig
     */
    fun sourcesLdapCreateRequestConfig(ldAPSourceRequest: LDAPSourceRequest) : RequestConfig<LDAPSourceRequest> {
        val localVariableBody = ldAPSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/sources/ldap/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get raw LDAP data to debug
     * @param slug 
     * @return LDAPDebug
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesLdapDebugRetrieve(slug: kotlin.String) : LDAPDebug {
        val localVarResponse = sourcesLdapDebugRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPDebug
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get raw LDAP data to debug
     * @param slug 
     * @return ApiResponse<LDAPDebug?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesLdapDebugRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<LDAPDebug?> {
        val localVariableConfig = sourcesLdapDebugRetrieveRequestConfig(slug = slug)

        return request<Unit, LDAPDebug>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesLdapDebugRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesLdapDebugRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/ldap/{slug}/debug/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP Source Viewset
     * @param slug 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesLdapDestroy(slug: kotlin.String) : Unit {
        val localVarResponse = sourcesLdapDestroyWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP Source Viewset
     * @param slug 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesLdapDestroyWithHttpInfo(slug: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesLdapDestroyRequestConfig(slug = slug)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesLdapDestroy
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesLdapDestroyRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/sources/ldap/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP Source Viewset
     * @param additionalGroupDn  (optional)
     * @param additionalUserDn  (optional)
     * @param baseDn  (optional)
     * @param bindCn  (optional)
     * @param clientCertificate  (optional)
     * @param enabled  (optional)
     * @param groupMembershipField  (optional)
     * @param groupObjectFilter  (optional)
     * @param name  (optional)
     * @param objectUniquenessField  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param peerCertificate  (optional)
     * @param propertyMappings  (optional)
     * @param propertyMappingsGroup  (optional)
     * @param search A search term. (optional)
     * @param serverUri  (optional)
     * @param slug  (optional)
     * @param sni  (optional)
     * @param startTls  (optional)
     * @param syncGroups  (optional)
     * @param syncParentGroup  (optional)
     * @param syncUsers  (optional)
     * @param syncUsersPassword  (optional)
     * @param userObjectFilter  (optional)
     * @return PaginatedLDAPSourceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesLdapList(additionalGroupDn: kotlin.String? = null, additionalUserDn: kotlin.String? = null, baseDn: kotlin.String? = null, bindCn: kotlin.String? = null, clientCertificate: java.util.UUID? = null, enabled: kotlin.Boolean? = null, groupMembershipField: kotlin.String? = null, groupObjectFilter: kotlin.String? = null, name: kotlin.String? = null, objectUniquenessField: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, peerCertificate: java.util.UUID? = null, propertyMappings: kotlin.collections.List<java.util.UUID>? = null, propertyMappingsGroup: kotlin.collections.List<java.util.UUID>? = null, search: kotlin.String? = null, serverUri: kotlin.String? = null, slug: kotlin.String? = null, sni: kotlin.Boolean? = null, startTls: kotlin.Boolean? = null, syncGroups: kotlin.Boolean? = null, syncParentGroup: java.util.UUID? = null, syncUsers: kotlin.Boolean? = null, syncUsersPassword: kotlin.Boolean? = null, userObjectFilter: kotlin.String? = null) : PaginatedLDAPSourceList {
        val localVarResponse = sourcesLdapListWithHttpInfo(additionalGroupDn = additionalGroupDn, additionalUserDn = additionalUserDn, baseDn = baseDn, bindCn = bindCn, clientCertificate = clientCertificate, enabled = enabled, groupMembershipField = groupMembershipField, groupObjectFilter = groupObjectFilter, name = name, objectUniquenessField = objectUniquenessField, ordering = ordering, page = page, pageSize = pageSize, peerCertificate = peerCertificate, propertyMappings = propertyMappings, propertyMappingsGroup = propertyMappingsGroup, search = search, serverUri = serverUri, slug = slug, sni = sni, startTls = startTls, syncGroups = syncGroups, syncParentGroup = syncParentGroup, syncUsers = syncUsers, syncUsersPassword = syncUsersPassword, userObjectFilter = userObjectFilter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedLDAPSourceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP Source Viewset
     * @param additionalGroupDn  (optional)
     * @param additionalUserDn  (optional)
     * @param baseDn  (optional)
     * @param bindCn  (optional)
     * @param clientCertificate  (optional)
     * @param enabled  (optional)
     * @param groupMembershipField  (optional)
     * @param groupObjectFilter  (optional)
     * @param name  (optional)
     * @param objectUniquenessField  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param peerCertificate  (optional)
     * @param propertyMappings  (optional)
     * @param propertyMappingsGroup  (optional)
     * @param search A search term. (optional)
     * @param serverUri  (optional)
     * @param slug  (optional)
     * @param sni  (optional)
     * @param startTls  (optional)
     * @param syncGroups  (optional)
     * @param syncParentGroup  (optional)
     * @param syncUsers  (optional)
     * @param syncUsersPassword  (optional)
     * @param userObjectFilter  (optional)
     * @return ApiResponse<PaginatedLDAPSourceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesLdapListWithHttpInfo(additionalGroupDn: kotlin.String?, additionalUserDn: kotlin.String?, baseDn: kotlin.String?, bindCn: kotlin.String?, clientCertificate: java.util.UUID?, enabled: kotlin.Boolean?, groupMembershipField: kotlin.String?, groupObjectFilter: kotlin.String?, name: kotlin.String?, objectUniquenessField: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, peerCertificate: java.util.UUID?, propertyMappings: kotlin.collections.List<java.util.UUID>?, propertyMappingsGroup: kotlin.collections.List<java.util.UUID>?, search: kotlin.String?, serverUri: kotlin.String?, slug: kotlin.String?, sni: kotlin.Boolean?, startTls: kotlin.Boolean?, syncGroups: kotlin.Boolean?, syncParentGroup: java.util.UUID?, syncUsers: kotlin.Boolean?, syncUsersPassword: kotlin.Boolean?, userObjectFilter: kotlin.String?) : ApiResponse<PaginatedLDAPSourceList?> {
        val localVariableConfig = sourcesLdapListRequestConfig(additionalGroupDn = additionalGroupDn, additionalUserDn = additionalUserDn, baseDn = baseDn, bindCn = bindCn, clientCertificate = clientCertificate, enabled = enabled, groupMembershipField = groupMembershipField, groupObjectFilter = groupObjectFilter, name = name, objectUniquenessField = objectUniquenessField, ordering = ordering, page = page, pageSize = pageSize, peerCertificate = peerCertificate, propertyMappings = propertyMappings, propertyMappingsGroup = propertyMappingsGroup, search = search, serverUri = serverUri, slug = slug, sni = sni, startTls = startTls, syncGroups = syncGroups, syncParentGroup = syncParentGroup, syncUsers = syncUsers, syncUsersPassword = syncUsersPassword, userObjectFilter = userObjectFilter)

        return request<Unit, PaginatedLDAPSourceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesLdapList
     *
     * @param additionalGroupDn  (optional)
     * @param additionalUserDn  (optional)
     * @param baseDn  (optional)
     * @param bindCn  (optional)
     * @param clientCertificate  (optional)
     * @param enabled  (optional)
     * @param groupMembershipField  (optional)
     * @param groupObjectFilter  (optional)
     * @param name  (optional)
     * @param objectUniquenessField  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param peerCertificate  (optional)
     * @param propertyMappings  (optional)
     * @param propertyMappingsGroup  (optional)
     * @param search A search term. (optional)
     * @param serverUri  (optional)
     * @param slug  (optional)
     * @param sni  (optional)
     * @param startTls  (optional)
     * @param syncGroups  (optional)
     * @param syncParentGroup  (optional)
     * @param syncUsers  (optional)
     * @param syncUsersPassword  (optional)
     * @param userObjectFilter  (optional)
     * @return RequestConfig
     */
    fun sourcesLdapListRequestConfig(additionalGroupDn: kotlin.String?, additionalUserDn: kotlin.String?, baseDn: kotlin.String?, bindCn: kotlin.String?, clientCertificate: java.util.UUID?, enabled: kotlin.Boolean?, groupMembershipField: kotlin.String?, groupObjectFilter: kotlin.String?, name: kotlin.String?, objectUniquenessField: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, peerCertificate: java.util.UUID?, propertyMappings: kotlin.collections.List<java.util.UUID>?, propertyMappingsGroup: kotlin.collections.List<java.util.UUID>?, search: kotlin.String?, serverUri: kotlin.String?, slug: kotlin.String?, sni: kotlin.Boolean?, startTls: kotlin.Boolean?, syncGroups: kotlin.Boolean?, syncParentGroup: java.util.UUID?, syncUsers: kotlin.Boolean?, syncUsersPassword: kotlin.Boolean?, userObjectFilter: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (additionalGroupDn != null) {
                    put("additional_group_dn", listOf(additionalGroupDn.toString()))
                }
                if (additionalUserDn != null) {
                    put("additional_user_dn", listOf(additionalUserDn.toString()))
                }
                if (baseDn != null) {
                    put("base_dn", listOf(baseDn.toString()))
                }
                if (bindCn != null) {
                    put("bind_cn", listOf(bindCn.toString()))
                }
                if (clientCertificate != null) {
                    put("client_certificate", listOf(clientCertificate.toString()))
                }
                if (enabled != null) {
                    put("enabled", listOf(enabled.toString()))
                }
                if (groupMembershipField != null) {
                    put("group_membership_field", listOf(groupMembershipField.toString()))
                }
                if (groupObjectFilter != null) {
                    put("group_object_filter", listOf(groupObjectFilter.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (objectUniquenessField != null) {
                    put("object_uniqueness_field", listOf(objectUniquenessField.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (peerCertificate != null) {
                    put("peer_certificate", listOf(peerCertificate.toString()))
                }
                if (propertyMappings != null) {
                    put("property_mappings", toMultiValue(propertyMappings.toList(), "multi"))
                }
                if (propertyMappingsGroup != null) {
                    put("property_mappings_group", toMultiValue(propertyMappingsGroup.toList(), "multi"))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (serverUri != null) {
                    put("server_uri", listOf(serverUri.toString()))
                }
                if (slug != null) {
                    put("slug", listOf(slug.toString()))
                }
                if (sni != null) {
                    put("sni", listOf(sni.toString()))
                }
                if (startTls != null) {
                    put("start_tls", listOf(startTls.toString()))
                }
                if (syncGroups != null) {
                    put("sync_groups", listOf(syncGroups.toString()))
                }
                if (syncParentGroup != null) {
                    put("sync_parent_group", listOf(syncParentGroup.toString()))
                }
                if (syncUsers != null) {
                    put("sync_users", listOf(syncUsers.toString()))
                }
                if (syncUsersPassword != null) {
                    put("sync_users_password", listOf(syncUsersPassword.toString()))
                }
                if (userObjectFilter != null) {
                    put("user_object_filter", listOf(userObjectFilter.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/ldap/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP Source Viewset
     * @param slug 
     * @param patchedLDAPSourceRequest  (optional)
     * @return LDAPSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesLdapPartialUpdate(slug: kotlin.String, patchedLDAPSourceRequest: PatchedLDAPSourceRequest? = null) : LDAPSource {
        val localVarResponse = sourcesLdapPartialUpdateWithHttpInfo(slug = slug, patchedLDAPSourceRequest = patchedLDAPSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP Source Viewset
     * @param slug 
     * @param patchedLDAPSourceRequest  (optional)
     * @return ApiResponse<LDAPSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesLdapPartialUpdateWithHttpInfo(slug: kotlin.String, patchedLDAPSourceRequest: PatchedLDAPSourceRequest?) : ApiResponse<LDAPSource?> {
        val localVariableConfig = sourcesLdapPartialUpdateRequestConfig(slug = slug, patchedLDAPSourceRequest = patchedLDAPSourceRequest)

        return request<PatchedLDAPSourceRequest, LDAPSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesLdapPartialUpdate
     *
     * @param slug 
     * @param patchedLDAPSourceRequest  (optional)
     * @return RequestConfig
     */
    fun sourcesLdapPartialUpdateRequestConfig(slug: kotlin.String, patchedLDAPSourceRequest: PatchedLDAPSourceRequest?) : RequestConfig<PatchedLDAPSourceRequest> {
        val localVariableBody = patchedLDAPSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/sources/ldap/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP Source Viewset
     * @param slug 
     * @return LDAPSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesLdapRetrieve(slug: kotlin.String) : LDAPSource {
        val localVarResponse = sourcesLdapRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP Source Viewset
     * @param slug 
     * @return ApiResponse<LDAPSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesLdapRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<LDAPSource?> {
        val localVariableConfig = sourcesLdapRetrieveRequestConfig(slug = slug)

        return request<Unit, LDAPSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesLdapRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesLdapRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/ldap/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get source&#39;s sync status
     * @param slug 
     * @return kotlin.collections.List<Task>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesLdapSyncStatusList(slug: kotlin.String) : kotlin.collections.List<Task> {
        val localVarResponse = sourcesLdapSyncStatusListWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Task>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get source&#39;s sync status
     * @param slug 
     * @return ApiResponse<kotlin.collections.List<Task>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesLdapSyncStatusListWithHttpInfo(slug: kotlin.String) : ApiResponse<kotlin.collections.List<Task>?> {
        val localVariableConfig = sourcesLdapSyncStatusListRequestConfig(slug = slug)

        return request<Unit, kotlin.collections.List<Task>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesLdapSyncStatusList
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesLdapSyncStatusListRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/ldap/{slug}/sync_status/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * LDAP Source Viewset
     * @param slug 
     * @param ldAPSourceRequest 
     * @return LDAPSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesLdapUpdate(slug: kotlin.String, ldAPSourceRequest: LDAPSourceRequest) : LDAPSource {
        val localVarResponse = sourcesLdapUpdateWithHttpInfo(slug = slug, ldAPSourceRequest = ldAPSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LDAPSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * LDAP Source Viewset
     * @param slug 
     * @param ldAPSourceRequest 
     * @return ApiResponse<LDAPSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesLdapUpdateWithHttpInfo(slug: kotlin.String, ldAPSourceRequest: LDAPSourceRequest) : ApiResponse<LDAPSource?> {
        val localVariableConfig = sourcesLdapUpdateRequestConfig(slug = slug, ldAPSourceRequest = ldAPSourceRequest)

        return request<LDAPSourceRequest, LDAPSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesLdapUpdate
     *
     * @param slug 
     * @param ldAPSourceRequest 
     * @return RequestConfig
     */
    fun sourcesLdapUpdateRequestConfig(slug: kotlin.String, ldAPSourceRequest: LDAPSourceRequest) : RequestConfig<LDAPSourceRequest> {
        val localVariableBody = ldAPSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/sources/ldap/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesLdapUsedByList(slug: kotlin.String) : kotlin.collections.List<UsedBy> {
        val localVarResponse = sourcesLdapUsedByListWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesLdapUsedByListWithHttpInfo(slug: kotlin.String) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = sourcesLdapUsedByListRequestConfig(slug = slug)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesLdapUsedByList
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesLdapUsedByListRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/ldap/{slug}/used_by/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param oauthSourceRequest 
     * @return OAuthSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesOauthCreate(oauthSourceRequest: OAuthSourceRequest) : OAuthSource {
        val localVarResponse = sourcesOauthCreateWithHttpInfo(oauthSourceRequest = oauthSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OAuthSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param oauthSourceRequest 
     * @return ApiResponse<OAuthSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesOauthCreateWithHttpInfo(oauthSourceRequest: OAuthSourceRequest) : ApiResponse<OAuthSource?> {
        val localVariableConfig = sourcesOauthCreateRequestConfig(oauthSourceRequest = oauthSourceRequest)

        return request<OAuthSourceRequest, OAuthSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesOauthCreate
     *
     * @param oauthSourceRequest 
     * @return RequestConfig
     */
    fun sourcesOauthCreateRequestConfig(oauthSourceRequest: OAuthSourceRequest) : RequestConfig<OAuthSourceRequest> {
        val localVariableBody = oauthSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/sources/oauth/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesOauthDestroy(slug: kotlin.String) : Unit {
        val localVarResponse = sourcesOauthDestroyWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesOauthDestroyWithHttpInfo(slug: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesOauthDestroyRequestConfig(slug = slug)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesOauthDestroy
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesOauthDestroyRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/sources/oauth/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter policyEngineMode
     */
     enum class PolicyEngineMode_sourcesOauthList(val value: kotlin.String) {
         @Json(name = "all") all("all"),
         @Json(name = "any") any("any"),
     }

    /**
     * enum for parameter userMatchingMode
     */
     enum class UserMatchingMode_sourcesOauthList(val value: kotlin.String) {
         @Json(name = "email_deny") emailDeny("email_deny"),
         @Json(name = "email_link") emailLink("email_link"),
         @Json(name = "identifier") identifier("identifier"),
         @Json(name = "username_deny") usernameDeny("username_deny"),
         @Json(name = "username_link") usernameLink("username_link"),
     }

    /**
     * 
     * Source Viewset
     * @param accessTokenUrl  (optional)
     * @param additionalScopes  (optional)
     * @param authenticationFlow  (optional)
     * @param authorizationUrl  (optional)
     * @param consumerKey  (optional)
     * @param enabled  (optional)
     * @param enrollmentFlow  (optional)
     * @param hasJwks Only return sources with JWKS data (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param profileUrl  (optional)
     * @param providerType  (optional)
     * @param requestTokenUrl  (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @param userMatchingMode How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
     * @return PaginatedOAuthSourceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesOauthList(accessTokenUrl: kotlin.String? = null, additionalScopes: kotlin.String? = null, authenticationFlow: java.util.UUID? = null, authorizationUrl: kotlin.String? = null, consumerKey: kotlin.String? = null, enabled: kotlin.Boolean? = null, enrollmentFlow: java.util.UUID? = null, hasJwks: kotlin.Boolean? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, policyEngineMode: PolicyEngineMode_sourcesOauthList? = null, profileUrl: kotlin.String? = null, providerType: kotlin.String? = null, requestTokenUrl: kotlin.String? = null, search: kotlin.String? = null, slug: kotlin.String? = null, userMatchingMode: UserMatchingMode_sourcesOauthList? = null) : PaginatedOAuthSourceList {
        val localVarResponse = sourcesOauthListWithHttpInfo(accessTokenUrl = accessTokenUrl, additionalScopes = additionalScopes, authenticationFlow = authenticationFlow, authorizationUrl = authorizationUrl, consumerKey = consumerKey, enabled = enabled, enrollmentFlow = enrollmentFlow, hasJwks = hasJwks, name = name, ordering = ordering, page = page, pageSize = pageSize, policyEngineMode = policyEngineMode, profileUrl = profileUrl, providerType = providerType, requestTokenUrl = requestTokenUrl, search = search, slug = slug, userMatchingMode = userMatchingMode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedOAuthSourceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param accessTokenUrl  (optional)
     * @param additionalScopes  (optional)
     * @param authenticationFlow  (optional)
     * @param authorizationUrl  (optional)
     * @param consumerKey  (optional)
     * @param enabled  (optional)
     * @param enrollmentFlow  (optional)
     * @param hasJwks Only return sources with JWKS data (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param profileUrl  (optional)
     * @param providerType  (optional)
     * @param requestTokenUrl  (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @param userMatchingMode How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
     * @return ApiResponse<PaginatedOAuthSourceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesOauthListWithHttpInfo(accessTokenUrl: kotlin.String?, additionalScopes: kotlin.String?, authenticationFlow: java.util.UUID?, authorizationUrl: kotlin.String?, consumerKey: kotlin.String?, enabled: kotlin.Boolean?, enrollmentFlow: java.util.UUID?, hasJwks: kotlin.Boolean?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyEngineMode: PolicyEngineMode_sourcesOauthList?, profileUrl: kotlin.String?, providerType: kotlin.String?, requestTokenUrl: kotlin.String?, search: kotlin.String?, slug: kotlin.String?, userMatchingMode: UserMatchingMode_sourcesOauthList?) : ApiResponse<PaginatedOAuthSourceList?> {
        val localVariableConfig = sourcesOauthListRequestConfig(accessTokenUrl = accessTokenUrl, additionalScopes = additionalScopes, authenticationFlow = authenticationFlow, authorizationUrl = authorizationUrl, consumerKey = consumerKey, enabled = enabled, enrollmentFlow = enrollmentFlow, hasJwks = hasJwks, name = name, ordering = ordering, page = page, pageSize = pageSize, policyEngineMode = policyEngineMode, profileUrl = profileUrl, providerType = providerType, requestTokenUrl = requestTokenUrl, search = search, slug = slug, userMatchingMode = userMatchingMode)

        return request<Unit, PaginatedOAuthSourceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesOauthList
     *
     * @param accessTokenUrl  (optional)
     * @param additionalScopes  (optional)
     * @param authenticationFlow  (optional)
     * @param authorizationUrl  (optional)
     * @param consumerKey  (optional)
     * @param enabled  (optional)
     * @param enrollmentFlow  (optional)
     * @param hasJwks Only return sources with JWKS data (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param profileUrl  (optional)
     * @param providerType  (optional)
     * @param requestTokenUrl  (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @param userMatchingMode How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
     * @return RequestConfig
     */
    fun sourcesOauthListRequestConfig(accessTokenUrl: kotlin.String?, additionalScopes: kotlin.String?, authenticationFlow: java.util.UUID?, authorizationUrl: kotlin.String?, consumerKey: kotlin.String?, enabled: kotlin.Boolean?, enrollmentFlow: java.util.UUID?, hasJwks: kotlin.Boolean?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyEngineMode: PolicyEngineMode_sourcesOauthList?, profileUrl: kotlin.String?, providerType: kotlin.String?, requestTokenUrl: kotlin.String?, search: kotlin.String?, slug: kotlin.String?, userMatchingMode: UserMatchingMode_sourcesOauthList?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accessTokenUrl != null) {
                    put("access_token_url", listOf(accessTokenUrl.toString()))
                }
                if (additionalScopes != null) {
                    put("additional_scopes", listOf(additionalScopes.toString()))
                }
                if (authenticationFlow != null) {
                    put("authentication_flow", listOf(authenticationFlow.toString()))
                }
                if (authorizationUrl != null) {
                    put("authorization_url", listOf(authorizationUrl.toString()))
                }
                if (consumerKey != null) {
                    put("consumer_key", listOf(consumerKey.toString()))
                }
                if (enabled != null) {
                    put("enabled", listOf(enabled.toString()))
                }
                if (enrollmentFlow != null) {
                    put("enrollment_flow", listOf(enrollmentFlow.toString()))
                }
                if (hasJwks != null) {
                    put("has_jwks", listOf(hasJwks.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (policyEngineMode != null) {
                    put("policy_engine_mode", listOf(policyEngineMode.toString()))
                }
                if (profileUrl != null) {
                    put("profile_url", listOf(profileUrl.toString()))
                }
                if (providerType != null) {
                    put("provider_type", listOf(providerType.toString()))
                }
                if (requestTokenUrl != null) {
                    put("request_token_url", listOf(requestTokenUrl.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (slug != null) {
                    put("slug", listOf(slug.toString()))
                }
                if (userMatchingMode != null) {
                    put("user_matching_mode", listOf(userMatchingMode.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/oauth/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @param patchedOAuthSourceRequest  (optional)
     * @return OAuthSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesOauthPartialUpdate(slug: kotlin.String, patchedOAuthSourceRequest: PatchedOAuthSourceRequest? = null) : OAuthSource {
        val localVarResponse = sourcesOauthPartialUpdateWithHttpInfo(slug = slug, patchedOAuthSourceRequest = patchedOAuthSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OAuthSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @param patchedOAuthSourceRequest  (optional)
     * @return ApiResponse<OAuthSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesOauthPartialUpdateWithHttpInfo(slug: kotlin.String, patchedOAuthSourceRequest: PatchedOAuthSourceRequest?) : ApiResponse<OAuthSource?> {
        val localVariableConfig = sourcesOauthPartialUpdateRequestConfig(slug = slug, patchedOAuthSourceRequest = patchedOAuthSourceRequest)

        return request<PatchedOAuthSourceRequest, OAuthSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesOauthPartialUpdate
     *
     * @param slug 
     * @param patchedOAuthSourceRequest  (optional)
     * @return RequestConfig
     */
    fun sourcesOauthPartialUpdateRequestConfig(slug: kotlin.String, patchedOAuthSourceRequest: PatchedOAuthSourceRequest?) : RequestConfig<PatchedOAuthSourceRequest> {
        val localVariableBody = patchedOAuthSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/sources/oauth/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @return OAuthSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesOauthRetrieve(slug: kotlin.String) : OAuthSource {
        val localVarResponse = sourcesOauthRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OAuthSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @return ApiResponse<OAuthSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesOauthRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<OAuthSource?> {
        val localVariableConfig = sourcesOauthRetrieveRequestConfig(slug = slug)

        return request<Unit, OAuthSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesOauthRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesOauthRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/oauth/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get all creatable source types. If ?name is set, only returns the type for &lt;name&gt;. If &lt;name&gt; isn&#39;t found, returns the default type.
     * @param name  (optional)
     * @return kotlin.collections.List<SourceType>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesOauthSourceTypesList(name: kotlin.String? = null) : kotlin.collections.List<SourceType> {
        val localVarResponse = sourcesOauthSourceTypesListWithHttpInfo(name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SourceType>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all creatable source types. If ?name is set, only returns the type for &lt;name&gt;. If &lt;name&gt; isn&#39;t found, returns the default type.
     * @param name  (optional)
     * @return ApiResponse<kotlin.collections.List<SourceType>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesOauthSourceTypesListWithHttpInfo(name: kotlin.String?) : ApiResponse<kotlin.collections.List<SourceType>?> {
        val localVariableConfig = sourcesOauthSourceTypesListRequestConfig(name = name)

        return request<Unit, kotlin.collections.List<SourceType>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesOauthSourceTypesList
     *
     * @param name  (optional)
     * @return RequestConfig
     */
    fun sourcesOauthSourceTypesListRequestConfig(name: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/oauth/source_types/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @param oauthSourceRequest 
     * @return OAuthSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesOauthUpdate(slug: kotlin.String, oauthSourceRequest: OAuthSourceRequest) : OAuthSource {
        val localVarResponse = sourcesOauthUpdateWithHttpInfo(slug = slug, oauthSourceRequest = oauthSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OAuthSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param slug 
     * @param oauthSourceRequest 
     * @return ApiResponse<OAuthSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesOauthUpdateWithHttpInfo(slug: kotlin.String, oauthSourceRequest: OAuthSourceRequest) : ApiResponse<OAuthSource?> {
        val localVariableConfig = sourcesOauthUpdateRequestConfig(slug = slug, oauthSourceRequest = oauthSourceRequest)

        return request<OAuthSourceRequest, OAuthSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesOauthUpdate
     *
     * @param slug 
     * @param oauthSourceRequest 
     * @return RequestConfig
     */
    fun sourcesOauthUpdateRequestConfig(slug: kotlin.String, oauthSourceRequest: OAuthSourceRequest) : RequestConfig<OAuthSourceRequest> {
        val localVariableBody = oauthSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/sources/oauth/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesOauthUsedByList(slug: kotlin.String) : kotlin.collections.List<UsedBy> {
        val localVarResponse = sourcesOauthUsedByListWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesOauthUsedByListWithHttpInfo(slug: kotlin.String) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = sourcesOauthUsedByListRequestConfig(slug = slug)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesOauthUsedByList
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesOauthUsedByListRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/oauth/{slug}/used_by/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Plex source Viewset
     * @param plexSourceRequest 
     * @return PlexSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesPlexCreate(plexSourceRequest: PlexSourceRequest) : PlexSource {
        val localVarResponse = sourcesPlexCreateWithHttpInfo(plexSourceRequest = plexSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PlexSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex source Viewset
     * @param plexSourceRequest 
     * @return ApiResponse<PlexSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesPlexCreateWithHttpInfo(plexSourceRequest: PlexSourceRequest) : ApiResponse<PlexSource?> {
        val localVariableConfig = sourcesPlexCreateRequestConfig(plexSourceRequest = plexSourceRequest)

        return request<PlexSourceRequest, PlexSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesPlexCreate
     *
     * @param plexSourceRequest 
     * @return RequestConfig
     */
    fun sourcesPlexCreateRequestConfig(plexSourceRequest: PlexSourceRequest) : RequestConfig<PlexSourceRequest> {
        val localVariableBody = plexSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/sources/plex/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Plex source Viewset
     * @param slug 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesPlexDestroy(slug: kotlin.String) : Unit {
        val localVarResponse = sourcesPlexDestroyWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex source Viewset
     * @param slug 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesPlexDestroyWithHttpInfo(slug: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesPlexDestroyRequestConfig(slug = slug)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesPlexDestroy
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesPlexDestroyRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/sources/plex/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter policyEngineMode
     */
     enum class PolicyEngineMode_sourcesPlexList(val value: kotlin.String) {
         @Json(name = "all") all("all"),
         @Json(name = "any") any("any"),
     }

    /**
     * enum for parameter userMatchingMode
     */
     enum class UserMatchingMode_sourcesPlexList(val value: kotlin.String) {
         @Json(name = "email_deny") emailDeny("email_deny"),
         @Json(name = "email_link") emailLink("email_link"),
         @Json(name = "identifier") identifier("identifier"),
         @Json(name = "username_deny") usernameDeny("username_deny"),
         @Json(name = "username_link") usernameLink("username_link"),
     }

    /**
     * 
     * Plex source Viewset
     * @param allowFriends  (optional)
     * @param authenticationFlow  (optional)
     * @param clientId  (optional)
     * @param enabled  (optional)
     * @param enrollmentFlow  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @param userMatchingMode How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
     * @return PaginatedPlexSourceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesPlexList(allowFriends: kotlin.Boolean? = null, authenticationFlow: java.util.UUID? = null, clientId: kotlin.String? = null, enabled: kotlin.Boolean? = null, enrollmentFlow: java.util.UUID? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, policyEngineMode: PolicyEngineMode_sourcesPlexList? = null, search: kotlin.String? = null, slug: kotlin.String? = null, userMatchingMode: UserMatchingMode_sourcesPlexList? = null) : PaginatedPlexSourceList {
        val localVarResponse = sourcesPlexListWithHttpInfo(allowFriends = allowFriends, authenticationFlow = authenticationFlow, clientId = clientId, enabled = enabled, enrollmentFlow = enrollmentFlow, name = name, ordering = ordering, page = page, pageSize = pageSize, policyEngineMode = policyEngineMode, search = search, slug = slug, userMatchingMode = userMatchingMode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPlexSourceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex source Viewset
     * @param allowFriends  (optional)
     * @param authenticationFlow  (optional)
     * @param clientId  (optional)
     * @param enabled  (optional)
     * @param enrollmentFlow  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @param userMatchingMode How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
     * @return ApiResponse<PaginatedPlexSourceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesPlexListWithHttpInfo(allowFriends: kotlin.Boolean?, authenticationFlow: java.util.UUID?, clientId: kotlin.String?, enabled: kotlin.Boolean?, enrollmentFlow: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyEngineMode: PolicyEngineMode_sourcesPlexList?, search: kotlin.String?, slug: kotlin.String?, userMatchingMode: UserMatchingMode_sourcesPlexList?) : ApiResponse<PaginatedPlexSourceList?> {
        val localVariableConfig = sourcesPlexListRequestConfig(allowFriends = allowFriends, authenticationFlow = authenticationFlow, clientId = clientId, enabled = enabled, enrollmentFlow = enrollmentFlow, name = name, ordering = ordering, page = page, pageSize = pageSize, policyEngineMode = policyEngineMode, search = search, slug = slug, userMatchingMode = userMatchingMode)

        return request<Unit, PaginatedPlexSourceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesPlexList
     *
     * @param allowFriends  (optional)
     * @param authenticationFlow  (optional)
     * @param clientId  (optional)
     * @param enabled  (optional)
     * @param enrollmentFlow  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param search A search term. (optional)
     * @param slug  (optional)
     * @param userMatchingMode How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
     * @return RequestConfig
     */
    fun sourcesPlexListRequestConfig(allowFriends: kotlin.Boolean?, authenticationFlow: java.util.UUID?, clientId: kotlin.String?, enabled: kotlin.Boolean?, enrollmentFlow: java.util.UUID?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyEngineMode: PolicyEngineMode_sourcesPlexList?, search: kotlin.String?, slug: kotlin.String?, userMatchingMode: UserMatchingMode_sourcesPlexList?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (allowFriends != null) {
                    put("allow_friends", listOf(allowFriends.toString()))
                }
                if (authenticationFlow != null) {
                    put("authentication_flow", listOf(authenticationFlow.toString()))
                }
                if (clientId != null) {
                    put("client_id", listOf(clientId.toString()))
                }
                if (enabled != null) {
                    put("enabled", listOf(enabled.toString()))
                }
                if (enrollmentFlow != null) {
                    put("enrollment_flow", listOf(enrollmentFlow.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (policyEngineMode != null) {
                    put("policy_engine_mode", listOf(policyEngineMode.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (slug != null) {
                    put("slug", listOf(slug.toString()))
                }
                if (userMatchingMode != null) {
                    put("user_matching_mode", listOf(userMatchingMode.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/plex/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Plex source Viewset
     * @param slug 
     * @param patchedPlexSourceRequest  (optional)
     * @return PlexSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesPlexPartialUpdate(slug: kotlin.String, patchedPlexSourceRequest: PatchedPlexSourceRequest? = null) : PlexSource {
        val localVarResponse = sourcesPlexPartialUpdateWithHttpInfo(slug = slug, patchedPlexSourceRequest = patchedPlexSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PlexSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex source Viewset
     * @param slug 
     * @param patchedPlexSourceRequest  (optional)
     * @return ApiResponse<PlexSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesPlexPartialUpdateWithHttpInfo(slug: kotlin.String, patchedPlexSourceRequest: PatchedPlexSourceRequest?) : ApiResponse<PlexSource?> {
        val localVariableConfig = sourcesPlexPartialUpdateRequestConfig(slug = slug, patchedPlexSourceRequest = patchedPlexSourceRequest)

        return request<PatchedPlexSourceRequest, PlexSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesPlexPartialUpdate
     *
     * @param slug 
     * @param patchedPlexSourceRequest  (optional)
     * @return RequestConfig
     */
    fun sourcesPlexPartialUpdateRequestConfig(slug: kotlin.String, patchedPlexSourceRequest: PatchedPlexSourceRequest?) : RequestConfig<PatchedPlexSourceRequest> {
        val localVariableBody = patchedPlexSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/sources/plex/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Redeem a plex token for an authenticated user, creating a connection
     * @param plexTokenRedeemRequest 
     * @param slug  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesPlexRedeemTokenAuthenticatedCreate(plexTokenRedeemRequest: PlexTokenRedeemRequest, slug: kotlin.String? = null) : Unit {
        val localVarResponse = sourcesPlexRedeemTokenAuthenticatedCreateWithHttpInfo(plexTokenRedeemRequest = plexTokenRedeemRequest, slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Redeem a plex token for an authenticated user, creating a connection
     * @param plexTokenRedeemRequest 
     * @param slug  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesPlexRedeemTokenAuthenticatedCreateWithHttpInfo(plexTokenRedeemRequest: PlexTokenRedeemRequest, slug: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesPlexRedeemTokenAuthenticatedCreateRequestConfig(plexTokenRedeemRequest = plexTokenRedeemRequest, slug = slug)

        return request<PlexTokenRedeemRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesPlexRedeemTokenAuthenticatedCreate
     *
     * @param plexTokenRedeemRequest 
     * @param slug  (optional)
     * @return RequestConfig
     */
    fun sourcesPlexRedeemTokenAuthenticatedCreateRequestConfig(plexTokenRedeemRequest: PlexTokenRedeemRequest, slug: kotlin.String?) : RequestConfig<PlexTokenRedeemRequest> {
        val localVariableBody = plexTokenRedeemRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (slug != null) {
                    put("slug", listOf(slug.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/sources/plex/redeem_token_authenticated/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Redeem a plex token, check it&#39;s access to resources against what&#39;s allowed for the source, and redirect to an authentication/enrollment flow.
     * @param plexTokenRedeemRequest 
     * @param slug  (optional)
     * @return RedirectChallenge
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesPlexRedeemTokenCreate(plexTokenRedeemRequest: PlexTokenRedeemRequest, slug: kotlin.String? = null) : RedirectChallenge {
        val localVarResponse = sourcesPlexRedeemTokenCreateWithHttpInfo(plexTokenRedeemRequest = plexTokenRedeemRequest, slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RedirectChallenge
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Redeem a plex token, check it&#39;s access to resources against what&#39;s allowed for the source, and redirect to an authentication/enrollment flow.
     * @param plexTokenRedeemRequest 
     * @param slug  (optional)
     * @return ApiResponse<RedirectChallenge?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesPlexRedeemTokenCreateWithHttpInfo(plexTokenRedeemRequest: PlexTokenRedeemRequest, slug: kotlin.String?) : ApiResponse<RedirectChallenge?> {
        val localVariableConfig = sourcesPlexRedeemTokenCreateRequestConfig(plexTokenRedeemRequest = plexTokenRedeemRequest, slug = slug)

        return request<PlexTokenRedeemRequest, RedirectChallenge>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesPlexRedeemTokenCreate
     *
     * @param plexTokenRedeemRequest 
     * @param slug  (optional)
     * @return RequestConfig
     */
    fun sourcesPlexRedeemTokenCreateRequestConfig(plexTokenRedeemRequest: PlexTokenRedeemRequest, slug: kotlin.String?) : RequestConfig<PlexTokenRedeemRequest> {
        val localVariableBody = plexTokenRedeemRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (slug != null) {
                    put("slug", listOf(slug.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/sources/plex/redeem_token/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Plex source Viewset
     * @param slug 
     * @return PlexSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesPlexRetrieve(slug: kotlin.String) : PlexSource {
        val localVarResponse = sourcesPlexRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PlexSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex source Viewset
     * @param slug 
     * @return ApiResponse<PlexSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesPlexRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<PlexSource?> {
        val localVariableConfig = sourcesPlexRetrieveRequestConfig(slug = slug)

        return request<Unit, PlexSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesPlexRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesPlexRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/plex/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Plex source Viewset
     * @param slug 
     * @param plexSourceRequest 
     * @return PlexSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesPlexUpdate(slug: kotlin.String, plexSourceRequest: PlexSourceRequest) : PlexSource {
        val localVarResponse = sourcesPlexUpdateWithHttpInfo(slug = slug, plexSourceRequest = plexSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PlexSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex source Viewset
     * @param slug 
     * @param plexSourceRequest 
     * @return ApiResponse<PlexSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesPlexUpdateWithHttpInfo(slug: kotlin.String, plexSourceRequest: PlexSourceRequest) : ApiResponse<PlexSource?> {
        val localVariableConfig = sourcesPlexUpdateRequestConfig(slug = slug, plexSourceRequest = plexSourceRequest)

        return request<PlexSourceRequest, PlexSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesPlexUpdate
     *
     * @param slug 
     * @param plexSourceRequest 
     * @return RequestConfig
     */
    fun sourcesPlexUpdateRequestConfig(slug: kotlin.String, plexSourceRequest: PlexSourceRequest) : RequestConfig<PlexSourceRequest> {
        val localVariableBody = plexSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/sources/plex/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesPlexUsedByList(slug: kotlin.String) : kotlin.collections.List<UsedBy> {
        val localVarResponse = sourcesPlexUsedByListWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesPlexUsedByListWithHttpInfo(slug: kotlin.String) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = sourcesPlexUsedByListRequestConfig(slug = slug)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesPlexUsedByList
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesPlexUsedByListRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/plex/{slug}/used_by/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLSource Viewset
     * @param saMLSourceRequest 
     * @return SAMLSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesSamlCreate(saMLSourceRequest: SAMLSourceRequest) : SAMLSource {
        val localVarResponse = sourcesSamlCreateWithHttpInfo(saMLSourceRequest = saMLSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLSource Viewset
     * @param saMLSourceRequest 
     * @return ApiResponse<SAMLSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesSamlCreateWithHttpInfo(saMLSourceRequest: SAMLSourceRequest) : ApiResponse<SAMLSource?> {
        val localVariableConfig = sourcesSamlCreateRequestConfig(saMLSourceRequest = saMLSourceRequest)

        return request<SAMLSourceRequest, SAMLSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesSamlCreate
     *
     * @param saMLSourceRequest 
     * @return RequestConfig
     */
    fun sourcesSamlCreateRequestConfig(saMLSourceRequest: SAMLSourceRequest) : RequestConfig<SAMLSourceRequest> {
        val localVariableBody = saMLSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/sources/saml/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLSource Viewset
     * @param slug 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesSamlDestroy(slug: kotlin.String) : Unit {
        val localVarResponse = sourcesSamlDestroyWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLSource Viewset
     * @param slug 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesSamlDestroyWithHttpInfo(slug: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesSamlDestroyRequestConfig(slug = slug)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesSamlDestroy
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesSamlDestroyRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/sources/saml/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter bindingType
     */
     enum class BindingType_sourcesSamlList(val value: kotlin.String) {
         @Json(name = "POST") pOST("POST"),
         @Json(name = "POST_AUTO") pOSTAUTO("POST_AUTO"),
         @Json(name = "REDIRECT") rEDIRECT("REDIRECT"),
     }

    /**
     * enum for parameter digestAlgorithm
     */
     enum class DigestAlgorithm_sourcesSamlList(val value: kotlin.String) {
         @Json(name = "http://www.w3.org/2000/09/xmldsig#sha1") _2000slash09SlashXmldsigHashSha1("http://www.w3.org/2000/09/xmldsig#sha1"),
         @Json(name = "http://www.w3.org/2001/04/xmldsig-more#sha384") _2001slash04SlashXmldsigMinusMoreHashSha384("http://www.w3.org/2001/04/xmldsig-more#sha384"),
         @Json(name = "http://www.w3.org/2001/04/xmlenc#sha256") _2001slash04SlashXmlencHashSha256("http://www.w3.org/2001/04/xmlenc#sha256"),
         @Json(name = "http://www.w3.org/2001/04/xmlenc#sha512") _2001slash04SlashXmlencHashSha512("http://www.w3.org/2001/04/xmlenc#sha512"),
     }

    /**
     * enum for parameter nameIdPolicy
     */
     enum class NameIdPolicy_sourcesSamlList(val value: kotlin.String) {
         @Json(name = "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress") _1period1ColonNameidMinusFormatColonEmailAddress("urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"),
         @Json(name = "urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName") _2period0ColonNameidMinusFormatColonWindowsDomainQualifiedName("urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName"),
         @Json(name = "urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName") _2period0ColonNameidMinusFormatColonX509SubjectName("urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName"),
         @Json(name = "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent") _2period0ColonNameidMinusFormatColonPersistent("urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"),
         @Json(name = "urn:oasis:names:tc:SAML:2.0:nameid-format:transient") _2period0ColonNameidMinusFormatColonTransient("urn:oasis:names:tc:SAML:2.0:nameid-format:transient"),
     }

    /**
     * enum for parameter policyEngineMode
     */
     enum class PolicyEngineMode_sourcesSamlList(val value: kotlin.String) {
         @Json(name = "all") all("all"),
         @Json(name = "any") any("any"),
     }

    /**
     * enum for parameter signatureAlgorithm
     */
     enum class SignatureAlgorithm_sourcesSamlList(val value: kotlin.String) {
         @Json(name = "http://www.w3.org/2000/09/xmldsig#dsa-sha1") _2000slash09SlashXmldsigHashDsaMinusSha1("http://www.w3.org/2000/09/xmldsig#dsa-sha1"),
         @Json(name = "http://www.w3.org/2000/09/xmldsig#rsa-sha1") _2000slash09SlashXmldsigHashRsaMinusSha1("http://www.w3.org/2000/09/xmldsig#rsa-sha1"),
         @Json(name = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256") _2001slash04SlashXmldsigMinusMoreHashRsaMinusSha256("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"),
         @Json(name = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384") _2001slash04SlashXmldsigMinusMoreHashRsaMinusSha384("http://www.w3.org/2001/04/xmldsig-more#rsa-sha384"),
         @Json(name = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512") _2001slash04SlashXmldsigMinusMoreHashRsaMinusSha512("http://www.w3.org/2001/04/xmldsig-more#rsa-sha512"),
     }

    /**
     * enum for parameter userMatchingMode
     */
     enum class UserMatchingMode_sourcesSamlList(val value: kotlin.String) {
         @Json(name = "email_deny") emailDeny("email_deny"),
         @Json(name = "email_link") emailLink("email_link"),
         @Json(name = "identifier") identifier("identifier"),
         @Json(name = "username_deny") usernameDeny("username_deny"),
         @Json(name = "username_link") usernameLink("username_link"),
     }

    /**
     * 
     * SAMLSource Viewset
     * @param allowIdpInitiated  (optional)
     * @param authenticationFlow  (optional)
     * @param bindingType * &#x60;REDIRECT&#x60; - Redirect Binding * &#x60;POST&#x60; - POST Binding * &#x60;POST_AUTO&#x60; - POST Binding with auto-confirmation (optional)
     * @param digestAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#sha1&#x60; - SHA1 * &#x60;http://www.w3.org/2001/04/xmlenc#sha256&#x60; - SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#sha384&#x60; - SHA384 * &#x60;http://www.w3.org/2001/04/xmlenc#sha512&#x60; - SHA512 (optional)
     * @param enabled  (optional)
     * @param enrollmentFlow  (optional)
     * @param issuer  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param nameIdPolicy NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.  * &#x60;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#x60; - Email * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:persistent&#x60; - Persistent * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName&#x60; - X509 * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName&#x60; - Windows * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:transient&#x60; - Transient (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param preAuthenticationFlow  (optional)
     * @param search A search term. (optional)
     * @param signatureAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#rsa-sha1&#x60; - RSA-SHA1 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha256&#x60; - RSA-SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha384&#x60; - RSA-SHA384 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha512&#x60; - RSA-SHA512 * &#x60;http://www.w3.org/2000/09/xmldsig#dsa-sha1&#x60; - DSA-SHA1 (optional)
     * @param signingKp  (optional)
     * @param sloUrl  (optional)
     * @param slug  (optional)
     * @param ssoUrl  (optional)
     * @param temporaryUserDeleteAfter  (optional)
     * @param userMatchingMode How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
     * @param verificationKp  (optional)
     * @return PaginatedSAMLSourceList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesSamlList(allowIdpInitiated: kotlin.Boolean? = null, authenticationFlow: java.util.UUID? = null, bindingType: BindingType_sourcesSamlList? = null, digestAlgorithm: DigestAlgorithm_sourcesSamlList? = null, enabled: kotlin.Boolean? = null, enrollmentFlow: java.util.UUID? = null, issuer: kotlin.String? = null, managed: kotlin.String? = null, name: kotlin.String? = null, nameIdPolicy: NameIdPolicy_sourcesSamlList? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, policyEngineMode: PolicyEngineMode_sourcesSamlList? = null, preAuthenticationFlow: java.util.UUID? = null, search: kotlin.String? = null, signatureAlgorithm: SignatureAlgorithm_sourcesSamlList? = null, signingKp: java.util.UUID? = null, sloUrl: kotlin.String? = null, slug: kotlin.String? = null, ssoUrl: kotlin.String? = null, temporaryUserDeleteAfter: kotlin.String? = null, userMatchingMode: UserMatchingMode_sourcesSamlList? = null, verificationKp: java.util.UUID? = null) : PaginatedSAMLSourceList {
        val localVarResponse = sourcesSamlListWithHttpInfo(allowIdpInitiated = allowIdpInitiated, authenticationFlow = authenticationFlow, bindingType = bindingType, digestAlgorithm = digestAlgorithm, enabled = enabled, enrollmentFlow = enrollmentFlow, issuer = issuer, managed = managed, name = name, nameIdPolicy = nameIdPolicy, ordering = ordering, page = page, pageSize = pageSize, policyEngineMode = policyEngineMode, preAuthenticationFlow = preAuthenticationFlow, search = search, signatureAlgorithm = signatureAlgorithm, signingKp = signingKp, sloUrl = sloUrl, slug = slug, ssoUrl = ssoUrl, temporaryUserDeleteAfter = temporaryUserDeleteAfter, userMatchingMode = userMatchingMode, verificationKp = verificationKp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedSAMLSourceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLSource Viewset
     * @param allowIdpInitiated  (optional)
     * @param authenticationFlow  (optional)
     * @param bindingType * &#x60;REDIRECT&#x60; - Redirect Binding * &#x60;POST&#x60; - POST Binding * &#x60;POST_AUTO&#x60; - POST Binding with auto-confirmation (optional)
     * @param digestAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#sha1&#x60; - SHA1 * &#x60;http://www.w3.org/2001/04/xmlenc#sha256&#x60; - SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#sha384&#x60; - SHA384 * &#x60;http://www.w3.org/2001/04/xmlenc#sha512&#x60; - SHA512 (optional)
     * @param enabled  (optional)
     * @param enrollmentFlow  (optional)
     * @param issuer  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param nameIdPolicy NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.  * &#x60;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#x60; - Email * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:persistent&#x60; - Persistent * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName&#x60; - X509 * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName&#x60; - Windows * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:transient&#x60; - Transient (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param preAuthenticationFlow  (optional)
     * @param search A search term. (optional)
     * @param signatureAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#rsa-sha1&#x60; - RSA-SHA1 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha256&#x60; - RSA-SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha384&#x60; - RSA-SHA384 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha512&#x60; - RSA-SHA512 * &#x60;http://www.w3.org/2000/09/xmldsig#dsa-sha1&#x60; - DSA-SHA1 (optional)
     * @param signingKp  (optional)
     * @param sloUrl  (optional)
     * @param slug  (optional)
     * @param ssoUrl  (optional)
     * @param temporaryUserDeleteAfter  (optional)
     * @param userMatchingMode How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
     * @param verificationKp  (optional)
     * @return ApiResponse<PaginatedSAMLSourceList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesSamlListWithHttpInfo(allowIdpInitiated: kotlin.Boolean?, authenticationFlow: java.util.UUID?, bindingType: BindingType_sourcesSamlList?, digestAlgorithm: DigestAlgorithm_sourcesSamlList?, enabled: kotlin.Boolean?, enrollmentFlow: java.util.UUID?, issuer: kotlin.String?, managed: kotlin.String?, name: kotlin.String?, nameIdPolicy: NameIdPolicy_sourcesSamlList?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyEngineMode: PolicyEngineMode_sourcesSamlList?, preAuthenticationFlow: java.util.UUID?, search: kotlin.String?, signatureAlgorithm: SignatureAlgorithm_sourcesSamlList?, signingKp: java.util.UUID?, sloUrl: kotlin.String?, slug: kotlin.String?, ssoUrl: kotlin.String?, temporaryUserDeleteAfter: kotlin.String?, userMatchingMode: UserMatchingMode_sourcesSamlList?, verificationKp: java.util.UUID?) : ApiResponse<PaginatedSAMLSourceList?> {
        val localVariableConfig = sourcesSamlListRequestConfig(allowIdpInitiated = allowIdpInitiated, authenticationFlow = authenticationFlow, bindingType = bindingType, digestAlgorithm = digestAlgorithm, enabled = enabled, enrollmentFlow = enrollmentFlow, issuer = issuer, managed = managed, name = name, nameIdPolicy = nameIdPolicy, ordering = ordering, page = page, pageSize = pageSize, policyEngineMode = policyEngineMode, preAuthenticationFlow = preAuthenticationFlow, search = search, signatureAlgorithm = signatureAlgorithm, signingKp = signingKp, sloUrl = sloUrl, slug = slug, ssoUrl = ssoUrl, temporaryUserDeleteAfter = temporaryUserDeleteAfter, userMatchingMode = userMatchingMode, verificationKp = verificationKp)

        return request<Unit, PaginatedSAMLSourceList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesSamlList
     *
     * @param allowIdpInitiated  (optional)
     * @param authenticationFlow  (optional)
     * @param bindingType * &#x60;REDIRECT&#x60; - Redirect Binding * &#x60;POST&#x60; - POST Binding * &#x60;POST_AUTO&#x60; - POST Binding with auto-confirmation (optional)
     * @param digestAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#sha1&#x60; - SHA1 * &#x60;http://www.w3.org/2001/04/xmlenc#sha256&#x60; - SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#sha384&#x60; - SHA384 * &#x60;http://www.w3.org/2001/04/xmlenc#sha512&#x60; - SHA512 (optional)
     * @param enabled  (optional)
     * @param enrollmentFlow  (optional)
     * @param issuer  (optional)
     * @param managed  (optional)
     * @param name  (optional)
     * @param nameIdPolicy NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.  * &#x60;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&#x60; - Email * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:persistent&#x60; - Persistent * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName&#x60; - X509 * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName&#x60; - Windows * &#x60;urn:oasis:names:tc:SAML:2.0:nameid-format:transient&#x60; - Transient (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param policyEngineMode * &#x60;all&#x60; - all, all policies must pass * &#x60;any&#x60; - any, any policy must pass (optional)
     * @param preAuthenticationFlow  (optional)
     * @param search A search term. (optional)
     * @param signatureAlgorithm * &#x60;http://www.w3.org/2000/09/xmldsig#rsa-sha1&#x60; - RSA-SHA1 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha256&#x60; - RSA-SHA256 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha384&#x60; - RSA-SHA384 * &#x60;http://www.w3.org/2001/04/xmldsig-more#rsa-sha512&#x60; - RSA-SHA512 * &#x60;http://www.w3.org/2000/09/xmldsig#dsa-sha1&#x60; - DSA-SHA1 (optional)
     * @param signingKp  (optional)
     * @param sloUrl  (optional)
     * @param slug  (optional)
     * @param ssoUrl  (optional)
     * @param temporaryUserDeleteAfter  (optional)
     * @param userMatchingMode How the source determines if an existing user should be authenticated or a new user enrolled.  * &#x60;identifier&#x60; - Use the source-specific identifier * &#x60;email_link&#x60; - Link to a user with identical email address. Can have security implications when a source doesn&#39;t validate email addresses. * &#x60;email_deny&#x60; - Use the user&#39;s email address, but deny enrollment when the email address already exists. * &#x60;username_link&#x60; - Link to a user with identical username. Can have security implications when a username is used with another source. * &#x60;username_deny&#x60; - Use the user&#39;s username, but deny enrollment when the username already exists. (optional)
     * @param verificationKp  (optional)
     * @return RequestConfig
     */
    fun sourcesSamlListRequestConfig(allowIdpInitiated: kotlin.Boolean?, authenticationFlow: java.util.UUID?, bindingType: BindingType_sourcesSamlList?, digestAlgorithm: DigestAlgorithm_sourcesSamlList?, enabled: kotlin.Boolean?, enrollmentFlow: java.util.UUID?, issuer: kotlin.String?, managed: kotlin.String?, name: kotlin.String?, nameIdPolicy: NameIdPolicy_sourcesSamlList?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, policyEngineMode: PolicyEngineMode_sourcesSamlList?, preAuthenticationFlow: java.util.UUID?, search: kotlin.String?, signatureAlgorithm: SignatureAlgorithm_sourcesSamlList?, signingKp: java.util.UUID?, sloUrl: kotlin.String?, slug: kotlin.String?, ssoUrl: kotlin.String?, temporaryUserDeleteAfter: kotlin.String?, userMatchingMode: UserMatchingMode_sourcesSamlList?, verificationKp: java.util.UUID?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (allowIdpInitiated != null) {
                    put("allow_idp_initiated", listOf(allowIdpInitiated.toString()))
                }
                if (authenticationFlow != null) {
                    put("authentication_flow", listOf(authenticationFlow.toString()))
                }
                if (bindingType != null) {
                    put("binding_type", listOf(bindingType.toString()))
                }
                if (digestAlgorithm != null) {
                    put("digest_algorithm", listOf(digestAlgorithm.toString()))
                }
                if (enabled != null) {
                    put("enabled", listOf(enabled.toString()))
                }
                if (enrollmentFlow != null) {
                    put("enrollment_flow", listOf(enrollmentFlow.toString()))
                }
                if (issuer != null) {
                    put("issuer", listOf(issuer.toString()))
                }
                if (managed != null) {
                    put("managed", listOf(managed.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (nameIdPolicy != null) {
                    put("name_id_policy", listOf(nameIdPolicy.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (policyEngineMode != null) {
                    put("policy_engine_mode", listOf(policyEngineMode.toString()))
                }
                if (preAuthenticationFlow != null) {
                    put("pre_authentication_flow", listOf(preAuthenticationFlow.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (signatureAlgorithm != null) {
                    put("signature_algorithm", listOf(signatureAlgorithm.toString()))
                }
                if (signingKp != null) {
                    put("signing_kp", listOf(signingKp.toString()))
                }
                if (sloUrl != null) {
                    put("slo_url", listOf(sloUrl.toString()))
                }
                if (slug != null) {
                    put("slug", listOf(slug.toString()))
                }
                if (ssoUrl != null) {
                    put("sso_url", listOf(ssoUrl.toString()))
                }
                if (temporaryUserDeleteAfter != null) {
                    put("temporary_user_delete_after", listOf(temporaryUserDeleteAfter.toString()))
                }
                if (userMatchingMode != null) {
                    put("user_matching_mode", listOf(userMatchingMode.toString()))
                }
                if (verificationKp != null) {
                    put("verification_kp", listOf(verificationKp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/saml/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Return metadata as XML string
     * @param slug 
     * @return SAMLMetadata
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesSamlMetadataRetrieve(slug: kotlin.String) : SAMLMetadata {
        val localVarResponse = sourcesSamlMetadataRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLMetadata
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Return metadata as XML string
     * @param slug 
     * @return ApiResponse<SAMLMetadata?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesSamlMetadataRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<SAMLMetadata?> {
        val localVariableConfig = sourcesSamlMetadataRetrieveRequestConfig(slug = slug)

        return request<Unit, SAMLMetadata>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesSamlMetadataRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesSamlMetadataRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/saml/{slug}/metadata/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLSource Viewset
     * @param slug 
     * @param patchedSAMLSourceRequest  (optional)
     * @return SAMLSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesSamlPartialUpdate(slug: kotlin.String, patchedSAMLSourceRequest: PatchedSAMLSourceRequest? = null) : SAMLSource {
        val localVarResponse = sourcesSamlPartialUpdateWithHttpInfo(slug = slug, patchedSAMLSourceRequest = patchedSAMLSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLSource Viewset
     * @param slug 
     * @param patchedSAMLSourceRequest  (optional)
     * @return ApiResponse<SAMLSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesSamlPartialUpdateWithHttpInfo(slug: kotlin.String, patchedSAMLSourceRequest: PatchedSAMLSourceRequest?) : ApiResponse<SAMLSource?> {
        val localVariableConfig = sourcesSamlPartialUpdateRequestConfig(slug = slug, patchedSAMLSourceRequest = patchedSAMLSourceRequest)

        return request<PatchedSAMLSourceRequest, SAMLSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesSamlPartialUpdate
     *
     * @param slug 
     * @param patchedSAMLSourceRequest  (optional)
     * @return RequestConfig
     */
    fun sourcesSamlPartialUpdateRequestConfig(slug: kotlin.String, patchedSAMLSourceRequest: PatchedSAMLSourceRequest?) : RequestConfig<PatchedSAMLSourceRequest> {
        val localVariableBody = patchedSAMLSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/sources/saml/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLSource Viewset
     * @param slug 
     * @return SAMLSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesSamlRetrieve(slug: kotlin.String) : SAMLSource {
        val localVarResponse = sourcesSamlRetrieveWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLSource Viewset
     * @param slug 
     * @return ApiResponse<SAMLSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesSamlRetrieveWithHttpInfo(slug: kotlin.String) : ApiResponse<SAMLSource?> {
        val localVariableConfig = sourcesSamlRetrieveRequestConfig(slug = slug)

        return request<Unit, SAMLSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesSamlRetrieve
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesSamlRetrieveRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/saml/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * SAMLSource Viewset
     * @param slug 
     * @param saMLSourceRequest 
     * @return SAMLSource
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesSamlUpdate(slug: kotlin.String, saMLSourceRequest: SAMLSourceRequest) : SAMLSource {
        val localVarResponse = sourcesSamlUpdateWithHttpInfo(slug = slug, saMLSourceRequest = saMLSourceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SAMLSource
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * SAMLSource Viewset
     * @param slug 
     * @param saMLSourceRequest 
     * @return ApiResponse<SAMLSource?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesSamlUpdateWithHttpInfo(slug: kotlin.String, saMLSourceRequest: SAMLSourceRequest) : ApiResponse<SAMLSource?> {
        val localVariableConfig = sourcesSamlUpdateRequestConfig(slug = slug, saMLSourceRequest = saMLSourceRequest)

        return request<SAMLSourceRequest, SAMLSource>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesSamlUpdate
     *
     * @param slug 
     * @param saMLSourceRequest 
     * @return RequestConfig
     */
    fun sourcesSamlUpdateRequestConfig(slug: kotlin.String, saMLSourceRequest: SAMLSourceRequest) : RequestConfig<SAMLSourceRequest> {
        val localVariableBody = saMLSourceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/sources/saml/{slug}/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesSamlUsedByList(slug: kotlin.String) : kotlin.collections.List<UsedBy> {
        val localVarResponse = sourcesSamlUsedByListWithHttpInfo(slug = slug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param slug 
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesSamlUsedByListWithHttpInfo(slug: kotlin.String) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = sourcesSamlUsedByListRequestConfig(slug = slug)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesSamlUsedByList
     *
     * @param slug 
     * @return RequestConfig
     */
    fun sourcesSamlUsedByListRequestConfig(slug: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/saml/{slug}/used_by/".replace("{"+"slug"+"}", encodeURIComponent(slug.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * User-source connection Viewset
     * @param id A unique integer value identifying this user source connection.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsAllDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = sourcesUserConnectionsAllDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User-source connection Viewset
     * @param id A unique integer value identifying this user source connection.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsAllDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesUserConnectionsAllDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsAllDestroy
     *
     * @param id A unique integer value identifying this user source connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsAllDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/sources/user_connections/all/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * User-source connection Viewset
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param user  (optional)
     * @return PaginatedUserSourceConnectionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsAllList(ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, user: kotlin.Int? = null) : PaginatedUserSourceConnectionList {
        val localVarResponse = sourcesUserConnectionsAllListWithHttpInfo(ordering = ordering, page = page, pageSize = pageSize, search = search, user = user)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedUserSourceConnectionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User-source connection Viewset
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param user  (optional)
     * @return ApiResponse<PaginatedUserSourceConnectionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsAllListWithHttpInfo(ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, user: kotlin.Int?) : ApiResponse<PaginatedUserSourceConnectionList?> {
        val localVariableConfig = sourcesUserConnectionsAllListRequestConfig(ordering = ordering, page = page, pageSize = pageSize, search = search, user = user)

        return request<Unit, PaginatedUserSourceConnectionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsAllList
     *
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param user  (optional)
     * @return RequestConfig
     */
    fun sourcesUserConnectionsAllListRequestConfig(ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, user: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/all/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * User-source connection Viewset
     * @param id A unique integer value identifying this user source connection.
     * @return UserSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsAllPartialUpdate(id: kotlin.Int) : UserSourceConnection {
        val localVarResponse = sourcesUserConnectionsAllPartialUpdateWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User-source connection Viewset
     * @param id A unique integer value identifying this user source connection.
     * @return ApiResponse<UserSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsAllPartialUpdateWithHttpInfo(id: kotlin.Int) : ApiResponse<UserSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsAllPartialUpdateRequestConfig(id = id)

        return request<Unit, UserSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsAllPartialUpdate
     *
     * @param id A unique integer value identifying this user source connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsAllPartialUpdateRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/sources/user_connections/all/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * User-source connection Viewset
     * @param id A unique integer value identifying this user source connection.
     * @return UserSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsAllRetrieve(id: kotlin.Int) : UserSourceConnection {
        val localVarResponse = sourcesUserConnectionsAllRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User-source connection Viewset
     * @param id A unique integer value identifying this user source connection.
     * @return ApiResponse<UserSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsAllRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<UserSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsAllRetrieveRequestConfig(id = id)

        return request<Unit, UserSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsAllRetrieve
     *
     * @param id A unique integer value identifying this user source connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsAllRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/all/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * User-source connection Viewset
     * @param id A unique integer value identifying this user source connection.
     * @return UserSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsAllUpdate(id: kotlin.Int) : UserSourceConnection {
        val localVarResponse = sourcesUserConnectionsAllUpdateWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * User-source connection Viewset
     * @param id A unique integer value identifying this user source connection.
     * @return ApiResponse<UserSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsAllUpdateWithHttpInfo(id: kotlin.Int) : ApiResponse<UserSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsAllUpdateRequestConfig(id = id)

        return request<Unit, UserSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsAllUpdate
     *
     * @param id A unique integer value identifying this user source connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsAllUpdateRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/sources/user_connections/all/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this user source connection.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsAllUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = sourcesUserConnectionsAllUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this user source connection.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsAllUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = sourcesUserConnectionsAllUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsAllUsedByList
     *
     * @param id A unique integer value identifying this user source connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsAllUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/all/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param userOAuthSourceConnectionRequest 
     * @return UserOAuthSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsOauthCreate(userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest) : UserOAuthSourceConnection {
        val localVarResponse = sourcesUserConnectionsOauthCreateWithHttpInfo(userOAuthSourceConnectionRequest = userOAuthSourceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserOAuthSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param userOAuthSourceConnectionRequest 
     * @return ApiResponse<UserOAuthSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsOauthCreateWithHttpInfo(userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest) : ApiResponse<UserOAuthSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsOauthCreateRequestConfig(userOAuthSourceConnectionRequest = userOAuthSourceConnectionRequest)

        return request<UserOAuthSourceConnectionRequest, UserOAuthSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsOauthCreate
     *
     * @param userOAuthSourceConnectionRequest 
     * @return RequestConfig
     */
    fun sourcesUserConnectionsOauthCreateRequestConfig(userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest) : RequestConfig<UserOAuthSourceConnectionRequest> {
        val localVariableBody = userOAuthSourceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/sources/user_connections/oauth/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsOauthDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = sourcesUserConnectionsOauthDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsOauthDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesUserConnectionsOauthDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsOauthDestroy
     *
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsOauthDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/sources/user_connections/oauth/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sourceSlug  (optional)
     * @return PaginatedUserOAuthSourceConnectionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsOauthList(ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, sourceSlug: kotlin.String? = null) : PaginatedUserOAuthSourceConnectionList {
        val localVarResponse = sourcesUserConnectionsOauthListWithHttpInfo(ordering = ordering, page = page, pageSize = pageSize, search = search, sourceSlug = sourceSlug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedUserOAuthSourceConnectionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sourceSlug  (optional)
     * @return ApiResponse<PaginatedUserOAuthSourceConnectionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsOauthListWithHttpInfo(ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, sourceSlug: kotlin.String?) : ApiResponse<PaginatedUserOAuthSourceConnectionList?> {
        val localVariableConfig = sourcesUserConnectionsOauthListRequestConfig(ordering = ordering, page = page, pageSize = pageSize, search = search, sourceSlug = sourceSlug)

        return request<Unit, PaginatedUserOAuthSourceConnectionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsOauthList
     *
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sourceSlug  (optional)
     * @return RequestConfig
     */
    fun sourcesUserConnectionsOauthListRequestConfig(ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, sourceSlug: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (sourceSlug != null) {
                    put("source__slug", listOf(sourceSlug.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/oauth/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @param patchedUserOAuthSourceConnectionRequest  (optional)
     * @return UserOAuthSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsOauthPartialUpdate(id: kotlin.Int, patchedUserOAuthSourceConnectionRequest: PatchedUserOAuthSourceConnectionRequest? = null) : UserOAuthSourceConnection {
        val localVarResponse = sourcesUserConnectionsOauthPartialUpdateWithHttpInfo(id = id, patchedUserOAuthSourceConnectionRequest = patchedUserOAuthSourceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserOAuthSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @param patchedUserOAuthSourceConnectionRequest  (optional)
     * @return ApiResponse<UserOAuthSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsOauthPartialUpdateWithHttpInfo(id: kotlin.Int, patchedUserOAuthSourceConnectionRequest: PatchedUserOAuthSourceConnectionRequest?) : ApiResponse<UserOAuthSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsOauthPartialUpdateRequestConfig(id = id, patchedUserOAuthSourceConnectionRequest = patchedUserOAuthSourceConnectionRequest)

        return request<PatchedUserOAuthSourceConnectionRequest, UserOAuthSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsOauthPartialUpdate
     *
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @param patchedUserOAuthSourceConnectionRequest  (optional)
     * @return RequestConfig
     */
    fun sourcesUserConnectionsOauthPartialUpdateRequestConfig(id: kotlin.Int, patchedUserOAuthSourceConnectionRequest: PatchedUserOAuthSourceConnectionRequest?) : RequestConfig<PatchedUserOAuthSourceConnectionRequest> {
        val localVariableBody = patchedUserOAuthSourceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/sources/user_connections/oauth/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @return UserOAuthSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsOauthRetrieve(id: kotlin.Int) : UserOAuthSourceConnection {
        val localVarResponse = sourcesUserConnectionsOauthRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserOAuthSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @return ApiResponse<UserOAuthSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsOauthRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<UserOAuthSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsOauthRetrieveRequestConfig(id = id)

        return request<Unit, UserOAuthSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsOauthRetrieve
     *
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsOauthRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/oauth/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @param userOAuthSourceConnectionRequest 
     * @return UserOAuthSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsOauthUpdate(id: kotlin.Int, userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest) : UserOAuthSourceConnection {
        val localVarResponse = sourcesUserConnectionsOauthUpdateWithHttpInfo(id = id, userOAuthSourceConnectionRequest = userOAuthSourceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserOAuthSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @param userOAuthSourceConnectionRequest 
     * @return ApiResponse<UserOAuthSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsOauthUpdateWithHttpInfo(id: kotlin.Int, userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest) : ApiResponse<UserOAuthSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsOauthUpdateRequestConfig(id = id, userOAuthSourceConnectionRequest = userOAuthSourceConnectionRequest)

        return request<UserOAuthSourceConnectionRequest, UserOAuthSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsOauthUpdate
     *
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @param userOAuthSourceConnectionRequest 
     * @return RequestConfig
     */
    fun sourcesUserConnectionsOauthUpdateRequestConfig(id: kotlin.Int, userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest) : RequestConfig<UserOAuthSourceConnectionRequest> {
        val localVariableBody = userOAuthSourceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/sources/user_connections/oauth/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsOauthUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = sourcesUserConnectionsOauthUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsOauthUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = sourcesUserConnectionsOauthUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsOauthUsedByList
     *
     * @param id A unique integer value identifying this User OAuth Source Connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsOauthUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/oauth/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param plexSourceConnectionRequest 
     * @return PlexSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsPlexCreate(plexSourceConnectionRequest: PlexSourceConnectionRequest) : PlexSourceConnection {
        val localVarResponse = sourcesUserConnectionsPlexCreateWithHttpInfo(plexSourceConnectionRequest = plexSourceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PlexSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param plexSourceConnectionRequest 
     * @return ApiResponse<PlexSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsPlexCreateWithHttpInfo(plexSourceConnectionRequest: PlexSourceConnectionRequest) : ApiResponse<PlexSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsPlexCreateRequestConfig(plexSourceConnectionRequest = plexSourceConnectionRequest)

        return request<PlexSourceConnectionRequest, PlexSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsPlexCreate
     *
     * @param plexSourceConnectionRequest 
     * @return RequestConfig
     */
    fun sourcesUserConnectionsPlexCreateRequestConfig(plexSourceConnectionRequest: PlexSourceConnectionRequest) : RequestConfig<PlexSourceConnectionRequest> {
        val localVariableBody = plexSourceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/sources/user_connections/plex/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsPlexDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = sourcesUserConnectionsPlexDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsPlexDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesUserConnectionsPlexDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsPlexDestroy
     *
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsPlexDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/sources/user_connections/plex/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sourceSlug  (optional)
     * @return PaginatedPlexSourceConnectionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsPlexList(ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, sourceSlug: kotlin.String? = null) : PaginatedPlexSourceConnectionList {
        val localVarResponse = sourcesUserConnectionsPlexListWithHttpInfo(ordering = ordering, page = page, pageSize = pageSize, search = search, sourceSlug = sourceSlug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPlexSourceConnectionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sourceSlug  (optional)
     * @return ApiResponse<PaginatedPlexSourceConnectionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsPlexListWithHttpInfo(ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, sourceSlug: kotlin.String?) : ApiResponse<PaginatedPlexSourceConnectionList?> {
        val localVariableConfig = sourcesUserConnectionsPlexListRequestConfig(ordering = ordering, page = page, pageSize = pageSize, search = search, sourceSlug = sourceSlug)

        return request<Unit, PaginatedPlexSourceConnectionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsPlexList
     *
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sourceSlug  (optional)
     * @return RequestConfig
     */
    fun sourcesUserConnectionsPlexListRequestConfig(ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, sourceSlug: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (sourceSlug != null) {
                    put("source__slug", listOf(sourceSlug.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/plex/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @param patchedPlexSourceConnectionRequest  (optional)
     * @return PlexSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsPlexPartialUpdate(id: kotlin.Int, patchedPlexSourceConnectionRequest: PatchedPlexSourceConnectionRequest? = null) : PlexSourceConnection {
        val localVarResponse = sourcesUserConnectionsPlexPartialUpdateWithHttpInfo(id = id, patchedPlexSourceConnectionRequest = patchedPlexSourceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PlexSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @param patchedPlexSourceConnectionRequest  (optional)
     * @return ApiResponse<PlexSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsPlexPartialUpdateWithHttpInfo(id: kotlin.Int, patchedPlexSourceConnectionRequest: PatchedPlexSourceConnectionRequest?) : ApiResponse<PlexSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsPlexPartialUpdateRequestConfig(id = id, patchedPlexSourceConnectionRequest = patchedPlexSourceConnectionRequest)

        return request<PatchedPlexSourceConnectionRequest, PlexSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsPlexPartialUpdate
     *
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @param patchedPlexSourceConnectionRequest  (optional)
     * @return RequestConfig
     */
    fun sourcesUserConnectionsPlexPartialUpdateRequestConfig(id: kotlin.Int, patchedPlexSourceConnectionRequest: PatchedPlexSourceConnectionRequest?) : RequestConfig<PatchedPlexSourceConnectionRequest> {
        val localVariableBody = patchedPlexSourceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/sources/user_connections/plex/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @return PlexSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsPlexRetrieve(id: kotlin.Int) : PlexSourceConnection {
        val localVarResponse = sourcesUserConnectionsPlexRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PlexSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @return ApiResponse<PlexSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsPlexRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<PlexSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsPlexRetrieveRequestConfig(id = id)

        return request<Unit, PlexSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsPlexRetrieve
     *
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsPlexRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/plex/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @param plexSourceConnectionRequest 
     * @return PlexSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsPlexUpdate(id: kotlin.Int, plexSourceConnectionRequest: PlexSourceConnectionRequest) : PlexSourceConnection {
        val localVarResponse = sourcesUserConnectionsPlexUpdateWithHttpInfo(id = id, plexSourceConnectionRequest = plexSourceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PlexSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Plex Source connection Serializer
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @param plexSourceConnectionRequest 
     * @return ApiResponse<PlexSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsPlexUpdateWithHttpInfo(id: kotlin.Int, plexSourceConnectionRequest: PlexSourceConnectionRequest) : ApiResponse<PlexSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsPlexUpdateRequestConfig(id = id, plexSourceConnectionRequest = plexSourceConnectionRequest)

        return request<PlexSourceConnectionRequest, PlexSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsPlexUpdate
     *
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @param plexSourceConnectionRequest 
     * @return RequestConfig
     */
    fun sourcesUserConnectionsPlexUpdateRequestConfig(id: kotlin.Int, plexSourceConnectionRequest: PlexSourceConnectionRequest) : RequestConfig<PlexSourceConnectionRequest> {
        val localVariableBody = plexSourceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/sources/user_connections/plex/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsPlexUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = sourcesUserConnectionsPlexUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsPlexUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = sourcesUserConnectionsPlexUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsPlexUsedByList
     *
     * @param id A unique integer value identifying this User Plex Source Connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsPlexUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/plex/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param userSAMLSourceConnectionRequest 
     * @return UserSAMLSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsSamlCreate(userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest) : UserSAMLSourceConnection {
        val localVarResponse = sourcesUserConnectionsSamlCreateWithHttpInfo(userSAMLSourceConnectionRequest = userSAMLSourceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSAMLSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param userSAMLSourceConnectionRequest 
     * @return ApiResponse<UserSAMLSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsSamlCreateWithHttpInfo(userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest) : ApiResponse<UserSAMLSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsSamlCreateRequestConfig(userSAMLSourceConnectionRequest = userSAMLSourceConnectionRequest)

        return request<UserSAMLSourceConnectionRequest, UserSAMLSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsSamlCreate
     *
     * @param userSAMLSourceConnectionRequest 
     * @return RequestConfig
     */
    fun sourcesUserConnectionsSamlCreateRequestConfig(userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest) : RequestConfig<UserSAMLSourceConnectionRequest> {
        val localVariableBody = userSAMLSourceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/sources/user_connections/saml/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsSamlDestroy(id: kotlin.Int) : Unit {
        val localVarResponse = sourcesUserConnectionsSamlDestroyWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsSamlDestroyWithHttpInfo(id: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = sourcesUserConnectionsSamlDestroyRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsSamlDestroy
     *
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsSamlDestroyRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/sources/user_connections/saml/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sourceSlug  (optional)
     * @return PaginatedUserSAMLSourceConnectionList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsSamlList(ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, sourceSlug: kotlin.String? = null) : PaginatedUserSAMLSourceConnectionList {
        val localVarResponse = sourcesUserConnectionsSamlListWithHttpInfo(ordering = ordering, page = page, pageSize = pageSize, search = search, sourceSlug = sourceSlug)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedUserSAMLSourceConnectionList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sourceSlug  (optional)
     * @return ApiResponse<PaginatedUserSAMLSourceConnectionList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsSamlListWithHttpInfo(ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, sourceSlug: kotlin.String?) : ApiResponse<PaginatedUserSAMLSourceConnectionList?> {
        val localVariableConfig = sourcesUserConnectionsSamlListRequestConfig(ordering = ordering, page = page, pageSize = pageSize, search = search, sourceSlug = sourceSlug)

        return request<Unit, PaginatedUserSAMLSourceConnectionList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsSamlList
     *
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sourceSlug  (optional)
     * @return RequestConfig
     */
    fun sourcesUserConnectionsSamlListRequestConfig(ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, sourceSlug: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (sourceSlug != null) {
                    put("source__slug", listOf(sourceSlug.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/saml/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @param patchedUserSAMLSourceConnectionRequest  (optional)
     * @return UserSAMLSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsSamlPartialUpdate(id: kotlin.Int, patchedUserSAMLSourceConnectionRequest: PatchedUserSAMLSourceConnectionRequest? = null) : UserSAMLSourceConnection {
        val localVarResponse = sourcesUserConnectionsSamlPartialUpdateWithHttpInfo(id = id, patchedUserSAMLSourceConnectionRequest = patchedUserSAMLSourceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSAMLSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @param patchedUserSAMLSourceConnectionRequest  (optional)
     * @return ApiResponse<UserSAMLSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsSamlPartialUpdateWithHttpInfo(id: kotlin.Int, patchedUserSAMLSourceConnectionRequest: PatchedUserSAMLSourceConnectionRequest?) : ApiResponse<UserSAMLSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsSamlPartialUpdateRequestConfig(id = id, patchedUserSAMLSourceConnectionRequest = patchedUserSAMLSourceConnectionRequest)

        return request<PatchedUserSAMLSourceConnectionRequest, UserSAMLSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsSamlPartialUpdate
     *
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @param patchedUserSAMLSourceConnectionRequest  (optional)
     * @return RequestConfig
     */
    fun sourcesUserConnectionsSamlPartialUpdateRequestConfig(id: kotlin.Int, patchedUserSAMLSourceConnectionRequest: PatchedUserSAMLSourceConnectionRequest?) : RequestConfig<PatchedUserSAMLSourceConnectionRequest> {
        val localVariableBody = patchedUserSAMLSourceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/sources/user_connections/saml/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @return UserSAMLSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsSamlRetrieve(id: kotlin.Int) : UserSAMLSourceConnection {
        val localVarResponse = sourcesUserConnectionsSamlRetrieveWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSAMLSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @return ApiResponse<UserSAMLSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsSamlRetrieveWithHttpInfo(id: kotlin.Int) : ApiResponse<UserSAMLSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsSamlRetrieveRequestConfig(id = id)

        return request<Unit, UserSAMLSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsSamlRetrieve
     *
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsSamlRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/saml/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @param userSAMLSourceConnectionRequest 
     * @return UserSAMLSourceConnection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsSamlUpdate(id: kotlin.Int, userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest) : UserSAMLSourceConnection {
        val localVarResponse = sourcesUserConnectionsSamlUpdateWithHttpInfo(id = id, userSAMLSourceConnectionRequest = userSAMLSourceConnectionRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSAMLSourceConnection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Source Viewset
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @param userSAMLSourceConnectionRequest 
     * @return ApiResponse<UserSAMLSourceConnection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsSamlUpdateWithHttpInfo(id: kotlin.Int, userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest) : ApiResponse<UserSAMLSourceConnection?> {
        val localVariableConfig = sourcesUserConnectionsSamlUpdateRequestConfig(id = id, userSAMLSourceConnectionRequest = userSAMLSourceConnectionRequest)

        return request<UserSAMLSourceConnectionRequest, UserSAMLSourceConnection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsSamlUpdate
     *
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @param userSAMLSourceConnectionRequest 
     * @return RequestConfig
     */
    fun sourcesUserConnectionsSamlUpdateRequestConfig(id: kotlin.Int, userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest) : RequestConfig<UserSAMLSourceConnectionRequest> {
        val localVariableBody = userSAMLSourceConnectionRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/sources/user_connections/saml/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sourcesUserConnectionsSamlUsedByList(id: kotlin.Int) : kotlin.collections.List<UsedBy> {
        val localVarResponse = sourcesUserConnectionsSamlUsedByListWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sourcesUserConnectionsSamlUsedByListWithHttpInfo(id: kotlin.Int) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = sourcesUserConnectionsSamlUsedByListRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sourcesUserConnectionsSamlUsedByList
     *
     * @param id A unique integer value identifying this User SAML Source Connection.
     * @return RequestConfig
     */
    fun sourcesUserConnectionsSamlUsedByListRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/sources/user_connections/saml/{id}/used_by/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
