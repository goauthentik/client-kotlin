/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.goauthentik.api.models.Coordinate
import io.goauthentik.api.models.Event
import io.goauthentik.api.models.EventRequest
import io.goauthentik.api.models.EventTopPerUser
import io.goauthentik.api.models.GenericError
import io.goauthentik.api.models.Notification
import io.goauthentik.api.models.NotificationRequest
import io.goauthentik.api.models.NotificationRule
import io.goauthentik.api.models.NotificationRuleRequest
import io.goauthentik.api.models.NotificationTransport
import io.goauthentik.api.models.NotificationTransportRequest
import io.goauthentik.api.models.NotificationTransportTest
import io.goauthentik.api.models.PaginatedEventList
import io.goauthentik.api.models.PaginatedNotificationList
import io.goauthentik.api.models.PaginatedNotificationRuleList
import io.goauthentik.api.models.PaginatedNotificationTransportList
import io.goauthentik.api.models.PaginatedSystemTaskList
import io.goauthentik.api.models.PatchedEventRequest
import io.goauthentik.api.models.PatchedNotificationRequest
import io.goauthentik.api.models.PatchedNotificationRuleRequest
import io.goauthentik.api.models.PatchedNotificationTransportRequest
import io.goauthentik.api.models.SystemTask
import io.goauthentik.api.models.TypeCreate
import io.goauthentik.api.models.UsedBy
import io.goauthentik.api.models.ValidationError

import com.squareup.moshi.Json

import io.goauthentik.api.infrastructure.ApiClient
import io.goauthentik.api.infrastructure.ApiResponse
import io.goauthentik.api.infrastructure.ClientException
import io.goauthentik.api.infrastructure.ClientError
import io.goauthentik.api.infrastructure.ServerException
import io.goauthentik.api.infrastructure.ServerError
import io.goauthentik.api.infrastructure.MultiValueMap
import io.goauthentik.api.infrastructure.PartConfig
import io.goauthentik.api.infrastructure.RequestConfig
import io.goauthentik.api.infrastructure.RequestMethod
import io.goauthentik.api.infrastructure.ResponseType
import io.goauthentik.api.infrastructure.Success
import io.goauthentik.api.infrastructure.toMultiValue

class EventsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost/api/v3")
        }
    }

    /**
     * 
     * Get all actions
     * @return kotlin.collections.List<TypeCreate>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsEventsActionsList() : kotlin.collections.List<TypeCreate> {
        val localVarResponse = eventsEventsActionsListWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TypeCreate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get all actions
     * @return ApiResponse<kotlin.collections.List<TypeCreate>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsEventsActionsListWithHttpInfo() : ApiResponse<kotlin.collections.List<TypeCreate>?> {
        val localVariableConfig = eventsEventsActionsListRequestConfig()

        return request<Unit, kotlin.collections.List<TypeCreate>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsEventsActionsList
     *
     * @return RequestConfig
     */
    fun eventsEventsActionsListRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/events/actions/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param eventRequest 
     * @return Event
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsEventsCreate(eventRequest: EventRequest) : Event {
        val localVarResponse = eventsEventsCreateWithHttpInfo(eventRequest = eventRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Event
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param eventRequest 
     * @return ApiResponse<Event?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsEventsCreateWithHttpInfo(eventRequest: EventRequest) : ApiResponse<Event?> {
        val localVariableConfig = eventsEventsCreateRequestConfig(eventRequest = eventRequest)

        return request<EventRequest, Event>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsEventsCreate
     *
     * @param eventRequest 
     * @return RequestConfig
     */
    fun eventsEventsCreateRequestConfig(eventRequest: EventRequest) : RequestConfig<EventRequest> {
        val localVariableBody = eventRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/events/events/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param eventUuid A UUID string identifying this Event.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsEventsDestroy(eventUuid: java.util.UUID) : Unit {
        val localVarResponse = eventsEventsDestroyWithHttpInfo(eventUuid = eventUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param eventUuid A UUID string identifying this Event.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsEventsDestroyWithHttpInfo(eventUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = eventsEventsDestroyRequestConfig(eventUuid = eventUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsEventsDestroy
     *
     * @param eventUuid A UUID string identifying this Event.
     * @return RequestConfig
     */
    fun eventsEventsDestroyRequestConfig(eventUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/events/events/{event_uuid}/".replace("{"+"event_uuid"+"}", encodeURIComponent(eventUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param action  (optional)
     * @param brandName Brand name (optional)
     * @param clientIp  (optional)
     * @param contextAuthorizedApp Context Authorized application (optional)
     * @param contextModelApp Context Model App (optional)
     * @param contextModelName Context Model Name (optional)
     * @param contextModelPk Context Model Primary Key (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param username Username (optional)
     * @return PaginatedEventList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsEventsList(action: kotlin.String? = null, brandName: kotlin.String? = null, clientIp: kotlin.String? = null, contextAuthorizedApp: kotlin.String? = null, contextModelApp: kotlin.String? = null, contextModelName: kotlin.String? = null, contextModelPk: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, username: kotlin.String? = null) : PaginatedEventList {
        val localVarResponse = eventsEventsListWithHttpInfo(action = action, brandName = brandName, clientIp = clientIp, contextAuthorizedApp = contextAuthorizedApp, contextModelApp = contextModelApp, contextModelName = contextModelName, contextModelPk = contextModelPk, ordering = ordering, page = page, pageSize = pageSize, search = search, username = username)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedEventList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param action  (optional)
     * @param brandName Brand name (optional)
     * @param clientIp  (optional)
     * @param contextAuthorizedApp Context Authorized application (optional)
     * @param contextModelApp Context Model App (optional)
     * @param contextModelName Context Model Name (optional)
     * @param contextModelPk Context Model Primary Key (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param username Username (optional)
     * @return ApiResponse<PaginatedEventList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsEventsListWithHttpInfo(action: kotlin.String?, brandName: kotlin.String?, clientIp: kotlin.String?, contextAuthorizedApp: kotlin.String?, contextModelApp: kotlin.String?, contextModelName: kotlin.String?, contextModelPk: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, username: kotlin.String?) : ApiResponse<PaginatedEventList?> {
        val localVariableConfig = eventsEventsListRequestConfig(action = action, brandName = brandName, clientIp = clientIp, contextAuthorizedApp = contextAuthorizedApp, contextModelApp = contextModelApp, contextModelName = contextModelName, contextModelPk = contextModelPk, ordering = ordering, page = page, pageSize = pageSize, search = search, username = username)

        return request<Unit, PaginatedEventList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsEventsList
     *
     * @param action  (optional)
     * @param brandName Brand name (optional)
     * @param clientIp  (optional)
     * @param contextAuthorizedApp Context Authorized application (optional)
     * @param contextModelApp Context Model App (optional)
     * @param contextModelName Context Model Name (optional)
     * @param contextModelPk Context Model Primary Key (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param username Username (optional)
     * @return RequestConfig
     */
    fun eventsEventsListRequestConfig(action: kotlin.String?, brandName: kotlin.String?, clientIp: kotlin.String?, contextAuthorizedApp: kotlin.String?, contextModelApp: kotlin.String?, contextModelName: kotlin.String?, contextModelPk: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, username: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (action != null) {
                    put("action", listOf(action.toString()))
                }
                if (brandName != null) {
                    put("brand_name", listOf(brandName.toString()))
                }
                if (clientIp != null) {
                    put("client_ip", listOf(clientIp.toString()))
                }
                if (contextAuthorizedApp != null) {
                    put("context_authorized_app", listOf(contextAuthorizedApp.toString()))
                }
                if (contextModelApp != null) {
                    put("context_model_app", listOf(contextModelApp.toString()))
                }
                if (contextModelName != null) {
                    put("context_model_name", listOf(contextModelName.toString()))
                }
                if (contextModelPk != null) {
                    put("context_model_pk", listOf(contextModelPk.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (username != null) {
                    put("username", listOf(username.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/events/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param eventUuid A UUID string identifying this Event.
     * @param patchedEventRequest  (optional)
     * @return Event
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsEventsPartialUpdate(eventUuid: java.util.UUID, patchedEventRequest: PatchedEventRequest? = null) : Event {
        val localVarResponse = eventsEventsPartialUpdateWithHttpInfo(eventUuid = eventUuid, patchedEventRequest = patchedEventRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Event
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param eventUuid A UUID string identifying this Event.
     * @param patchedEventRequest  (optional)
     * @return ApiResponse<Event?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsEventsPartialUpdateWithHttpInfo(eventUuid: java.util.UUID, patchedEventRequest: PatchedEventRequest?) : ApiResponse<Event?> {
        val localVariableConfig = eventsEventsPartialUpdateRequestConfig(eventUuid = eventUuid, patchedEventRequest = patchedEventRequest)

        return request<PatchedEventRequest, Event>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsEventsPartialUpdate
     *
     * @param eventUuid A UUID string identifying this Event.
     * @param patchedEventRequest  (optional)
     * @return RequestConfig
     */
    fun eventsEventsPartialUpdateRequestConfig(eventUuid: java.util.UUID, patchedEventRequest: PatchedEventRequest?) : RequestConfig<PatchedEventRequest> {
        val localVariableBody = patchedEventRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/events/events/{event_uuid}/".replace("{"+"event_uuid"+"}", encodeURIComponent(eventUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get the count of events per month
     * @param action  (optional)
     * @param query  (optional)
     * @return kotlin.collections.List<Coordinate>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsEventsPerMonthList(action: kotlin.String? = null, query: kotlin.String? = null) : kotlin.collections.List<Coordinate> {
        val localVarResponse = eventsEventsPerMonthListWithHttpInfo(action = action, query = query)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Coordinate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get the count of events per month
     * @param action  (optional)
     * @param query  (optional)
     * @return ApiResponse<kotlin.collections.List<Coordinate>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsEventsPerMonthListWithHttpInfo(action: kotlin.String?, query: kotlin.String?) : ApiResponse<kotlin.collections.List<Coordinate>?> {
        val localVariableConfig = eventsEventsPerMonthListRequestConfig(action = action, query = query)

        return request<Unit, kotlin.collections.List<Coordinate>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsEventsPerMonthList
     *
     * @param action  (optional)
     * @param query  (optional)
     * @return RequestConfig
     */
    fun eventsEventsPerMonthListRequestConfig(action: kotlin.String?, query: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (action != null) {
                    put("action", listOf(action.toString()))
                }
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/events/per_month/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param eventUuid A UUID string identifying this Event.
     * @return Event
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsEventsRetrieve(eventUuid: java.util.UUID) : Event {
        val localVarResponse = eventsEventsRetrieveWithHttpInfo(eventUuid = eventUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Event
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param eventUuid A UUID string identifying this Event.
     * @return ApiResponse<Event?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsEventsRetrieveWithHttpInfo(eventUuid: java.util.UUID) : ApiResponse<Event?> {
        val localVariableConfig = eventsEventsRetrieveRequestConfig(eventUuid = eventUuid)

        return request<Unit, Event>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsEventsRetrieve
     *
     * @param eventUuid A UUID string identifying this Event.
     * @return RequestConfig
     */
    fun eventsEventsRetrieveRequestConfig(eventUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/events/{event_uuid}/".replace("{"+"event_uuid"+"}", encodeURIComponent(eventUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get the top_n events grouped by user count
     * @param action  (optional)
     * @param topN  (optional)
     * @return kotlin.collections.List<EventTopPerUser>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsEventsTopPerUserList(action: kotlin.String? = null, topN: kotlin.Int? = null) : kotlin.collections.List<EventTopPerUser> {
        val localVarResponse = eventsEventsTopPerUserListWithHttpInfo(action = action, topN = topN)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<EventTopPerUser>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get the top_n events grouped by user count
     * @param action  (optional)
     * @param topN  (optional)
     * @return ApiResponse<kotlin.collections.List<EventTopPerUser>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsEventsTopPerUserListWithHttpInfo(action: kotlin.String?, topN: kotlin.Int?) : ApiResponse<kotlin.collections.List<EventTopPerUser>?> {
        val localVariableConfig = eventsEventsTopPerUserListRequestConfig(action = action, topN = topN)

        return request<Unit, kotlin.collections.List<EventTopPerUser>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsEventsTopPerUserList
     *
     * @param action  (optional)
     * @param topN  (optional)
     * @return RequestConfig
     */
    fun eventsEventsTopPerUserListRequestConfig(action: kotlin.String?, topN: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (action != null) {
                    put("action", listOf(action.toString()))
                }
                if (topN != null) {
                    put("top_n", listOf(topN.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/events/top_per_user/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param eventUuid A UUID string identifying this Event.
     * @param eventRequest 
     * @return Event
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsEventsUpdate(eventUuid: java.util.UUID, eventRequest: EventRequest) : Event {
        val localVarResponse = eventsEventsUpdateWithHttpInfo(eventUuid = eventUuid, eventRequest = eventRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Event
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Event Read-Only Viewset
     * @param eventUuid A UUID string identifying this Event.
     * @param eventRequest 
     * @return ApiResponse<Event?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsEventsUpdateWithHttpInfo(eventUuid: java.util.UUID, eventRequest: EventRequest) : ApiResponse<Event?> {
        val localVariableConfig = eventsEventsUpdateRequestConfig(eventUuid = eventUuid, eventRequest = eventRequest)

        return request<EventRequest, Event>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsEventsUpdate
     *
     * @param eventUuid A UUID string identifying this Event.
     * @param eventRequest 
     * @return RequestConfig
     */
    fun eventsEventsUpdateRequestConfig(eventUuid: java.util.UUID, eventRequest: EventRequest) : RequestConfig<EventRequest> {
        val localVariableBody = eventRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/events/events/{event_uuid}/".replace("{"+"event_uuid"+"}", encodeURIComponent(eventUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get event volume for specified filters and timeframe
     * @param action  (optional)
     * @param brandName Brand name (optional)
     * @param clientIp  (optional)
     * @param contextAuthorizedApp Context Authorized application (optional)
     * @param contextModelApp Context Model App (optional)
     * @param contextModelName Context Model Name (optional)
     * @param contextModelPk Context Model Primary Key (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param search A search term. (optional)
     * @param username Username (optional)
     * @return kotlin.collections.List<Coordinate>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsEventsVolumeList(action: kotlin.String? = null, brandName: kotlin.String? = null, clientIp: kotlin.String? = null, contextAuthorizedApp: kotlin.String? = null, contextModelApp: kotlin.String? = null, contextModelName: kotlin.String? = null, contextModelPk: kotlin.String? = null, ordering: kotlin.String? = null, search: kotlin.String? = null, username: kotlin.String? = null) : kotlin.collections.List<Coordinate> {
        val localVarResponse = eventsEventsVolumeListWithHttpInfo(action = action, brandName = brandName, clientIp = clientIp, contextAuthorizedApp = contextAuthorizedApp, contextModelApp = contextModelApp, contextModelName = contextModelName, contextModelPk = contextModelPk, ordering = ordering, search = search, username = username)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Coordinate>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get event volume for specified filters and timeframe
     * @param action  (optional)
     * @param brandName Brand name (optional)
     * @param clientIp  (optional)
     * @param contextAuthorizedApp Context Authorized application (optional)
     * @param contextModelApp Context Model App (optional)
     * @param contextModelName Context Model Name (optional)
     * @param contextModelPk Context Model Primary Key (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param search A search term. (optional)
     * @param username Username (optional)
     * @return ApiResponse<kotlin.collections.List<Coordinate>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsEventsVolumeListWithHttpInfo(action: kotlin.String?, brandName: kotlin.String?, clientIp: kotlin.String?, contextAuthorizedApp: kotlin.String?, contextModelApp: kotlin.String?, contextModelName: kotlin.String?, contextModelPk: kotlin.String?, ordering: kotlin.String?, search: kotlin.String?, username: kotlin.String?) : ApiResponse<kotlin.collections.List<Coordinate>?> {
        val localVariableConfig = eventsEventsVolumeListRequestConfig(action = action, brandName = brandName, clientIp = clientIp, contextAuthorizedApp = contextAuthorizedApp, contextModelApp = contextModelApp, contextModelName = contextModelName, contextModelPk = contextModelPk, ordering = ordering, search = search, username = username)

        return request<Unit, kotlin.collections.List<Coordinate>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsEventsVolumeList
     *
     * @param action  (optional)
     * @param brandName Brand name (optional)
     * @param clientIp  (optional)
     * @param contextAuthorizedApp Context Authorized application (optional)
     * @param contextModelApp Context Model App (optional)
     * @param contextModelName Context Model Name (optional)
     * @param contextModelPk Context Model Primary Key (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param search A search term. (optional)
     * @param username Username (optional)
     * @return RequestConfig
     */
    fun eventsEventsVolumeListRequestConfig(action: kotlin.String?, brandName: kotlin.String?, clientIp: kotlin.String?, contextAuthorizedApp: kotlin.String?, contextModelApp: kotlin.String?, contextModelName: kotlin.String?, contextModelPk: kotlin.String?, ordering: kotlin.String?, search: kotlin.String?, username: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (action != null) {
                    put("action", listOf(action.toString()))
                }
                if (brandName != null) {
                    put("brand_name", listOf(brandName.toString()))
                }
                if (clientIp != null) {
                    put("client_ip", listOf(clientIp.toString()))
                }
                if (contextAuthorizedApp != null) {
                    put("context_authorized_app", listOf(contextAuthorizedApp.toString()))
                }
                if (contextModelApp != null) {
                    put("context_model_app", listOf(contextModelApp.toString()))
                }
                if (contextModelName != null) {
                    put("context_model_name", listOf(contextModelName.toString()))
                }
                if (contextModelPk != null) {
                    put("context_model_pk", listOf(contextModelPk.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (username != null) {
                    put("username", listOf(username.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/events/volume/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Notification Viewset
     * @param uuid A UUID string identifying this Notification.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsNotificationsDestroy(uuid: java.util.UUID) : Unit {
        val localVarResponse = eventsNotificationsDestroyWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Notification Viewset
     * @param uuid A UUID string identifying this Notification.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsNotificationsDestroyWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = eventsNotificationsDestroyRequestConfig(uuid = uuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsNotificationsDestroy
     *
     * @param uuid A UUID string identifying this Notification.
     * @return RequestConfig
     */
    fun eventsNotificationsDestroyRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/events/notifications/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter severity
     */
     enum class SeverityEventsNotificationsList(val value: kotlin.String) {
         @Json(name = "alert") alert("alert"),
         @Json(name = "notice") notice("notice"),
         @Json(name = "warning") warning("warning"),
     }

    /**
     * 
     * Notification Viewset
     * @param body  (optional)
     * @param created  (optional)
     * @param event  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param seen  (optional)
     * @param severity * &#x60;notice&#x60; - Notice * &#x60;warning&#x60; - Warning * &#x60;alert&#x60; - Alert (optional)
     * @param user  (optional)
     * @return PaginatedNotificationList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsNotificationsList(body: kotlin.String? = null, created: java.time.OffsetDateTime? = null, event: java.util.UUID? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, seen: kotlin.Boolean? = null, severity: SeverityEventsNotificationsList? = null, user: kotlin.Int? = null) : PaginatedNotificationList {
        val localVarResponse = eventsNotificationsListWithHttpInfo(body = body, created = created, event = event, ordering = ordering, page = page, pageSize = pageSize, search = search, seen = seen, severity = severity, user = user)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedNotificationList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Notification Viewset
     * @param body  (optional)
     * @param created  (optional)
     * @param event  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param seen  (optional)
     * @param severity * &#x60;notice&#x60; - Notice * &#x60;warning&#x60; - Warning * &#x60;alert&#x60; - Alert (optional)
     * @param user  (optional)
     * @return ApiResponse<PaginatedNotificationList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsNotificationsListWithHttpInfo(body: kotlin.String?, created: java.time.OffsetDateTime?, event: java.util.UUID?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, seen: kotlin.Boolean?, severity: SeverityEventsNotificationsList?, user: kotlin.Int?) : ApiResponse<PaginatedNotificationList?> {
        val localVariableConfig = eventsNotificationsListRequestConfig(body = body, created = created, event = event, ordering = ordering, page = page, pageSize = pageSize, search = search, seen = seen, severity = severity, user = user)

        return request<Unit, PaginatedNotificationList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsNotificationsList
     *
     * @param body  (optional)
     * @param created  (optional)
     * @param event  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param seen  (optional)
     * @param severity * &#x60;notice&#x60; - Notice * &#x60;warning&#x60; - Warning * &#x60;alert&#x60; - Alert (optional)
     * @param user  (optional)
     * @return RequestConfig
     */
    fun eventsNotificationsListRequestConfig(body: kotlin.String?, created: java.time.OffsetDateTime?, event: java.util.UUID?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, seen: kotlin.Boolean?, severity: SeverityEventsNotificationsList?, user: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (body != null) {
                    put("body", listOf(body.toString()))
                }
                if (created != null) {
                    put("created", listOf(parseDateToQueryString(created)))
                }
                if (event != null) {
                    put("event", listOf(event.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (seen != null) {
                    put("seen", listOf(seen.toString()))
                }
                if (severity != null) {
                    put("severity", listOf(severity.value))
                }
                if (user != null) {
                    put("user", listOf(user.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/notifications/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Mark all the user&#39;s notifications as seen
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsNotificationsMarkAllSeenCreate() : Unit {
        val localVarResponse = eventsNotificationsMarkAllSeenCreateWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Mark all the user&#39;s notifications as seen
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsNotificationsMarkAllSeenCreateWithHttpInfo() : ApiResponse<Unit?> {
        val localVariableConfig = eventsNotificationsMarkAllSeenCreateRequestConfig()

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsNotificationsMarkAllSeenCreate
     *
     * @return RequestConfig
     */
    fun eventsNotificationsMarkAllSeenCreateRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/events/notifications/mark_all_seen/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Notification Viewset
     * @param uuid A UUID string identifying this Notification.
     * @param patchedNotificationRequest  (optional)
     * @return Notification
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsNotificationsPartialUpdate(uuid: java.util.UUID, patchedNotificationRequest: PatchedNotificationRequest? = null) : Notification {
        val localVarResponse = eventsNotificationsPartialUpdateWithHttpInfo(uuid = uuid, patchedNotificationRequest = patchedNotificationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Notification
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Notification Viewset
     * @param uuid A UUID string identifying this Notification.
     * @param patchedNotificationRequest  (optional)
     * @return ApiResponse<Notification?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsNotificationsPartialUpdateWithHttpInfo(uuid: java.util.UUID, patchedNotificationRequest: PatchedNotificationRequest?) : ApiResponse<Notification?> {
        val localVariableConfig = eventsNotificationsPartialUpdateRequestConfig(uuid = uuid, patchedNotificationRequest = patchedNotificationRequest)

        return request<PatchedNotificationRequest, Notification>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsNotificationsPartialUpdate
     *
     * @param uuid A UUID string identifying this Notification.
     * @param patchedNotificationRequest  (optional)
     * @return RequestConfig
     */
    fun eventsNotificationsPartialUpdateRequestConfig(uuid: java.util.UUID, patchedNotificationRequest: PatchedNotificationRequest?) : RequestConfig<PatchedNotificationRequest> {
        val localVariableBody = patchedNotificationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/events/notifications/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Notification Viewset
     * @param uuid A UUID string identifying this Notification.
     * @return Notification
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsNotificationsRetrieve(uuid: java.util.UUID) : Notification {
        val localVarResponse = eventsNotificationsRetrieveWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Notification
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Notification Viewset
     * @param uuid A UUID string identifying this Notification.
     * @return ApiResponse<Notification?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsNotificationsRetrieveWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Notification?> {
        val localVariableConfig = eventsNotificationsRetrieveRequestConfig(uuid = uuid)

        return request<Unit, Notification>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsNotificationsRetrieve
     *
     * @param uuid A UUID string identifying this Notification.
     * @return RequestConfig
     */
    fun eventsNotificationsRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/notifications/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Notification Viewset
     * @param uuid A UUID string identifying this Notification.
     * @param notificationRequest  (optional)
     * @return Notification
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsNotificationsUpdate(uuid: java.util.UUID, notificationRequest: NotificationRequest? = null) : Notification {
        val localVarResponse = eventsNotificationsUpdateWithHttpInfo(uuid = uuid, notificationRequest = notificationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Notification
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Notification Viewset
     * @param uuid A UUID string identifying this Notification.
     * @param notificationRequest  (optional)
     * @return ApiResponse<Notification?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsNotificationsUpdateWithHttpInfo(uuid: java.util.UUID, notificationRequest: NotificationRequest?) : ApiResponse<Notification?> {
        val localVariableConfig = eventsNotificationsUpdateRequestConfig(uuid = uuid, notificationRequest = notificationRequest)

        return request<NotificationRequest, Notification>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsNotificationsUpdate
     *
     * @param uuid A UUID string identifying this Notification.
     * @param notificationRequest  (optional)
     * @return RequestConfig
     */
    fun eventsNotificationsUpdateRequestConfig(uuid: java.util.UUID, notificationRequest: NotificationRequest?) : RequestConfig<NotificationRequest> {
        val localVariableBody = notificationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/events/notifications/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Notification.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsNotificationsUsedByList(uuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = eventsNotificationsUsedByListWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Notification.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsNotificationsUsedByListWithHttpInfo(uuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = eventsNotificationsUsedByListRequestConfig(uuid = uuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsNotificationsUsedByList
     *
     * @param uuid A UUID string identifying this Notification.
     * @return RequestConfig
     */
    fun eventsNotificationsUsedByListRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/notifications/{uuid}/used_by/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationRule Viewset
     * @param notificationRuleRequest 
     * @return NotificationRule
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsRulesCreate(notificationRuleRequest: NotificationRuleRequest) : NotificationRule {
        val localVarResponse = eventsRulesCreateWithHttpInfo(notificationRuleRequest = notificationRuleRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationRule
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationRule Viewset
     * @param notificationRuleRequest 
     * @return ApiResponse<NotificationRule?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsRulesCreateWithHttpInfo(notificationRuleRequest: NotificationRuleRequest) : ApiResponse<NotificationRule?> {
        val localVariableConfig = eventsRulesCreateRequestConfig(notificationRuleRequest = notificationRuleRequest)

        return request<NotificationRuleRequest, NotificationRule>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsRulesCreate
     *
     * @param notificationRuleRequest 
     * @return RequestConfig
     */
    fun eventsRulesCreateRequestConfig(notificationRuleRequest: NotificationRuleRequest) : RequestConfig<NotificationRuleRequest> {
        val localVariableBody = notificationRuleRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/events/rules/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationRule Viewset
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsRulesDestroy(pbmUuid: java.util.UUID) : Unit {
        val localVarResponse = eventsRulesDestroyWithHttpInfo(pbmUuid = pbmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationRule Viewset
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsRulesDestroyWithHttpInfo(pbmUuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = eventsRulesDestroyRequestConfig(pbmUuid = pbmUuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsRulesDestroy
     *
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @return RequestConfig
     */
    fun eventsRulesDestroyRequestConfig(pbmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/events/rules/{pbm_uuid}/".replace("{"+"pbm_uuid"+"}", encodeURIComponent(pbmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter severity
     */
     enum class SeverityEventsRulesList(val value: kotlin.String) {
         @Json(name = "alert") alert("alert"),
         @Json(name = "notice") notice("notice"),
         @Json(name = "warning") warning("warning"),
     }

    /**
     * 
     * NotificationRule Viewset
     * @param groupName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param severity Controls which severity level the created notifications will have.  * &#x60;notice&#x60; - Notice * &#x60;warning&#x60; - Warning * &#x60;alert&#x60; - Alert (optional)
     * @return PaginatedNotificationRuleList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsRulesList(groupName: kotlin.String? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, severity: SeverityEventsRulesList? = null) : PaginatedNotificationRuleList {
        val localVarResponse = eventsRulesListWithHttpInfo(groupName = groupName, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, severity = severity)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedNotificationRuleList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationRule Viewset
     * @param groupName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param severity Controls which severity level the created notifications will have.  * &#x60;notice&#x60; - Notice * &#x60;warning&#x60; - Warning * &#x60;alert&#x60; - Alert (optional)
     * @return ApiResponse<PaginatedNotificationRuleList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsRulesListWithHttpInfo(groupName: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, severity: SeverityEventsRulesList?) : ApiResponse<PaginatedNotificationRuleList?> {
        val localVariableConfig = eventsRulesListRequestConfig(groupName = groupName, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, severity = severity)

        return request<Unit, PaginatedNotificationRuleList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsRulesList
     *
     * @param groupName  (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param severity Controls which severity level the created notifications will have.  * &#x60;notice&#x60; - Notice * &#x60;warning&#x60; - Warning * &#x60;alert&#x60; - Alert (optional)
     * @return RequestConfig
     */
    fun eventsRulesListRequestConfig(groupName: kotlin.String?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, severity: SeverityEventsRulesList?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (groupName != null) {
                    put("group__name", listOf(groupName.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (severity != null) {
                    put("severity", listOf(severity.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/rules/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationRule Viewset
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @param patchedNotificationRuleRequest  (optional)
     * @return NotificationRule
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsRulesPartialUpdate(pbmUuid: java.util.UUID, patchedNotificationRuleRequest: PatchedNotificationRuleRequest? = null) : NotificationRule {
        val localVarResponse = eventsRulesPartialUpdateWithHttpInfo(pbmUuid = pbmUuid, patchedNotificationRuleRequest = patchedNotificationRuleRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationRule
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationRule Viewset
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @param patchedNotificationRuleRequest  (optional)
     * @return ApiResponse<NotificationRule?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsRulesPartialUpdateWithHttpInfo(pbmUuid: java.util.UUID, patchedNotificationRuleRequest: PatchedNotificationRuleRequest?) : ApiResponse<NotificationRule?> {
        val localVariableConfig = eventsRulesPartialUpdateRequestConfig(pbmUuid = pbmUuid, patchedNotificationRuleRequest = patchedNotificationRuleRequest)

        return request<PatchedNotificationRuleRequest, NotificationRule>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsRulesPartialUpdate
     *
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @param patchedNotificationRuleRequest  (optional)
     * @return RequestConfig
     */
    fun eventsRulesPartialUpdateRequestConfig(pbmUuid: java.util.UUID, patchedNotificationRuleRequest: PatchedNotificationRuleRequest?) : RequestConfig<PatchedNotificationRuleRequest> {
        val localVariableBody = patchedNotificationRuleRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/events/rules/{pbm_uuid}/".replace("{"+"pbm_uuid"+"}", encodeURIComponent(pbmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationRule Viewset
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @return NotificationRule
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsRulesRetrieve(pbmUuid: java.util.UUID) : NotificationRule {
        val localVarResponse = eventsRulesRetrieveWithHttpInfo(pbmUuid = pbmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationRule
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationRule Viewset
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @return ApiResponse<NotificationRule?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsRulesRetrieveWithHttpInfo(pbmUuid: java.util.UUID) : ApiResponse<NotificationRule?> {
        val localVariableConfig = eventsRulesRetrieveRequestConfig(pbmUuid = pbmUuid)

        return request<Unit, NotificationRule>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsRulesRetrieve
     *
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @return RequestConfig
     */
    fun eventsRulesRetrieveRequestConfig(pbmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/rules/{pbm_uuid}/".replace("{"+"pbm_uuid"+"}", encodeURIComponent(pbmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationRule Viewset
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @param notificationRuleRequest 
     * @return NotificationRule
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsRulesUpdate(pbmUuid: java.util.UUID, notificationRuleRequest: NotificationRuleRequest) : NotificationRule {
        val localVarResponse = eventsRulesUpdateWithHttpInfo(pbmUuid = pbmUuid, notificationRuleRequest = notificationRuleRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationRule
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationRule Viewset
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @param notificationRuleRequest 
     * @return ApiResponse<NotificationRule?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsRulesUpdateWithHttpInfo(pbmUuid: java.util.UUID, notificationRuleRequest: NotificationRuleRequest) : ApiResponse<NotificationRule?> {
        val localVariableConfig = eventsRulesUpdateRequestConfig(pbmUuid = pbmUuid, notificationRuleRequest = notificationRuleRequest)

        return request<NotificationRuleRequest, NotificationRule>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsRulesUpdate
     *
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @param notificationRuleRequest 
     * @return RequestConfig
     */
    fun eventsRulesUpdateRequestConfig(pbmUuid: java.util.UUID, notificationRuleRequest: NotificationRuleRequest) : RequestConfig<NotificationRuleRequest> {
        val localVariableBody = notificationRuleRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/events/rules/{pbm_uuid}/".replace("{"+"pbm_uuid"+"}", encodeURIComponent(pbmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsRulesUsedByList(pbmUuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = eventsRulesUsedByListWithHttpInfo(pbmUuid = pbmUuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsRulesUsedByListWithHttpInfo(pbmUuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = eventsRulesUsedByListRequestConfig(pbmUuid = pbmUuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsRulesUsedByList
     *
     * @param pbmUuid A UUID string identifying this Notification Rule.
     * @return RequestConfig
     */
    fun eventsRulesUsedByListRequestConfig(pbmUuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/rules/{pbm_uuid}/used_by/".replace("{"+"pbm_uuid"+"}", encodeURIComponent(pbmUuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter status
     */
     enum class StatusEventsSystemTasksList(val value: kotlin.String) {
         @Json(name = "error") error("error"),
         @Json(name = "successful") successful("successful"),
         @Json(name = "unknown") unknown("unknown"),
         @Json(name = "warning") warning("warning"),
     }

    /**
     * 
     * Read-only view set that returns all background tasks
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param status * &#x60;unknown&#x60; - Unknown * &#x60;successful&#x60; - Successful * &#x60;warning&#x60; - Warning * &#x60;error&#x60; - Error (optional)
     * @param uid  (optional)
     * @return PaginatedSystemTaskList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsSystemTasksList(name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, status: StatusEventsSystemTasksList? = null, uid: kotlin.String? = null) : PaginatedSystemTaskList {
        val localVarResponse = eventsSystemTasksListWithHttpInfo(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, status = status, uid = uid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedSystemTaskList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Read-only view set that returns all background tasks
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param status * &#x60;unknown&#x60; - Unknown * &#x60;successful&#x60; - Successful * &#x60;warning&#x60; - Warning * &#x60;error&#x60; - Error (optional)
     * @param uid  (optional)
     * @return ApiResponse<PaginatedSystemTaskList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsSystemTasksListWithHttpInfo(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, status: StatusEventsSystemTasksList?, uid: kotlin.String?) : ApiResponse<PaginatedSystemTaskList?> {
        val localVariableConfig = eventsSystemTasksListRequestConfig(name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, status = status, uid = uid)

        return request<Unit, PaginatedSystemTaskList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsSystemTasksList
     *
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param status * &#x60;unknown&#x60; - Unknown * &#x60;successful&#x60; - Successful * &#x60;warning&#x60; - Warning * &#x60;error&#x60; - Error (optional)
     * @param uid  (optional)
     * @return RequestConfig
     */
    fun eventsSystemTasksListRequestConfig(name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, status: StatusEventsSystemTasksList?, uid: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.value))
                }
                if (uid != null) {
                    put("uid", listOf(uid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/system_tasks/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Read-only view set that returns all background tasks
     * @param uuid A UUID string identifying this System Task.
     * @return SystemTask
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsSystemTasksRetrieve(uuid: java.util.UUID) : SystemTask {
        val localVarResponse = eventsSystemTasksRetrieveWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SystemTask
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Read-only view set that returns all background tasks
     * @param uuid A UUID string identifying this System Task.
     * @return ApiResponse<SystemTask?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsSystemTasksRetrieveWithHttpInfo(uuid: java.util.UUID) : ApiResponse<SystemTask?> {
        val localVariableConfig = eventsSystemTasksRetrieveRequestConfig(uuid = uuid)

        return request<Unit, SystemTask>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsSystemTasksRetrieve
     *
     * @param uuid A UUID string identifying this System Task.
     * @return RequestConfig
     */
    fun eventsSystemTasksRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/system_tasks/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Run task
     * @param uuid A UUID string identifying this System Task.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsSystemTasksRunCreate(uuid: java.util.UUID) : Unit {
        val localVarResponse = eventsSystemTasksRunCreateWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Run task
     * @param uuid A UUID string identifying this System Task.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsSystemTasksRunCreateWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = eventsSystemTasksRunCreateRequestConfig(uuid = uuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsSystemTasksRunCreate
     *
     * @param uuid A UUID string identifying this System Task.
     * @return RequestConfig
     */
    fun eventsSystemTasksRunCreateRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/events/system_tasks/{uuid}/run/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationTransport Viewset
     * @param notificationTransportRequest 
     * @return NotificationTransport
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsTransportsCreate(notificationTransportRequest: NotificationTransportRequest) : NotificationTransport {
        val localVarResponse = eventsTransportsCreateWithHttpInfo(notificationTransportRequest = notificationTransportRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationTransport
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationTransport Viewset
     * @param notificationTransportRequest 
     * @return ApiResponse<NotificationTransport?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsTransportsCreateWithHttpInfo(notificationTransportRequest: NotificationTransportRequest) : ApiResponse<NotificationTransport?> {
        val localVariableConfig = eventsTransportsCreateRequestConfig(notificationTransportRequest = notificationTransportRequest)

        return request<NotificationTransportRequest, NotificationTransport>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsTransportsCreate
     *
     * @param notificationTransportRequest 
     * @return RequestConfig
     */
    fun eventsTransportsCreateRequestConfig(notificationTransportRequest: NotificationTransportRequest) : RequestConfig<NotificationTransportRequest> {
        val localVariableBody = notificationTransportRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/events/transports/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationTransport Viewset
     * @param uuid A UUID string identifying this Notification Transport.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsTransportsDestroy(uuid: java.util.UUID) : Unit {
        val localVarResponse = eventsTransportsDestroyWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationTransport Viewset
     * @param uuid A UUID string identifying this Notification Transport.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsTransportsDestroyWithHttpInfo(uuid: java.util.UUID) : ApiResponse<Unit?> {
        val localVariableConfig = eventsTransportsDestroyRequestConfig(uuid = uuid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsTransportsDestroy
     *
     * @param uuid A UUID string identifying this Notification Transport.
     * @return RequestConfig
     */
    fun eventsTransportsDestroyRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/events/transports/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter mode
     */
     enum class ModeEventsTransportsList(val value: kotlin.String) {
         @Json(name = "email") email("email"),
         @Json(name = "local") local("local"),
         @Json(name = "webhook") webhook("webhook"),
         @Json(name = "webhook_slack") webhookSlack("webhook_slack"),
     }

    /**
     * 
     * NotificationTransport Viewset
     * @param mode * &#x60;local&#x60; - authentik inbuilt notifications * &#x60;webhook&#x60; - Generic Webhook * &#x60;webhook_slack&#x60; - Slack Webhook (Slack/Discord) * &#x60;email&#x60; - Email (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sendOnce  (optional)
     * @param webhookUrl  (optional)
     * @return PaginatedNotificationTransportList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsTransportsList(mode: ModeEventsTransportsList? = null, name: kotlin.String? = null, ordering: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, search: kotlin.String? = null, sendOnce: kotlin.Boolean? = null, webhookUrl: kotlin.String? = null) : PaginatedNotificationTransportList {
        val localVarResponse = eventsTransportsListWithHttpInfo(mode = mode, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, sendOnce = sendOnce, webhookUrl = webhookUrl)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedNotificationTransportList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationTransport Viewset
     * @param mode * &#x60;local&#x60; - authentik inbuilt notifications * &#x60;webhook&#x60; - Generic Webhook * &#x60;webhook_slack&#x60; - Slack Webhook (Slack/Discord) * &#x60;email&#x60; - Email (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sendOnce  (optional)
     * @param webhookUrl  (optional)
     * @return ApiResponse<PaginatedNotificationTransportList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsTransportsListWithHttpInfo(mode: ModeEventsTransportsList?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, sendOnce: kotlin.Boolean?, webhookUrl: kotlin.String?) : ApiResponse<PaginatedNotificationTransportList?> {
        val localVariableConfig = eventsTransportsListRequestConfig(mode = mode, name = name, ordering = ordering, page = page, pageSize = pageSize, search = search, sendOnce = sendOnce, webhookUrl = webhookUrl)

        return request<Unit, PaginatedNotificationTransportList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsTransportsList
     *
     * @param mode * &#x60;local&#x60; - authentik inbuilt notifications * &#x60;webhook&#x60; - Generic Webhook * &#x60;webhook_slack&#x60; - Slack Webhook (Slack/Discord) * &#x60;email&#x60; - Email (optional)
     * @param name  (optional)
     * @param ordering Which field to use when ordering the results. (optional)
     * @param page A page number within the paginated result set. (optional)
     * @param pageSize Number of results to return per page. (optional)
     * @param search A search term. (optional)
     * @param sendOnce  (optional)
     * @param webhookUrl  (optional)
     * @return RequestConfig
     */
    fun eventsTransportsListRequestConfig(mode: ModeEventsTransportsList?, name: kotlin.String?, ordering: kotlin.String?, page: kotlin.Int?, pageSize: kotlin.Int?, search: kotlin.String?, sendOnce: kotlin.Boolean?, webhookUrl: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (mode != null) {
                    put("mode", listOf(mode.value))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (ordering != null) {
                    put("ordering", listOf(ordering.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (sendOnce != null) {
                    put("send_once", listOf(sendOnce.toString()))
                }
                if (webhookUrl != null) {
                    put("webhook_url", listOf(webhookUrl.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/transports/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationTransport Viewset
     * @param uuid A UUID string identifying this Notification Transport.
     * @param patchedNotificationTransportRequest  (optional)
     * @return NotificationTransport
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsTransportsPartialUpdate(uuid: java.util.UUID, patchedNotificationTransportRequest: PatchedNotificationTransportRequest? = null) : NotificationTransport {
        val localVarResponse = eventsTransportsPartialUpdateWithHttpInfo(uuid = uuid, patchedNotificationTransportRequest = patchedNotificationTransportRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationTransport
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationTransport Viewset
     * @param uuid A UUID string identifying this Notification Transport.
     * @param patchedNotificationTransportRequest  (optional)
     * @return ApiResponse<NotificationTransport?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsTransportsPartialUpdateWithHttpInfo(uuid: java.util.UUID, patchedNotificationTransportRequest: PatchedNotificationTransportRequest?) : ApiResponse<NotificationTransport?> {
        val localVariableConfig = eventsTransportsPartialUpdateRequestConfig(uuid = uuid, patchedNotificationTransportRequest = patchedNotificationTransportRequest)

        return request<PatchedNotificationTransportRequest, NotificationTransport>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsTransportsPartialUpdate
     *
     * @param uuid A UUID string identifying this Notification Transport.
     * @param patchedNotificationTransportRequest  (optional)
     * @return RequestConfig
     */
    fun eventsTransportsPartialUpdateRequestConfig(uuid: java.util.UUID, patchedNotificationTransportRequest: PatchedNotificationTransportRequest?) : RequestConfig<PatchedNotificationTransportRequest> {
        val localVariableBody = patchedNotificationTransportRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/events/transports/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationTransport Viewset
     * @param uuid A UUID string identifying this Notification Transport.
     * @return NotificationTransport
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsTransportsRetrieve(uuid: java.util.UUID) : NotificationTransport {
        val localVarResponse = eventsTransportsRetrieveWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationTransport
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationTransport Viewset
     * @param uuid A UUID string identifying this Notification Transport.
     * @return ApiResponse<NotificationTransport?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsTransportsRetrieveWithHttpInfo(uuid: java.util.UUID) : ApiResponse<NotificationTransport?> {
        val localVariableConfig = eventsTransportsRetrieveRequestConfig(uuid = uuid)

        return request<Unit, NotificationTransport>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsTransportsRetrieve
     *
     * @param uuid A UUID string identifying this Notification Transport.
     * @return RequestConfig
     */
    fun eventsTransportsRetrieveRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/transports/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Send example notification using selected transport. Requires Modify permissions.
     * @param uuid A UUID string identifying this Notification Transport.
     * @return NotificationTransportTest
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsTransportsTestCreate(uuid: java.util.UUID) : NotificationTransportTest {
        val localVarResponse = eventsTransportsTestCreateWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationTransportTest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Send example notification using selected transport. Requires Modify permissions.
     * @param uuid A UUID string identifying this Notification Transport.
     * @return ApiResponse<NotificationTransportTest?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsTransportsTestCreateWithHttpInfo(uuid: java.util.UUID) : ApiResponse<NotificationTransportTest?> {
        val localVariableConfig = eventsTransportsTestCreateRequestConfig(uuid = uuid)

        return request<Unit, NotificationTransportTest>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsTransportsTestCreate
     *
     * @param uuid A UUID string identifying this Notification Transport.
     * @return RequestConfig
     */
    fun eventsTransportsTestCreateRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/events/transports/{uuid}/test/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * NotificationTransport Viewset
     * @param uuid A UUID string identifying this Notification Transport.
     * @param notificationTransportRequest 
     * @return NotificationTransport
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsTransportsUpdate(uuid: java.util.UUID, notificationTransportRequest: NotificationTransportRequest) : NotificationTransport {
        val localVarResponse = eventsTransportsUpdateWithHttpInfo(uuid = uuid, notificationTransportRequest = notificationTransportRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationTransport
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * NotificationTransport Viewset
     * @param uuid A UUID string identifying this Notification Transport.
     * @param notificationTransportRequest 
     * @return ApiResponse<NotificationTransport?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsTransportsUpdateWithHttpInfo(uuid: java.util.UUID, notificationTransportRequest: NotificationTransportRequest) : ApiResponse<NotificationTransport?> {
        val localVariableConfig = eventsTransportsUpdateRequestConfig(uuid = uuid, notificationTransportRequest = notificationTransportRequest)

        return request<NotificationTransportRequest, NotificationTransport>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsTransportsUpdate
     *
     * @param uuid A UUID string identifying this Notification Transport.
     * @param notificationTransportRequest 
     * @return RequestConfig
     */
    fun eventsTransportsUpdateRequestConfig(uuid: java.util.UUID, notificationTransportRequest: NotificationTransportRequest) : RequestConfig<NotificationTransportRequest> {
        val localVariableBody = notificationTransportRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/events/transports/{uuid}/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Notification Transport.
     * @return kotlin.collections.List<UsedBy>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun eventsTransportsUsedByList(uuid: java.util.UUID) : kotlin.collections.List<UsedBy> {
        val localVarResponse = eventsTransportsUsedByListWithHttpInfo(uuid = uuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UsedBy>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of all objects that use this object
     * @param uuid A UUID string identifying this Notification Transport.
     * @return ApiResponse<kotlin.collections.List<UsedBy>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun eventsTransportsUsedByListWithHttpInfo(uuid: java.util.UUID) : ApiResponse<kotlin.collections.List<UsedBy>?> {
        val localVariableConfig = eventsTransportsUsedByListRequestConfig(uuid = uuid)

        return request<Unit, kotlin.collections.List<UsedBy>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation eventsTransportsUsedByList
     *
     * @param uuid A UUID string identifying this Notification Transport.
     * @return RequestConfig
     */
    fun eventsTransportsUsedByListRequestConfig(uuid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/events/transports/{uuid}/used_by/".replace("{"+"uuid"+"}", encodeURIComponent(uuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
