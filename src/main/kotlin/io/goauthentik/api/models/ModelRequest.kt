/**
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2023.10.3
 * Contact: hello@goauthentik.io
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.goauthentik.api.models

import io.goauthentik.api.models.ClientTypeEnum
import io.goauthentik.api.models.DigestAlgorithmEnum
import io.goauthentik.api.models.IssuerModeEnum
import io.goauthentik.api.models.LDAPAPIAccessMode
import io.goauthentik.api.models.LDAPProviderRequest
import io.goauthentik.api.models.OAuth2ProviderRequest
import io.goauthentik.api.models.ProxyMode
import io.goauthentik.api.models.ProxyProviderRequest
import io.goauthentik.api.models.RadiusProviderRequest
import io.goauthentik.api.models.SAMLProviderRequest
import io.goauthentik.api.models.SCIMProviderRequest
import io.goauthentik.api.models.SignatureAlgorithmEnum
import io.goauthentik.api.models.SpBindingEnum
import io.goauthentik.api.models.SubModeEnum

import com.squareup.moshi.Json

/**
 * 
 *
 * @param name 
 * @param authorizationFlow Flow used when authorizing this provider.
 * @param externalHost 
 * @param acsUrl 
 * @param url Base URL to SCIM requests, usually ends in /v2
 * @param token Authentication token
 * @param authenticationFlow Flow used for authentication when the associated application is accessed by an un-authenticated user.
 * @param propertyMappings 
 * @param baseDn DN under which objects are accessible.
 * @param searchGroup Users in this group can do search queries. If not set, every user can execute search queries.
 * @param certificate 
 * @param tlsServerName 
 * @param uidStartNumber The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber
 * @param gidStartNumber The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber
 * @param searchMode 
 * @param bindMode 
 * @param mfaSupport When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.
 * @param clientType Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable  * `confidential` - Confidential * `public` - Public
 * @param clientId 
 * @param clientSecret 
 * @param accessCodeValidity Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
 * @param accessTokenValidity Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
 * @param refreshTokenValidity Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
 * @param includeClaimsInIdToken Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint.
 * @param signingKey Key used to sign the tokens. Only required when JWT Algorithm is set to RS256.
 * @param redirectUris Enter each URI on a new line.
 * @param subMode Configure what data should be used as unique User Identifier. For most cases, the default should be fine.  * `hashed_user_id` - Based on the Hashed User ID * `user_id` - Based on user ID * `user_uuid` - Based on user UUID * `user_username` - Based on the username * `user_email` - Based on the User's Email. This is recommended over the UPN method. * `user_upn` - Based on the User's UPN, only works if user has a 'upn' attribute set. Use this method only if you have different UPN and Mail domains.
 * @param issuerMode Configure how the issuer field of the ID Token should be filled.  * `global` - Same identifier is used for all providers * `per_provider` - Each provider has a different issuer, based on the application slug.
 * @param jwksSources 
 * @param internalHost 
 * @param internalHostSslValidation Validate SSL Certificates of upstream servers
 * @param skipPathRegex Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.
 * @param basicAuthEnabled Set a custom HTTP-Basic Authentication header based on values from authentik.
 * @param basicAuthPasswordAttribute User/Group Attribute used for the password part of the HTTP-Basic Header.
 * @param basicAuthUserAttribute User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.
 * @param mode Enable support for forwardAuth in traefik and nginx auth_request. Exclusive with internal_host.  * `proxy` - Proxy * `forward_single` - Forward Single * `forward_domain` - Forward Domain
 * @param interceptHeaderAuth When enabled, this provider will intercept the authorization header and authenticate requests based on its value.
 * @param cookieDomain 
 * @param clientNetworks List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped.
 * @param sharedSecret Shared secret between clients and server to hash packets.
 * @param audience Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added.
 * @param issuer Also known as EntityID
 * @param assertionValidNotBefore Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3).
 * @param assertionValidNotOnOrAfter Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
 * @param sessionValidNotOnOrAfter Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).
 * @param nameIdMapping Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered
 * @param digestAlgorithm 
 * @param signatureAlgorithm 
 * @param signingKp Keypair used to sign outgoing Responses going to the Service Provider.
 * @param verificationKp When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.
 * @param spBinding This determines how authentik sends the response back to the Service Provider.  * `redirect` - Redirect * `post` - Post
 * @param defaultRelayState Default relay_state value for IDP-initiated logins
 * @param propertyMappingsGroup Property mappings used for group creation/updating.
 * @param excludeUsersServiceAccount 
 * @param filterGroup 
 */

interface ModelRequest {

    @Json(name = "name")
    val name: kotlin.String
    /* Flow used when authorizing this provider. */
    @Json(name = "authorization_flow")
    val authorizationFlow: java.util.UUID
    @Json(name = "external_host")
    val externalHost: java.net.URI
    @Json(name = "acs_url")
    val acsUrl: java.net.URI
    /* Base URL to SCIM requests, usually ends in /v2 */
    @Json(name = "url")
    val url: kotlin.String
    /* Authentication token */
    @Json(name = "token")
    val token: kotlin.String
    /* Flow used for authentication when the associated application is accessed by an un-authenticated user. */
    @Json(name = "authentication_flow")
    val authenticationFlow: java.util.UUID?
    @Json(name = "property_mappings")
    val propertyMappings: kotlin.collections.List<java.util.UUID>?
    /* DN under which objects are accessible. */
    @Json(name = "base_dn")
    val baseDn: kotlin.String?
    /* Users in this group can do search queries. If not set, every user can execute search queries. */
    @Json(name = "search_group")
    val searchGroup: java.util.UUID?
    @Json(name = "certificate")
    val certificate: java.util.UUID?
    @Json(name = "tls_server_name")
    val tlsServerName: kotlin.String?
    /* The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber */
    @Json(name = "uid_start_number")
    val uidStartNumber: kotlin.Int?
    /* The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber */
    @Json(name = "gid_start_number")
    val gidStartNumber: kotlin.Int?
    @Json(name = "search_mode")
    val searchMode: LDAPAPIAccessMode?
    @Json(name = "bind_mode")
    val bindMode: LDAPAPIAccessMode?
    /* When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon. */
    @Json(name = "mfa_support")
    val mfaSupport: kotlin.Boolean?
    /* Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable  * `confidential` - Confidential * `public` - Public */
    @Json(name = "client_type")
    val clientType: ClientTypeEnum?
    @Json(name = "client_id")
    val clientId: kotlin.String?
    @Json(name = "client_secret")
    val clientSecret: kotlin.String?
    /* Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
    @Json(name = "access_code_validity")
    val accessCodeValidity: kotlin.String?
    /* Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
    @Json(name = "access_token_validity")
    val accessTokenValidity: kotlin.String?
    /* Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
    @Json(name = "refresh_token_validity")
    val refreshTokenValidity: kotlin.String?
    /* Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint. */
    @Json(name = "include_claims_in_id_token")
    val includeClaimsInIdToken: kotlin.Boolean?
    /* Key used to sign the tokens. Only required when JWT Algorithm is set to RS256. */
    @Json(name = "signing_key")
    val signingKey: java.util.UUID?
    /* Enter each URI on a new line. */
    @Json(name = "redirect_uris")
    val redirectUris: kotlin.String?
    /* Configure what data should be used as unique User Identifier. For most cases, the default should be fine.  * `hashed_user_id` - Based on the Hashed User ID * `user_id` - Based on user ID * `user_uuid` - Based on user UUID * `user_username` - Based on the username * `user_email` - Based on the User's Email. This is recommended over the UPN method. * `user_upn` - Based on the User's UPN, only works if user has a 'upn' attribute set. Use this method only if you have different UPN and Mail domains. */
    @Json(name = "sub_mode")
    val subMode: SubModeEnum?
    /* Configure how the issuer field of the ID Token should be filled.  * `global` - Same identifier is used for all providers * `per_provider` - Each provider has a different issuer, based on the application slug. */
    @Json(name = "issuer_mode")
    val issuerMode: IssuerModeEnum?
    @Json(name = "jwks_sources")
    val jwksSources: kotlin.collections.List<java.util.UUID>?
    @Json(name = "internal_host")
    val internalHost: java.net.URI?
    /* Validate SSL Certificates of upstream servers */
    @Json(name = "internal_host_ssl_validation")
    val internalHostSslValidation: kotlin.Boolean?
    /* Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression. */
    @Json(name = "skip_path_regex")
    val skipPathRegex: kotlin.String?
    /* Set a custom HTTP-Basic Authentication header based on values from authentik. */
    @Json(name = "basic_auth_enabled")
    val basicAuthEnabled: kotlin.Boolean?
    /* User/Group Attribute used for the password part of the HTTP-Basic Header. */
    @Json(name = "basic_auth_password_attribute")
    val basicAuthPasswordAttribute: kotlin.String?
    /* User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used. */
    @Json(name = "basic_auth_user_attribute")
    val basicAuthUserAttribute: kotlin.String?
    /* Enable support for forwardAuth in traefik and nginx auth_request. Exclusive with internal_host.  * `proxy` - Proxy * `forward_single` - Forward Single * `forward_domain` - Forward Domain */
    @Json(name = "mode")
    val mode: ProxyMode?
    /* When enabled, this provider will intercept the authorization header and authenticate requests based on its value. */
    @Json(name = "intercept_header_auth")
    val interceptHeaderAuth: kotlin.Boolean?
    @Json(name = "cookie_domain")
    val cookieDomain: kotlin.String?
    /* List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped. */
    @Json(name = "client_networks")
    val clientNetworks: kotlin.String?
    /* Shared secret between clients and server to hash packets. */
    @Json(name = "shared_secret")
    val sharedSecret: kotlin.String?
    /* Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added. */
    @Json(name = "audience")
    val audience: kotlin.String?
    /* Also known as EntityID */
    @Json(name = "issuer")
    val issuer: kotlin.String?
    /* Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3). */
    @Json(name = "assertion_valid_not_before")
    val assertionValidNotBefore: kotlin.String?
    /* Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
    @Json(name = "assertion_valid_not_on_or_after")
    val assertionValidNotOnOrAfter: kotlin.String?
    /* Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3). */
    @Json(name = "session_valid_not_on_or_after")
    val sessionValidNotOnOrAfter: kotlin.String?
    /* Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered */
    @Json(name = "name_id_mapping")
    val nameIdMapping: java.util.UUID?
    @Json(name = "digest_algorithm")
    val digestAlgorithm: DigestAlgorithmEnum?
    @Json(name = "signature_algorithm")
    val signatureAlgorithm: SignatureAlgorithmEnum?
    /* Keypair used to sign outgoing Responses going to the Service Provider. */
    @Json(name = "signing_kp")
    val signingKp: java.util.UUID?
    /* When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default. */
    @Json(name = "verification_kp")
    val verificationKp: java.util.UUID?
    /* This determines how authentik sends the response back to the Service Provider.  * `redirect` - Redirect * `post` - Post */
    @Json(name = "sp_binding")
    val spBinding: SpBindingEnum?
    /* Default relay_state value for IDP-initiated logins */
    @Json(name = "default_relay_state")
    val defaultRelayState: kotlin.String?
    /* Property mappings used for group creation/updating. */
    @Json(name = "property_mappings_group")
    val propertyMappingsGroup: kotlin.collections.List<java.util.UUID>?
    @Json(name = "exclude_users_service_account")
    val excludeUsersServiceAccount: kotlin.Boolean?
    @Json(name = "filter_group")
    val filterGroup: java.util.UUID?
}

